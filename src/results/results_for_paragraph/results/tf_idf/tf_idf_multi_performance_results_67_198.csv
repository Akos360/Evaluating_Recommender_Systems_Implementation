book_index,paragraph_index,similarity_score,recommended_book,recommended_text
59,691,0.635,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"pomocou pravidiel. TÃ¡to skutoÄnosÅ¥ otvÃ¡ra novÃ© moÅ¾nosti vÃ½skumu v kognitÃ­vnej vede v oblasti rieÅ¡enia problÃ©mov, vytvÃ¡raÅ¥ mentÃ¡lne modely pouÅ¾Ã­vania zÃ¡kladnÃ©ho mentÃ¡lneho modelu, t. j. hÄ¾adaÅ¥ pravidlÃ¡ â regularity pre pouÅ¾Ã­vania pravidiel 0 â 3. PoznÃ¡mka 1: V kapitole 3 boli Å¡pecifikovanÃ© zÃ¡kladnÃ© princÃ­py evoluÄnÃ½ch algoritmov, ktorÃ© moÅ¾no charakterizovaÅ¥ ako stochastickÃ© optimalizaÄnÃ© algoritmy akcelerovanÃ© heuristikou darwinovskÃ©ho prirodzenÃ©ho vÃ½beru. Tieto algoritmy sÃº aplikovateÄ¾nÃ© aj na rieÅ¡enie sudoku. V dÃ´sledku ich stochastiÄnosti, zapÄºÅanie prÃ¡zdnych buniek v matici sa deje kvÃ¡zi-nÃ¡hodne. Ich efektivita rieÅ¡enia uÅ¾ najjednoduchÅ¡Ã­ch sudoku nie je veÄ¾kÃ¡. TÃ½m, ako bolo ukÃ¡zanÃ© v predchÃ¡dzajÃºcej Äasti tejto publikÃ¡cie, Å¾e obsadzovanie prÃ¡zdnych buniek je deterministickÃ½ problÃ©m riadenÃ½ jednoduchÃ½mi logickÃ½mi Ãºvahami, pouÅ¾itie evoluÄnÃ½ch algoritmov (aj keÄ v princÃ­pu moÅ¾nÃ©) nie je vhodnÃ½m prÃ­stupom k rieÅ¡eniu sudoku. ÄalÅ¡Ã­ problÃ©m s pouÅ¾itÃ­m evoluÄnÃ½ch algoritmov pre rieÅ¡enie sudoku spoÄÃ­va v tom, Å¾e poÅ¾adovanÃ© rieÅ¡enie je reprezentovanÃ© globÃ¡lnym minimom, inÃ© â suboptimÃ¡lne rieÅ¡enia sÃº nezaujÃ­mavÃ©, priÄom evoluÄnÃ© algoritmy svoju efektÃ­vnosÅ¥ manifestujÃº schopnosÅ¥ou rÃ½chlej konÅ¡trukcie prÃ¡ve suboptimÃ¡lneho rieÅ¡enia. PoznÃ¡mka 2: Chceme upozorniÅ¥ seniorov informatickej komunity na skutoÄnosÅ¥, Å¾e rieÅ¡enie sudoku je v podstate deterministickÃ½ problÃ©m riadenÃ½ jednoduchÃ½mi logickÃ½mi Ãºvahami. MetÃ³da rieÅ¡enia sudoku prezentovanÃ¡ v tejto prÃ¡ci mÃ¡ jednoduchÃ½ algoritmickÃ½ charakter a preto je zaujÃ­mavÃ¡ aj pre seniorov ako vhodnÃ© âprecviÄovanieâ kognitÃ­vneho aparÃ¡tu â mozgu (pre ktorÃ½ platÃ­ to, Äo platÃ­ pre kaÅ¾dÃ½ orgÃ¡n, jeho âneprecviÄovanieâ vedie k jeho atrofii)."
59,689,0.629,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"3. VeÄ¾mi zloÅ¾itÃ© rieÅ¡enie (diabolskÃ©), kde sa aspoÅ raz musÃ­ pouÅ¾iÅ¥ nÃ¡hodnÃ½ vÃ½ber alternatÃ­vnej moÅ¾nosti s moÅ¾nÃ½m nÃ¡vratom do bodu vetvenia, ak sme dostali nekorektnÃº pozÃ­ciu v ÄalÅ¡om predlÅ¾ovanÃ­ rieÅ¡enia (pozri Obr. 14.8). NeexistujÃº pevnÃ© hranice medzi oblasÅ¥ami zloÅ¾itosti hier sudoku, vyÅ¡Å¡ie navrhnutÃ¡ klasifikÃ¡cia vÅ¡ak odrÃ¡Å¾a zÃ¡kladnÃ© princÃ­py zloÅ¾itosti ich rieÅ¡enia. Pre nÃ¡s je vÅ¡ak dÃ´leÅ¾itÃ©, Å¾e navrhnutÃ½ mentÃ¡lny model hry sudoku je dostatoÄne jednoduchÃ½, aby slÃºÅ¾il ako nÃ¡vod k systematickÃ©mu rieÅ¡eniu Ãºloh hier sudoku a taktieÅ¾, ktorÃ½ taktieÅ¾ odrÃ¡Å¾a pomerne verne âexperimentÃ¡lne pozorovanieâ o zloÅ¾itosti ich rieÅ¡enia."
59,685,0.628,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"14.4 StratÃ©gia rieÅ¡enia StratÃ©gia rieÅ¡enia hry sudoku obsahuje postupnosÅ¥ tÃ½chto krokov: 1. krok. PoÄiatoÄnÃº pozÃ­ciu doplnÃ­me v kaÅ¾dej prÃ¡zdnej bunke o alternatÃ­vne moÅ¾nosti. 2. krok. Ak v alternatÃ­vnych moÅ¾nostiach pre danÃ½ riadok, alebo stÄºpec, alebo podoblasÅ¥ sa vyskytuje nejakÃ© ÄÃ­slo prÃ¡ve raz, potom tÃ½mto ÄÃ­slom obsadÃ­me danÃº bunku. 3. krok. Opakovane aplikujeme na pozÃ­ciu pravidlÃ¡ 1-3 tak, aby sa pozÃ­cia neustÃ¡le zjednoduÅ¡ovala buÄ zruÅ¡enÃ­m (pravidlÃ¡ 2 a 3) vybranÃ½ch alternatÃ­vnych moÅ¾nostÃ­ alebo obsadenÃ­m vybranej bunky fixnÃ½m ÄÃ­slom (pravidlo 1). 4. krok. V prÃ­pade, Å¾e pozÃ­cia obsahuje eÅ¡te alternatÃ­vne moÅ¾nosti a nie je moÅ¾nÃ© vykonaÅ¥ 3. krok (bod vetvenia, pozri Obr. 14.8), nÃ¡hodne vyberieme z aktuÃ¡lnej pozÃ­cie jednu alternatÃ­vnu moÅ¾nosÅ¥ a s Åou obsadÃ­me danÃº bunku. Ak sa nÃ¡m v ÄalÅ¡om rieÅ¡enÃ­ od bodu vetvenia objavÃ­ nekorektnÃ¡ pozÃ­cia (v niektorom riadku/stÄºpci/podoblasti sa vyskytujÃº dve rovnakÃ© ÄÃ­sla), potom sa vrÃ¡time do bodu rieÅ¡enia, opakovane nÃ¡hodne vyberieme inÃº alternatÃ­vnu moÅ¾nosÅ¥ a opakovane pokraÄujeme v rieÅ¡enÃ­. 5. krok. Ak sme dospeli v rieÅ¡enÃ­ do korektnej koneÄnej pozÃ­cie, kde vÅ¡etky pÃ´vodne prÃ¡zdne bunky sÃº obsadenÃ© ÄÃ­slami, hru ukonÄÃ­me a zÃ­skanÃ¡ pozÃ­cia je rieÅ¡enÃ­m hry sudoku. Pomocou tejto stratÃ©gie mÃ´Å¾eme zaviesÅ¥ klasifikÃ¡ciu rieÅ¡enÃ­ hry sudoku:"
59,224,0.612,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"naÅ¡li sprÃ¡vne rieÅ¡enie (t. j. ihlu v kope sena), musÃ­me prekontrolovaÅ¥ vÅ¡etky prÃ­pustnÃ© rieÅ¡enia, Äo je vlastne ten najhorÅ¡Ã­ moÅ¾nÃ½ algoritmus rieÅ¡enia danÃ©ho problÃ©mu. AvÅ¡ak, ak pouÅ¾Ã­vame efektÃ­vne fitnes, ktorÃ© je nenulovÃ© aj v blÃ­zkom okolÃ­ hÄ¾adanÃ©ho rieÅ¡enia, mÃ¡me podstatne vÃ¤ÄÅ¡iu Å¡ancu nÃ¡jsÅ¥ sprÃ¡vne rieÅ¡enie. MÃ´Å¾eme povedaÅ¥, Å¾e efektÃ­vne fitnes nÃ¡s proces prehÄ¾adÃ¡vania naviguje smerom, kde sÃº vÃ¤ÄÅ¡ie hodnoty efektÃ­vneho fitnes. fitnes"
393,539,0.589,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 2,"Na druhej strane Å¡tandardnÃ© objektovo-orientovanÃ© jazyky ponÃºkajÃº iba zÃ¡kladnÃ© prostriedky pre znovupouÅ¾itie. V mnohÃ½ch prÃ­padoch objektovo-orientovanÃ© jazyky, ktorÃ© patria do tejto skupiny, disponujÃº jazykovo Å¡pecifickÃ½m prostriedkami ako naprÃ­klad generickÃ© triedy alebo viacnÃ¡sobnÃ© dedenie, ktorÃ© sÃº sÃ­ce pomerne jednoducho v danom jazyku pouÅ¾iteÄ¾nÃ©, no pri nutnosti portovania takÃ©hoto rieÅ¡enia na inÃ½ implementaÄnÃ½ jazyk sa vynÃ¡rajÃº problÃ©my spojenÃ© s realizÃ¡ciou tÃ½chto Å¡pecifÃ­k pomocou prostriedkov jazyka, ktorÃ© sÃº k dispozÃ­cii. NavyÅ¡e pri niektorÃ½ch nÃ¡vrhovÃ½ch vzoroch nemusia postaÄovaÅ¥ ani tieto jazykovo Å¡pecifickÃ© prostriedky pre vytvorenie prehÄ¾adnÃ©ho rieÅ¡enia. CelÃ© snaÅ¾enie a zÃ¡very z jednotlivÃ½ch ÄastÃ­ zaoberajÃºcimi sa znovupouÅ¾Ã­tÃ­m ÄastÃ­ nÃ¡vrhovÃ½ch vzorov akoby smerovali k univerzÃ¡lnym rozÅ¡Ã­reniam jazyka, ktorÃ© budÃº realizovateÄ¾nÃ© vo vÃ¤ÄÅ¡ej skupine jazykov a aplikaÄnÃ©mu programÃ¡torovi poskytnÃº rozÅ¡Ã­renÃ© moÅ¾nosti znovupouÅ¾itia tried, metÃ³d a v koneÄnom dÃ´sledku i samotnÃ½ch nÃ¡vrhovÃ½ch vzorov. RieÅ¡enie sa ponÃºka formou znovupouÅ¾itia koncernov s vyuÅ¾itÃ­m adaptÃ¡ciÃ­. AnalÃ½za rieÅ¡enia s prekompilÃ¡torom pre jazyk JAVA ukÃ¡zala, Å¾e ide o pomerne jazykovo nezÃ¡vislÃ© rieÅ¡enie rozÅ¡irujÃºce moÅ¾nosti znovupouÅ¾itia zdrojovÃ©ho kÃ³du ako takÃ©ho. UmoÅ¾nenÃ­m vytvÃ¡rania hierarchiÃ­ adaptÃ©rov a oddelenÃ­m spoloÄnÃ©ho zdrojovÃ©ho kÃ³du od Å¡pecifickÃ©ho sa v koneÄnom dÃ´sledku zvÃ½Å¡i prehÄ¾adnosÅ¥ rieÅ¡enia a jeho udrÅ¾iavateÄ¾nosÅ¥. Na druhej strane sme nemali moÅ¾nosÅ¥ vyskÃºÅ¡aÅ¥ rieÅ¡enie na vlastnom prÃ­klade, a teda nevieme, ako sa prekompilÃ¡tor chovÃ¡ aj v prÃ­pade jednoduchÃ½ch syntaktickÃ½ch chÃ½b v adaptÃ©roch. Prostriedky, s ktorÃ½mi priÅ¡li autori tohto rieÅ¡enia, sa zdajÃº postaÄujÃºce na vytvorenie kniÅ¾nice znovupouÅ¾iteÄ¾nÃ½ch nÃ¡vrhovÃ½ch vzorov, priÄom oddelenie vÅ¡eobecnÃ½ch ÄastÃ­ od domÃ©novo zÃ¡vislÃ½ch ako i pouÅ¾itie nÃ¡vrhovÃ©ho vzoru z kniÅ¾nice by malo zostaÅ¥ prehÄ¾adnÃ©, zrozumiteÄ¾nÃ© a Ä¾ahko udrÅ¾iavateÄ¾nÃ©. Od CASE nÃ¡strojov cez atypickÃ© a Å¡tandardnÃ© objektovo-orientovanÃ© jazyky aÅ¾ k rozÅ¡Ã­reniam objektovo-orientovanÃ½ch jazykov je len vybranÃ¡ skupina moÅ¾nostÃ­ ako znovupouÅ¾iÅ¥ zdrojovÃ½ kÃ³d, resp. ako znovupouÅ¾iÅ¥ zdrojovÃ½ kÃ³d nÃ¡vrhovÃ©ho vzoru. StÃ¡le zostÃ¡va viacero otvorenÃ½ch otÃ¡zok a alternatÃ­vnych moÅ¾nostÃ­, ktorÃ© mÃ´Å¾u vÃ½znamnÃ½m spÃ´sobom uÄ¾ahÄiÅ¥ pouÅ¾itie a znovupouÅ¾itie nÃ¡vrhovÃ½ch vzorov."
184,68,0.574,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 3,"naplnenie poÅ¾iadaviek na atribÃºty kvality â vyber atribÃºt a pridaj mechanizmus na jeho splnenie. PraktickÃ© rieÅ¡enia vÅ¡ak nie sÃº priamoÄiare, pretoÅ¾e atribÃºty kvality nie sÃº od seba nezÃ¡vislÃ© â mÃ´Å¾u sa navzÃ¡jom ovplyvÅovaÅ¥ rozliÄnÃ½mi skrytÃ½mi spÃ´sobmi. NÃ¡vrh, ktorÃ½ spÄºÅa poÅ¾iadavky na jeden atribÃºt kvality mÃ´Å¾e maÅ¥ negatÃ­vny dopad na inÃ½ atribÃºt kvality. Napr. vysoko zabezpeÄenÃ½ systÃ©m mÃ´Å¾e byÅ¥ veÄ¾mi Å¥aÅ¾kÃ© aÅ¾ nemoÅ¾nÃ© integrovaÅ¥ do otvorenÃ©ho prostredia. Vysoko dostupnÃ¡ aplikÃ¡cia mÃ´Å¾e vymeniÅ¥ niÅ¾Å¡iu vÃ½konnosÅ¥ za vyÅ¡Å¡iu dostupnosÅ¥. Pochopenie vplyvov a kompromisov medzi jednotlivÃ½mi poÅ¾iadavkami na atribÃºty kvality a nÃ¡vrh rieÅ¡enia, ktorÃ© predstavuje zmysluplnÃ½ kompromis je jednou z najÅ¥aÅ¾Å¡Ã­ch Ãºloh softvÃ©rovÃ©ho architekta. Nie je jednoducho moÅ¾nÃ© nÃ¡jsÅ¥ rieÅ¡enie, ktorÃ© v plnej miere spÄºÅa Ãºplne vÅ¡etky protichodnÃ© poÅ¾iadavky a je prÃ¡ve Ãºlohou architekta identifikovaÅ¥ problÃ©movÃ© miesta a scenÃ¡re, definovaÅ¥ priority a dokumentovaÅ¥ jednotlivÃ© rozhodnutia pri nÃ¡vrhu. Pochopenie a identifikÃ¡cia poÅ¾iadaviek na kvalitu predstavuje vÅ¡ak len nutnÃ½ predpoklad na nÃ¡vrh vhodnÃ©ho rieÅ¡enia. PozÃ­cia architekta je veÄ¾mi komplikovanÃ¡ aj preto, Å¾e architekt predstavuje styÄnÃ½ bod viacerÃ½ch zÃºÄastnenÃ½ch strÃ¡n a musÃ­ nielen podrobne rozumieÅ¥ atribÃºtom kvality a pouÅ¾itÃ½m technolÃ³giÃ¡m ale aj komunikovaÅ¥ s ostatnÃ½mi ÃºÄastnÃ­kmi. Architekt musÃ­ u zÃ¡kaznÃ­ka podrobne identifikovaÅ¥ poÅ¾iadavky na kvalitu, pretoÅ¾e tieto Äasto nie sÃº dostatoÄne zachytenÃ© v Å¡pecifikÃ¡cii poÅ¾iadaviek na systÃ©m. SÃºÄasne je Ãºlohou architekta diskutovaÅ¥ tolerancie v nÃ¡vrhu, identifikovaÅ¥ podmienky, za ktorÃ½ch moÅ¾no znÃ­Å¾iÅ¥ poÅ¾iadavky na kvalitu a jasne predostrieÅ¥ kompromisy jednotlivÃ½m zÃºÄastnenÃ½m stranÃ¡m tak, aby pochopili âdo Äoho idÃºâ."
184,27,0.571,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 3,"NÃ¡vrh architektÃºry sa nedÃ¡ efektÃ­vne validovaÅ¥ a testovaÅ¥ predtÃ½m, ako sa vyvinÃº aspoÅ zÃ¡kladnÃ© Äasti systÃ©mu. Prototypovanie tento problÃ©m rieÅ¡i iba ÄiastoÄne a nemusÃ­ dÃ¡vaÅ¥ ÃºplnÃº istotu o vhodnosti nÃ¡vrhu. Z tohto dÃ´vodu sa architekti spoliehajÃº na odskÃºÅ¡anÃ© prÃ­stupy k rieÅ¡eniu skupÃ­n problÃ©mov â architektonickÃ© vzory. ArchitektonickÃ½ vzor vÅ¡ak predstavuje abstraktnÃ© rieÅ¡enie, ktorÃ© vznikne generalizovanÃ­m niekoÄ¾kÃ½ch konkrÃ©tnych prÃ­stupov k rieÅ¡eniu problÃ©mu. Toto abstraktnÃ© rieÅ¡enie nie je spustiteÄ¾nÃ© na poÄÃ­taÄi a je Ãºlohou softvÃ©rovÃ½ch inÅ¾inierov vytvoriÅ¥ zo vzoru jeho konkrÃ©tnu pouÅ¾iteÄ¾nÃº implementÃ¡ciu. NajÄastejÅ¡ie pouÅ¾Ã­vanÃ© vzory sÃº podporovanÃ© verejne dostupnÃ½mi aplikÃ¡ciami, ktorÃ© poskytujÃº poÅ¾adovanÃº funkcionalitu a sÃº pritom znovupouÅ¾iteÄ¾nÃ© a aplikaÄne nezÃ¡vislÃ©. VÃ½vojovÃ½ tÃ­m teda nemusÃ­ nanovo vyvÃ­jaÅ¥ vÅ¡etky komponenty systÃ©mu, ale mÃ´Å¾e niektorÃ© Äasti pokryÅ¥ existujÃºcimi komerÄnÃ½mi alebo voÄ¾ne dostupnÃ½mi rieÅ¡eniami. Ãlohou softvÃ©rovÃ©ho architekta je vybraÅ¥ najvhodnejÅ¡Ã­ produkt na trhu, priÄom musÃ­ uvaÅ¾ovaÅ¥ rÃ´zne aspekty ako je cena, kvalita a funkcionalita. Takmer Å¾iadna aplikÃ¡cia neposkytuje presne to, Äo si Å¾iada nÃ¡Å¡ nÃ¡vrh. NÃ¡kupom aplikÃ¡cie buÄ zaplatÃ­me aj za funkcionalitu, ktorÃº nepoÅ¾adujeme (ktorÃº nikdy nepouÅ¾ijeme aj keÄ sme si za Åu zaplatili) alebo nÃ¡m naopak funkcionalita bude chÃ½baÅ¥ (priÄom rieÅ¡enÃ­m je doplnenie chÃ½bajÃºcich ÄastÃ­ alebo zmena nÃ¡vrhu). SoftvÃ©rovÃ½ architekt musÃ­ zvÃ¡Å¾iÅ¥ vÅ¡etky vÃ½hody a nevÃ½hody jednotlivÃ½ch produktov a vykonaÅ¥ sprÃ¡vnu voÄ¾bu."
369,82,0.562,AplikaÄnÃ© architektÃºry softvÃ©rovÃ½ch systÃ©mov,"HistÃ³ria a vÃ½znam vzorov Vzor opisuje rieÅ¡enie vÅ¡eobecnÃ©ho problÃ©mu, ktorÃ½ sa vyskytuje v urÄitÃ½ch situÃ¡ciÃ¡ch, tzv. kontextoch. Buschmann a kol. ho v [Buschmann 1996] definujÃº takto: Vzor Å¡pecifikuje opakujÃºci sa nÃ¡vrhovÃ½ problÃ©m, ktorÃ½ vziÅ¡iel zo Å¡pecifickÃ½ch nÃ¡vrhovÃ½ch kontextov a poskytuje pre ne overenÃº generickÃº schÃ©mu rieÅ¡enia PodÄ¾a objaviteÄ¾a vzorov, Christophera Alexandra [Alexander 1979]: KaÅ¾dÃ½ vzor je pravidlo pozostÃ¡vajÃºce z troch ÄastÃ­, ktorÃ© vyjadruje relÃ¡ciu medzi urÄitÃ½m kontextom, problÃ©mom a rieÅ¡enÃ­m. UvedenÃ© tri Äasti moÅ¾no nÃ¡jsÅ¥ aj v Buschmannovej definÃ­cii vzoru:"
59,223,0.533,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"kde ï¸ je tzv. koeficient strmosti, ktorÃ½ Å¡pecifikuje âostrosÅ¥â fitnes funkcie. Proces uÄenia je Å¡pecifikovanÃ½ dvoma parametrami: (1) kardinalitou q okolia U(x) a (2) parameter strmosti ï¸. Pre asymptotickÃ© hodnoty F(x) platÃ­ ï¬1 ï¨ if x ï½ xopt ï© a lim F ï¨ x ï© ï½ f max (4.10) lim F ï¨ x ï© ï½ ï­ ObyÄajnÃ© fitnes f(x) mÃ¡ tento jednoduchÃ½ priebeh ï¬1 ï¨ pre x ï½ xopt ï© (4.11) f ï¨ xï© ï½ ï­ ï®0 ï¨ pre x ï¹ xopt ï© Potom platÃ­ pre kaÅ¾dÃ½ chromozÃ³m x podmienka (pozri obr. 4.4) f ï¨ xï© ï³ F ï¨ xï© (4.12) PodÄ¾a Hintona a Nowlana [8] Å¡tudovanÃ½ problÃ©m mÃ´Å¾e byÅ¥ charakterizovanÃ½ ako hÄ¾adanie ihly v kope sena (ang. needle in a haystack) dÃ´sledku skutoÄnosti, Å¾e existuje len jedno korektnÃ© rieÅ¡enie v priestore 2n rieÅ¡enÃ­. Fitnes je obvykle vÃ½znamnou heuristikou, ktorÃ¡ nÃ¡m uÄ¾ahÄuje toto hÄ¾adanie optimÃ¡lneho rieÅ¡enia. ObyÄajnÃ© fitnes f(x) nie je nÃ¡m vÅ¡ak nÃ¡pomocnÃ© v tomto prehÄ¾adÃ¡vanÃ­, z jeho definÃ­cie (4.11) vyplÃ½va, Å¾e je jednotkovÃ© v prÃ­pade, Å¾e x = xopt, v opaÄnom prÃ­pade je nulovÃ© (pozri Obr. 4.4). To znamenÃ¡, Å¾e k tomu, aby sme"
240,2,0.519,PROGRAMOVANIE V JAZYKU C V RIEÅ ENÃCH PRÃKLADOCH 1,"vysvetlenie a ukÃ¡Å¾ky programov, za ktorÃ½mi nasledujÃº Ãºlohy pre samostatnÃº prÃ¡cu. RieÅ¡enia Ãºloh uvÃ¡dzame na konci kaÅ¾dej kapitoly a verÃ­me, Å¾e prÃ¡ve tieto rieÅ¡enia budÃº pre ÄitateÄ¾a vÃ½znamnÃ½m prostriedkom pre hlbÅ¡ie porozumenie jednotlivÃ½ch aspektov programovania v jazyku C. V poslednej kapitole (Projekty) uvÃ¡dzame niekoÄ¾ko vÃ¤ÄÅ¡Ã­ch projektov spolu s podrobnÃ½m postupom rieÅ¡enia, ktorÃ© sÃº urÄenÃ© predovÅ¡etkÃ½m ako moÅ¾nosÅ¥ integrovaÅ¥ zÃ­skanÃ© znalosti z ostatnÃ½ch kapitol. TeÅ¡Ã­me sa, Å¾e ste sa rozhodli preniknÃºÅ¥ do zÃ¡kutÃ­ programovania v jazyku C prÃ¡ve s nami. Jazyk C je malÃ½ jazyk, obsahuje pomerne mÃ¡lo kÄ¾ÃºÄovÃ½ch slov a len zÃ¡kladnÃ© typy riadiacich Å¡truktÃºr. Napriek tomu si pri jeho pouÅ¾itÃ­ mÃ´Å¾e programÃ¡tor âÄ¾ahko streliÅ¥ do nohyâ, keÄ aj jeden zatÃºlanÃ½ (chybnÃ½) znak v zdrojovom kÃ³de, mÃ´Å¾e pri vykonanÃ­ programu spÃ´sobiÅ¥ neoÄakÃ¡vanÃ© sprÃ¡vanie, ktorÃ© v koneÄnom dÃ´sledku spÃ´sobÃ­ finanÄnÃ© alebo materiÃ¡lne Å¡kody. Je preto veÄ¾mi nÃ¡roÄnÃ© pÃ­saÅ¥ programy, ktorÃ© sÃº spoÄ¾ahlivÃ© a bezpeÄnÃ©, v zmysle, Å¾e vo vÅ¡etkÃ½ch predvÃ­dateÄ¾nÃ½ch aj nepredvÃ­dateÄ¾nÃ½ch situÃ¡ciÃ¡ch nespÃ´sobia aÅ¾ takÃ© vÃ¡Å¾ne Å¡kody. Programovanie v jazyku C je umenie, ktorÃ© vyÅ¾aduje roky prÃ¡ce a skÃºsenostÃ­. V Bratislave, 25. augusta 2018."
115,167,0.518,Algebra a diskrÃ©tna  matematika,"UvÃ¡dzame strom prehÄ¾adÃ¡vania, kedy v prÃ­pade eÅ¡te nepouÅ¾itÃ½ch farieb pokladÃ¡me vÅ¡etky farby za ekvivalentnÃ© a preto neuvÃ¡dzame permutÃ¡cie nÃ¡jdenÃ©ho rieÅ¡enia s vÃ½menou farieb medzi mnoÅ¾inami vrcholov rovnakej farby. V takom prÃ­pade existuje iba jedno rieÅ¡enie. Farby sÃº oznaÄenÃ© prirodzenÃ½mi ÄÃ­slami"
135,222,0.493,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 4,"3.3.5 alÅ¡ie prÃ­klady pouÅ¾itia Okrem doteraz spomenutÃ½ch prÃ­kladov, alÅ¡Ã­mi prÃ­kladmi pouÅ¾itia architektonickÃ©ho vzoru DÃ¡tovody a filtre je vykresovanie grafickÃ½ch scÃ©n (Kaisler, 2005), prÃ­padne kniÅ¾nica LASSPTools pre oblas numerickej analÃ½zy a grafiky (Buschmann, 1996). VÃ½znamnou oblasou pouÅ¾itia tohto vzoru je integrÃ¡cia podnikovÃ½ch aplikÃ¡ciÃ­, kde sÃº integranÃ© rieÅ¡enia asto zaloÅ¾enÃ© na tomto architektonickom vzore (Hohpe, 2004). PrÃ­kladom takÃ©hoto integranÃ©ho rieÅ¡enia mÃ´Å¾e by spracovanie prichÃ¡dzajÃºcich objednÃ¡vok, ktorÃ© majÃº by najskÃ´r deÅ¡ifrovanÃ© (predpokladÃ¡ sa, Å¾e prichÃ¡dzajÃº v Å¡ifrovanej podobe), potom mÃ¡ by vykonanÃ¡ ich autorizÃ¡cia (predpokladÃ¡ sa nutnos overenia, i je odosielate oprÃ¡vnenÃ½ posla objednÃ¡vku s danÃ½mi charakteristikami, ako je naprÃ­klad finannÃ¡ hodnota) a napokon odstrÃ¡nenie duplicÃ­t (predpokladÃ¡ sa, Å¾e z technickÃ½ch dÃ´vodov sa mÃ´Å¾e sta, Å¾e jedna objednÃ¡vka je poslanÃ¡ viackrÃ¡t). ArchitektÃºra tohto integranÃ©ho rieÅ¡enia je zobrazenÃ¡ na obrÃ¡zku 3-8."
184,238,0.491,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 3,"ObrÃ¡zok 3-12. VzdialenÃ½ prÃ­stup analytickÃ½ch nÃ¡strojov k ICDE. WebovÃ© sluÅ¾by sÃº poslednÃ½m vÃ½krikom mÃ³dy vo veÄ¾kÃ½ch a stredne veÄ¾kÃ½ch systÃ©moch kde sa predpokladÃ¡ interoperabilita medzi viacerÃ½mi architektÃºrami. TradiÄnÃ© rieÅ¡enia, ako naprÃ­klad J2EE aplikaÄnÃ© servery a posielanie sprÃ¡v je vynikajÃºce rieÅ¡enie pre vnÃºtropodnikovÃ© aplikÃ¡cie. Äasto vÅ¡ak padÃ¡ ak sa ho snaÅ¾Ã­me prepojiÅ¥ s inÃ½m rieÅ¡enÃ­m, ktorÃ© je prepojenÃ© s naÅ¡ou aplikÃ¡ciou cez Internet. Vo svojej podstate webovÃ© sluÅ¾by nie sÃº niÄÃ­m novÃ½m. Volanie vzdialenÃ©ho kÃ³du Java podporuje pomocou svojich komponentov. WebovÃ© sluÅ¾by vÅ¡ak prinÃ¡Å¡ajÃº moÅ¾nosÅ¥ komunikÃ¡cie rÃ´znych platforiem medzi sebou bez potreby poznania druhej strany. KaÅ¾dÃ¡ z platforiem, Äi uÅ¾ ide o Javu, .NET alebo inÃº implementaÄnÃº platformu, dokÃ¡Å¾e poskytnÃºÅ¥ vzdialenÃ© sluÅ¾by inÃ½m aplikÃ¡ciÃ¡m, avÅ¡ak len ak pracujÃº na rovnakej platforme. TaktieÅ¾ majÃº tieto rieÅ¡enia problÃ©m s komunikÃ¡ciou cez Internet. ÄalÅ¡Ã­m problÃ©mom je to, Å¾e aplikÃ¡cie ktorÃ© neboli nikdy navrhovanÃ© tak aby prekroÄili hranice spoloÄnosti sÃº zrazu nÃºtenÃ© komunikovaÅ¥ so systÃ©mami mimo organizÃ¡cie."
94,407,0.476,Sprievodca svetom vedeckÃ©ho publikovania,"transparentnosÅ¥: vznikla tzv. âOpen Discovery Initiative167â, ktorÃ¡ propaguje otvorenÃº vÃ½menu metadÃ¡t a dÃ¡tovÃ½ch formÃ¡tov. Vytvorenie otvorenÃ©ho centrÃ¡lneho indexu je veÄ¾mi nÃ¡roÄnÃ¡ otÃ¡zka, keÄÅ¾e vyÅ¾aduje sÃºhru vÅ¡etkÃ½ch troch ÃºÄastnÃ­kov âdiscovery procesuâ â kniÅ¾nice, poskytovateÄ¾ov obsahu a poskytovateÄ¾ov technickÃ©ho rieÅ¡enia,"
135,31,0.467,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 4,"â sÃºvisiace vzory â vzory, ktorÃ© moÅ¾no pouÅ¾i sÃºasne, priom sa uvedie danÃ½ kontext a obmedzenia. Opis nÃ¡vrhovÃ½ch vzorov mÃ¡ by nezÃ¡vislÃ½ od programovacieho jazyka alebo implementanÃ½ch detailov, pretoÅ¾e nÃ¡vrhovÃ½ vzor je vlastne Å¡ablÃ³nou, poda ktorej moÅ¾no rieÅ¡enie aplikova v rÃ´znych situÃ¡ciÃ¡ch. Ako nÃ¡js nÃ¡vrhovÃ½ vzor ZÃ¡kladnou podmienkou pre âobjavenieâ nÃ¡vrhovÃ©ho vzoru je, aby programÃ¡tor rieÅ¡il danÃ½ problÃ©m sÃ¡m a pritom si robil poznÃ¡mky o tom, ako jednotlivÃ© problÃ©my rieÅ¡il. S pribÃºdajÃºcimi skÃºsenosami zistÃ­me, Å¾e ide stÃ¡le o tie istÃ© typy problÃ©mov. VÅ¾dy, ke sa danÃ½ alebo podobnÃ½ problÃ©m vyskytne, poznaÃ­me si v om je odliÅ¡nÃ½, v om je rovnakÃ½ a ako sme ho v danom prÃ­pade vyrieÅ¡ili. EventuÃ¡lne vytvorÃ­me Å¡tandardnÃ½ spÃ´sob na rieÅ¡enie takÃ©hoto problÃ©mu, ktorÃ½ budeme trvalo pouÅ¾Ã­va. Tak vznikÃ¡ nÃ¡vrhovÃ½ vzor."
240,482,0.464,PROGRAMOVANIE V JAZYKU C V RIEÅ ENÃCH PRÃKLADOCH 1,programovania. VÃ½slednÃ© zdrojovÃ© kÃ³dy rieÅ¡enÃ­ sa skladajÃº z viacerÃ½ch funkciÃ­ a vhodne vyuÅ¾Ã­vajÃº viacerÃ© prvky programovacieho jazyka. NaÅ¡im cieÄ¾om je zrozumiteÄ¾ne a prÃ­stupne pre zaÄÃ­najÃºceho programÃ¡tora opÃ­saÅ¥ ako postupovaÅ¥ pri rieÅ¡enÃ­ zloÅ¾itejÅ¡Ã­ch Ãºloh.
130,387,0.463,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 1,"Adhokracia Adhokracia znamenÃ¡ rozdeÄ¾ovanie Ãºloh metÃ³dou ad-hoc. Å truktÃºra a rozdelenie Ãºloh sÃº vytvÃ¡ranÃ© znovu pre kaÅ¾dÃ½ problÃ©m, ktorÃ½ treba rieÅ¡iÅ¥. TypickÃ© pouÅ¾itie adhokracie je pri nedostatoÄne Å¡truktÃºrovanÃ½ch problÃ©moch alebo problÃ©moch, pri ktorÃ½ch nevieme dopredu urÄiÅ¥ spÃ´sob ich rieÅ¡enia. Äasto sa pri prideÄ¾ovanÃ­ Ãºloh vyuÅ¾Ã­va mechanizmus trhu (naprÃ­klad âcontract netâ (Smith, 1980)). Pri rieÅ¡enÃ­ konkrÃ©tneho problÃ©mu sa vytvorÃ­ ad-hoc Å¡truktÃºra rozdelenia Ãºloh. Po viacnÃ¡sobnom rieÅ¡enÃ­ podobnÃ©ho problÃ©mu podobnÃ½m spÃ´sobom je moÅ¾nÃ© Å¡truktÃºru spoluprÃ¡ce vytvorenÃº spÃ´sobom ad-hoc ustÃ¡liÅ¥, teda preniesÅ¥ do Å¡tandardov alebo rozdelenia zodpovednostÃ­."
240,483,0.453,PROGRAMOVANIE V JAZYKU C V RIEÅ ENÃCH PRÃKLADOCH 1,"A. Maximum Proces tvorby rieÅ¡enia zahÅÅa rÃ´zne nepredvÃ­danÃ© situÃ¡cie a rozhodnutia, ktorÃ© musÃ­ programÃ¡tor spraviÅ¥, aby dospel k nejakÃ©mu uspokojivÃ©mu rieÅ¡eniu. PokÃºsime sa na prÃ­klade pomerne jednoduchej Ãºlohy spolu preskÃºmaÅ¥ a objaviÅ¥ moÅ¾nosti, ktorÃ© sa otvÃ¡rajÃº, pri rieÅ¡enÃ­ aj takejto zdanlivo jednoduchej Ãºlohy. Zadanie: Na vstupe je postupnosÅ¥ reÃ¡lnych ÄÃ­sel, ktorÃ© chceme analyzovaÅ¥."
41,22,0.449,InformaÄnÃ© vzdelÃ¡vanie,"Å¡kodiÅ¥!). Podmienky pouÅ¾Ã­vania open-source zvyÄajne definuje âvÅ¡eobecnÃ¡ verejnÃ¡ licenciaâ (General Public Licence), ktorÃ¡ slÃºÅ¾i ako licenÄnÃ¡ zmluva na softvÃ©r (SLA â v tomto prÃ­pade Software Licence Agreement) pre mnoho programov s otvorenÃ½m kÃ³dom. VeÄ¾a Ä¾udÃ­ uprednostÅuje open-source pred uzavretÃ½mi programami. ProgramÃ¡tori spravidla nemÃ´Å¾u ÃºÄtovaÅ¥ peniaze za softvÃ©r s otvorenÃ½m zdrojovÃ½m kÃ³dom, ktorÃ½ vytvÃ¡rajÃº, alebo ku ktorÃ©mu prispievajÃº. Preto mnoho softvÃ©rovÃ½ch programÃ¡torov s open-source spoplatÅuje softvÃ©rovÃ© sluÅ¾iby a podporu skÃ´r ako za samotnÃ½ softvÃ©r. Ich softvÃ©r tak zostÃ¡va bezplatnÃ½ a zarÃ¡bajÃº peniaze tÃ½m, Å¾e pomÃ¡hajÃº inÃ½m s jeho inÅ¡talÃ¡ciou, pouÅ¾Ã­vanÃ­m a rieÅ¡enÃ­m problÃ©mov. VÃ½hody open-source teda mÃ´Å¾eme zhodnotiÅ¥ nasledovne: âª kÃ³d mÃ´Å¾e byÅ¥ znÃ¡my a upravenÃ½ tak, aby rieÅ¡il problÃ©my s nÃ­m spojenÃ©, alebo ho moÅ¾no prispÃ´sobiÅ¥ konkrÃ©tnym potrebÃ¡m, âª kÃ³d zostÃ¡va v stave neustÃ¡leho zlepÅ¡ovania vÄaka zÃ¡sahom vÃ½vojÃ¡rov, revÃ­ziÃ¡m a novÃ½m nÃ¡padom, âª Ãºpravy kÃ³du je moÅ¾nÃ© Ä¾ubovoÄ¾ne redistribuovaÅ¥, âª obmedzuje predÃ¡torskÃ© sprÃ¡vanie pri presadzovanÃ­ softvÃ©ru, monopolu a zdraÅ¾ovaniu, âª pouÅ¾itÃ­m sa mÃ´Å¾u dosiahnuÅ¥ vyÅ¡Å¡ie Å¡tandardy kvality, âª open-source kÃ³d umoÅ¾Åuje kontinuitu projektov, a to aj po zmene programÃ¡torov alebo pÃ´vodnÃ½ch rieÅ¡iteÄ¾ov, âª umoÅ¾Åuje spoloÄnostiam a vÃ½vojÃ¡rom zaviesÅ¥ urÄitÃ© obmedzenia pouÅ¾Ã­vania, a tak chrÃ¡niÅ¥ integritu kÃ³du. POZNÃMKA: PoslednÃ© dva body v zozname mÃ´Å¾u Ä¾ahko spÃ´sobiÅ¥ protichodnÃ© ÃºÄinky. SpoloÄnosÅ¥, alebo zdruÅ¾enie (aj na Slovensku mÃ¡me takÃ©...) na prvÃ½ pohÄ¾ad bojujÃº za pouÅ¾Ã­vanie open-source pri rieÅ¡enÃ­ informatickÃ½ch systÃ©mov. Ak sa uÅ¾ vÅ¡ak âubytujÃºâ v danom systÃ©me a niekto by ich chcel vytlaÄiÅ¥, staÄÃ­ aplikovaÅ¥ licenÄnÃ© obmedzenia, a eÅ¡te lepÅ¡ie vÅ¡etky zmeny vydÃ¡vaÅ¥ na nevyhnutnÃ© servisnÃ© Ãºkony, a to uÅ¾ predsa patrÃ­ pod kategÃ³riu rieÅ¡enia problÃ©mov."
59,475,0.441,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"SÃ©mantickÃ½ prÃ­stup k rieÅ¡eniu tohto problÃ©mu je zaloÅ¾enÃ½ na pravdivostnej tabuÄ¾ke 9.2, z ktorej okamÅ¾ite dostÃ¡vame, Å¾e teÃ³ria ï je nekonzistentnÃ¡, t. j. ï ï½ ï . Pre vÅ¡etky moÅ¾nÃ© pravdivostnÃ© hodnoty, nikdy nenastÃ¡va situÃ¡cia, aby kaÅ¾dÃ¡ formula z teÃ³rie bola sÃºÄasne pravdivÃ¡. VytvorenÃ© âpodteÃ³rieâ ïi majÃº tieto modely: ï1ï¢ ï½ ï»ï¨ 0, ï£ ï©ï½ , ïï¢2 ï½ ï»ï¨ 0, ï£ ï© ,ï¨ ï£ ,1ï©ï½ , ïï¢3 ï½ ï»ï¨ï±ï¬ 0 ï©ï½ , ïï¢4 ï½ ï»ï¨ ï£ï¬ï±ï©ï½ PristÃºpime k ârieÅ¡eniuâ rovnice inklÃºzie ïï¢i ï ï£i , dostaneme ï1ï¢ ïp , ïï¢2 p ï q , ïï¢3 ïq , ïï¢4 Pomocou prirodzenej dedukcie znÃ¡zornÃ­me prvÃ½ vÃ½sledok:"
59,717,0.432,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"5. MÃ´Å¾eme diskutovaÅ¥, Äi tÃ¡to schopnosÅ¥ a tendencia je pre âÄ¾udskÃ©ho agentaâ pozitÃ­vna alebo negatÃ­vna Ärta. SÃºÄasnÃ¡ kognitÃ­vna a evoluÄnÃ¡ psycholÃ³gia poskytuje jednoznaÄnÃº odpoveÄ, Å¾e tÃ¡to schopnosÅ¥ je âpoÅ¾ehnanieâ pre Ä¾udskÃ½ druh, umoÅ¾Åuje rÃ½chlu orientÃ¡ciu v zloÅ¾itom materiÃ¡lnom, aj sociÃ¡lnom svete. Bez tejto vlastnosti by jeho Å¡anca preÅ¾itia (fitnes) bola podstatne niÅ¾Å¡ia. 6. Pri zmenenej situÃ¡cii (zmena prÃ­rodnÃ©ho prostredia, sociÃ¡lnej Å¡truktÃºry a pod.) mÃ´Å¾e sa staÅ¥, Å¾e niektorÃ© pouÅ¾Ã­vanÃ© heuristiky sa stanÃº âkontraproduktÃ­vneâ, brzdou ÄalÅ¡ieho rozvoja multiagentovÃ©ho systÃ©mu. Potom sa buÄ danÃ¡ heuristika nahradÃ­ inou, v danej situÃ¡cii vhodnejÅ¡ou, alebo bude pre multiagentovÃ½ systÃ©m predstavovaÅ¥ podstatnÃº bariÃ©ru jeho zachovania a rozvoja. 7. Pre umelÃº inteligenciu (a aj kognitÃ­vnu vedu) je veÄ¾kou vÃ½zvou navrhovaÅ¥ mechanizmy vzniku tÃ½chto heuristÃ­k pouÅ¾itÃ­m prostriedkov poÄÃ­taÄovej inteligencie a sledovaÅ¥ ich kultÃºrny prenos a fixÃ¡ciu pomocou memetickÃ½ch prÃ­stupov v systÃ©me. RieÅ¡enie tohto problÃ©mu spoÄÃ­va hÄ¾adanÃ­ vhodnej stratÃ©gie pre rÃ½chle a efektÃ­vne rieÅ¡enie danÃ©ho problÃ©mu. Pri pouÅ¾itÃ­ evoluÄnÃ½ch algoritmov je potrebnÃ© preto navrhnÃºÅ¥ vhodnÃ© kÃ³dovanie stratÃ©gie, ktorÃ© je dostatoÄne flexibilnÃ© k tomu, aby emergovanÃ© rieÅ¡enia boli dostatoÄne zaujÃ­mavÃ©. 8. MÃ´Å¾eme si poloÅ¾iÅ¥ zÃ¡vereÄnÃº otÃ¡zku, ako je moÅ¾nÃ©, Å¾e u Ä¾udÃ­ s tak nedokonalÃ½m a ohraniÄenÃ½m kognitÃ­vnym orgÃ¡nom, ktorÃ½ pri rieÅ¡enÃ­ problÃ©mov pouÅ¾Ã­va skoro vÃ½luÄne jednoduchÃ© heuristickÃ© postupy, vznikla sofistikovanÃ¡ veda? Ide o veÄ¾mi zloÅ¾itÃ½ problÃ©m, ktorÃ©ho vysvetlenie nie je jednoduchÃ©. Vznik vedy (kognitÃ­vneho artefaktu) v populÃ¡cii agentov, Äo moÅ¾no chÃ¡paÅ¥ ako emergenciu novej kvality, je asi umoÅ¾nenÃ½ tÃ½m, Å¾e v systÃ©me existujÃº spoÄ¾ahlivÃ© memetickÃ© vertikÃ¡lne prenosy poznatkov (mÃ©mov), ktorÃ© zabezpeÄujÃº ich akumulÃ¡ciu v priebehu mnohÃ½ch Å¾ivotnÃ½ch cyklov agentov. Samozrejme, veda nie je lineÃ¡rne ukladanie poznatkov, ktorÃ© spolu nesÃºvisia, je reprezentovanÃ¡ sÃºborom navzÃ¡jom previazanÃ½ch konzistentnÃ½ch poznatkov. Preto musia existovaÅ¥ aj ÄalÅ¡ie âvyÅ¡Å¡ieâ kognitÃ­vne aktivity agentov nad touto sumou poznatkov, ktorÃ© spoÄÃ­vajÃº napr. v odstraÅovanÃ­ nekonzistentnÃ½ch alebo redundantnÃ½ch poznatkov, Äi v induktÃ­vnom zovÅ¡eobecÅovanÃ­ a pod. V dÃ´sledku ohraniÄenej racionality kognitÃ­vneho orgÃ¡nu agentov je tento dvojitÃ½ proces pomalÃ½ a mÃ¡ inkrementÃ¡lny charakter. ProblÃ©m ohraniÄenej racionality reprezentuje pre umelÃº inteligenciu a kognitÃ­vnu vedu zaujÃ­mavÃº a aktuÃ¡lnu novÃº problematiku, ktorÃ¡ doposiaÄ¾ v tÃ½chto oblastiach nebola Å¡tudovanÃ¡. Å tÃºdium vzniku heuristÃ­k pre rieÅ¡enie zloÅ¾itÃ½ch Ãºloh, problÃ©m ich klasifikÃ¡cie podÄ¾a ÃºspeÅ¡nosti, spÃ¡janie rÃ´znych heuristÃ­k do jednej novej heuristiky a pod. reprezentujÃº veÄ¾mi zaujÃ­mavÃ© problÃ©my leÅ¾iace na rozhranÃ­ informatiky a sociÃ¡lnych vied. MetÃ³dy poÄÃ­taÄovej inteligencie (neurÃ³novÃ© siete a evoluÄnÃ© algoritmy) a multiagentovÃ½ch systÃ©mov majÃº pri tÃ½chto Å¡tÃºdiÃ¡ch dÃ´leÅ¾itÃ© postavenie jednotiacej metodiky pre vÃ½skum a opis problematiky ohraniÄenej racionality."
190,137,0.43,O softvÃ©ri od A po Z ; Ãvahy nastupujÃºcich profesionÃ¡lov,"Pri rieÅ¡enÃ­ softvÃ©rovÃ½ch projektov sa na celÃ½ rieÅ¡iteÄ¾skÃ½ tÃ­m kladie nespoÄetnÃ© mnoÅ¾stvo poÅ¾iadaviek. Ich splnenie by malo vyÃºstiÅ¥ k ÃºspeÅ¡nÃ©mu vyrieÅ¡eniu projektu, t.j. k odovzdaniu softvÃ©rovÃ©ho produktu v poÅ¾adovanej kvalite, naÄas a so stanovenÃ½mi zdrojmi. Tu vznikÃ¡ problÃ©m ako vÅ¡etky tieto poÅ¾iadavky zosÃºladiÅ¥ do procesov tak, aby bolo moÅ¾nÃ© vÅ¡etky v Äo najkratÅ¡om Äase vyrieÅ¡iÅ¥. V prÃ­pade, Å¾e sa jednÃ¡ o rozsiahle projekty a na realizÃ¡cii sa podieÄ¾a viac Ä¾udÃ­, je priam nutnosÅ¥ou ich prÃ¡cu spÃ´so- Existuje veÄ¾a metÃ³d a podporbom plÃ¡novaÅ¥ a koordinovaÅ¥. DostÃ¡vame sa k pojmu plÃ¡novania, ktorÃ© si naÅ¡lo svoje pevnÃ© miesto nÃ½ch nÃ¡strojov pri rieÅ¡enÃ­ softvÃ©rovÃ½ch projektov. V sÃºÄasnosti uÅ¾ existuje veÄ¾kÃ© mnoÅ¾- uÄ¾ahÄujÃºcich stvo metÃ³d a podpornÃ½ch prostriedkov uÄ¾ahÄujÃºcich proces plÃ¡novania. plÃ¡novanie. No aj tak je niekedy problÃ©m zostaviÅ¥ hodnotnÃ½ plÃ¡n, ktorÃ½ by bol reÃ¡lne vyuÅ¾iteÄ¾nÃ½ pri rieÅ¡enÃ­ projektu a netvoril by iba formu dokumentÃ¡cie, ktorÃ¡ by skonÄila pod kopou papierov nejakÃ©ho manaÅ¾Ã©ra. Tu sa mÃ´Å¾eme pozastaviÅ¥ nad otÃ¡zkou, Äi je plÃ¡novanie pri rieÅ¡enÃ­ projektu dÃ´leÅ¾itÃ©. OdpovedaÅ¥ si musÃ­ kaÅ¾dÃ½ sÃ¡m, pretoÅ¾e existujÃº aj prÃ­stupy, ktorÃ© minimalizujÃº proces plÃ¡novania a snaÅ¾ia sa tak zefektÃ­vniÅ¥ celÃ½ proces vÃ½voja. Faktom vÅ¡ak zostÃ¡va, Å¾e plÃ¡nom riadenÃ½ vÃ½voj je v sÃºÄasnosti rozÅ¡Ã­renÃ½m spÃ´sobom rieÅ¡enia softvÃ©rovÃ½ch projektov a existuje veÄ¾kÃ© mnoÅ¾stvo prÃ­kladov jeho ÃºspeÅ¡nÃ©ho pouÅ¾itia. Ak sa rozhodneme, Å¾e chceme vyuÅ¾iÅ¥ plÃ¡nom riadenÃ½ prÃ­stup, treba, aby sme zvlÃ¡dli niektorÃ© techniky spojenÃ© s vytvÃ¡ranÃ­m plÃ¡nu. V neposlednom rade si musÃ­me uvedomiÅ¥, v Äom nÃ¡m mÃ´Å¾e dobre zostavenÃ½ plÃ¡n pomÃ´cÅ¥ a Äoho by sme sa mali pri zostavovanÃ­ plÃ¡nu vyvarovaÅ¥. OdpoveÄ sa pokÃºsim poskytnÃºÅ¥ v nasledujÃºcich Äastiach."
59,510,0.427,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"v ktorom hÄ¾adÃ¡me globÃ¡lne minimum funkcie f (x) definovanej nad binÃ¡rnymi reÅ¥azcami dÄºÅ¾ky n. PretoÅ¾e poÄet binÃ¡rnych vektorov dÄºÅ¾ky n je 2n, zloÅ¾itosÅ¥ rieÅ¡enia tohto problÃ©mu rastie exponenciÃ¡lne, t. j. Äas potrebnÃ½ na rieÅ¡enie tohto problÃ©mu rastie exponenciÃ¡lne s rastom dimenzie n, tvÃ½poÄtu 2n . To znamenÃ¡, Å¾e pre vÃ¤ÄÅ¡ie n (napr. n = 50 alebo n =100), tento problÃ©m nemÃ¡me Å¡ancu vyrieÅ¡iÅ¥ v rozumnom Äase. PrÃ¡ve v tomto prÃ­pade vystupujÃº nastupujÃº evoluÄnÃ© algoritmy, ktorÃ© na zÃ¡klade darwinovskej metafory evolÃºcie sÃº schopnÃ© nÃ¡jsÅ¥ rieÅ¡enia tohto problÃ©mu, ktorÃ© aj keÄ sa nemusia rovnaÅ¥ globÃ¡lne optimÃ¡lnemu ieÅ¡eniu xopt, ale je mu veÄ¾mi blÃ­zke a v mnohÃ½ch prÃ­padoch pouÅ¾iteÄ¾nÃ© ako globÃ¡lne rieÅ¡enie. Na zÃ¡ver tejto podkapitoly uvedieme jednoduchÃ½ ilustraÄnÃ½ prÃ­klad rozÅ¡Ã­renia genetickÃ©ho algoritmu o âkolektÃ­vnu pamÃ¤Å¥â [24], ktorÃ¡ je realizovanÃ¡ tzv. pravdepodobnostnÃ½m vektorom w ï½ ï¨ w1 ,w2 ,...,wn ï© ï 0,1 , ktorÃ©ho jednotlivÃ© komponenty 0ï£wiï£1 urÄujÃº pravdepodobnosÅ¥ toho, Äi pri mutÃ¡cii replikÃ¡tora x ï½ ï¨ x1 ,x2 ,...,xn ï© ïï»0,1ï½ bude v polohe xi binÃ¡rna hodnota 1 alebo 0. V pÃ´vodnom genetickom algoritme, proces mutÃ¡cie je Ãºplne nÃ¡hodnÃ½, t. j. v replikÃ¡tore v danej polohe pri mutÃ¡cii sa bitovÃ© preklopenie 0ï«1 generuje nÃ¡hodne (pozri Obr. 10.2, diagram B): (1) modifikovanÃ½ genetickÃ½ algoritmus ï¯1 ï¨ random ï£ wi ï© ï¯mutÃ¡cia ï¨ random ï£ Pmut ï© ï½ ï­ (10.2a) xi ï½ ï­ ï®0 ï¨ inÃ¡Ä ï© ï¨ inÃ¡Ä ï© ï® xi (2) pÃ´vodnÃ½ genetickÃ½ algoritmus ï¯1 ï­ xi ï¨ mutÃ¡cia, ak random ï£ Pmut ï© (10.2b) xi ï½ ï­ ï¨ inÃ¡Ä ï© ï® xi Kde random je nÃ¡hodnÃ© ÄÃ­slo s rovnomernou distribÃºciou pravdepodobnosti z intervalu 0,1 . Ãloha, ktorÃ¡ je rieÅ¡enÃ¡ evoluÄnÃ½m prÃ­stupom je hÄ¾adanie globÃ¡lneho minima funkcie f ï¨ x ï© ï½ eï­0.01x sin ï¨8x ï© cos ï¨10 x ï© na intervale ï­10 ï£ x ï£ 10 . TÃ¡to funkcia mÃ¡ na danom intervale 56 minÃ­m, z ktorÃ½ch len jedno je globÃ¡lne, f(xopt)=-0,966565, xopt=0,61288 (pozri diagram A, Obr. 10.4). Nech v danej epoche evolÃºcie populÃ¡cia obsahuje replikÃ¡tor xopt s doÄasne maximÃ¡lnym fitnesom, toto vybranÃ© rieÅ¡enie sa pouÅ¾ije na modifikÃ¡ciu pamÃ¤te algoritmu reprezentovanej pravdepodobnostnÃ½mi vektorom w (pozri diagram B, Obr. 10.2) w : ï½ ï¨1 ï­ ï¬ ï© w ï« ï¬ xopt (10.3)"
135,3,0.426,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 4,"Diel 1: SoftvÃ©rovÃ© paradigmy o sÃº to softvÃ©rovÃ© paradigmy? Jedna cesta, ktorÃ¡ by mohla vies k odpovedi, ide cez podrobnejÅ¡ie preskÃºmanie pojmu paradigma. Pojem paradigma nadobudol modernÃ½ (sÃºasnÃ½) obsah najmÃ¤ vaka prÃ¡ci T. Kuhna, v ktorej sa zaoberal paradigmou ako vÃ½sledkom vedeckej revolÃºcie, meniacej nÃ¡had vedeckej komunity prÃ­sluÅ¡nej oblasti na problÃ©my a metÃ³dy rieÅ¡enia prelomovÃ½m spÃ´sobom. UvÃ¡dzame tento vÃ½znam slova paradigma, pretoÅ¾e sa jednoducho v Å¾iadnom vedeckom pojednanÃ­, postavenom na pojme paradigmy, nedÃ¡ dos dobre obÃ­s. To vÅ¡ak neznamenÃ¡, Å¾e to je jedinÃ½ relevantnÃ½ pohad. JednotlivÃ© oblasti poznania asto pouÅ¾Ã­vajÃº pojem paradigma v zmysle, ktorÃ½ je do znanej miery odliÅ¡nÃ½, i ke moÅ¾no nie priamo protireivÃ½. VÃ¤Å¡inou sa pojem paradigma v Å¡peciÃ¡lnych oblastiach poznania pouÅ¾Ã­va v omnoho Å¡peciÃ¡lnejÅ¡om zmysle, neÅ¾ ako sa chÃ¡pe KuhnovskÃ¡ paradigma. Tu uÅ¾ paradigma nie je nutne vÃ½sledkom vedeckej revolÃºcie i prevratu. Paradigma tieÅ¾ nie je (jedinÃ½m) prevlÃ¡dajÃºcim nÃ¡hadom na metÃ³dy rieÅ¡enia problÃ©mov prÃ­sluÅ¡nej oblasti. Pokojne mÃ´Å¾eme hovori o paradigmÃ¡ch v mnoÅ¾nom Ã­sle, nakoko sa v komunite uznÃ¡va viacero dos Å¡pecifickÃ½ch schÃ©m rieÅ¡enia problÃ©mov."
184,91,0.425,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 3,"AplikaÄnÃ½ server z pohÄ¾adu softvÃ©rovÃ©ho architekta AplikaÄnÃ© servery sÃº komplexnÃ¡ technolÃ³gie a je preto zrejmÃ©, Å¾e softvÃ©rovÃ½ architekt musÃ­ veÄ¾mi dobre poznaÅ¥ konkrÃ©tne poÅ¾iadavky na systÃ©m, aby dokÃ¡zal zvoliÅ¥ vhodnÃ½ typ pouÅ¾itÃ©ho aplikaÄnÃ©ho servera. TechnolÃ³gie aplikaÄnÃ½ch serverov vÅ¡ak umoÅ¾ÅujÃº vyÅ¡Å¡iu voÄ¾nosÅ¥ pri vyuÅ¾Ã­vanÃ­ rÃ´znych architektonickÃ½ch vzorov. KomplexnosÅ¥ komunikÃ¡cie s komponentmi v aplikaÄnom serveri zasa mÃ´Å¾e byÅ¥ vzhÄ¾adom na vÃ½konnosÅ¥ znaÄne limitujÃºcim faktorom pouÅ¾itia takÃ©hoto rieÅ¡enia. 2.2.5"
135,29,0.423,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 4,"â nÃ¡zov â vystihuje zÃ¡kladnÃº charakteristiku vzoru, â problÃ©m â opisuje typickÃ½ problÃ©m, na ktorÃ½ sa vzor aplikuje, â rieÅ¡enie â Å¡pecifikuje ako rieÅ¡i problÃ©m vrÃ¡tane opisu elementov, vzahov medzi sebou navzÃ¡jom a zodpovednosti voi ostatnÃ½m elementom,"
135,30,0.419,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 4,"â aplikovatenos â predstavuje obmedzenia, kedy vzor zodpovedÃ¡ reÃ¡lnej situÃ¡cii, â prÃ­klady â prÃ­klady aktuÃ¡lneho pouÅ¾itia vzoru pri rieÅ¡enÃ­ reÃ¡lnych problÃ©mov, â ukÃ¡Å¾kovÃ½ kÃ³d â implementÃ¡cia vzoru v danom kontexte, â racionÃ¡lny vÃ½znam â formou strunÃ©ho vysvetlenia, preo bolo rieÅ¡enie aplikovanÃ© a pre danÃ½ problÃ©m uÅ¾itonÃ©,"
111,63,0.417,ZÃ¡kladnÃ© metÃ³dy na zlepÅ¡enie pouÅ¾itelânosti webov,"Obr. 4.1: PrÃ­klad stromu (Å¡truktÃºra navigaÄnÃ©ho menu) pre regionÃ¡lnu autobusovÃº spoloÄnosÅ¥ prezentovanÃ½ vo forme tabuÄ¾ky. OznaÄenia kategÃ³riÃ­ sÃº takÃ© oznaÄenia v strome (uzly, angl. nodes), ktorÃ© majÃº pod sebou ÄalÅ¡ie oznaÄenia (ÄalÅ¡ie uzly, potomkov). Ide o uzly, ktorÃ© tvoria kategÃ³riu, resp. podkategÃ³riu. ObsahovÃ© oznaÄenia sÃº takÃ© oznaÄenia v strome, ktorÃ© nemajÃº ÄalÅ¡Ã­ch potomkov (listy stromu) a v podstate reprezentujÃº cieÄ¾ovÃ© informÃ¡cie/obsah, ktorÃ© chcete, aby nÃ¡vÅ¡tevnÃ­ci/pouÅ¾Ã­vatelia vaÅ¡ej webovej strÃ¡nky mohli Ä¾ahko nÃ¡jsÅ¥. V ÃºlohÃ¡ch Å¾iadame respondentov, aby naÅ¡li umiestnenie nejakÃ©ho obsahu, informÃ¡cie, prÃ­p. funkcie v strome. PoÄas testovania hierarchickej Å¡truktÃºry je Ãºlohou respondenta kliknÃºÅ¥ na strom a nÃ¡jsÅ¥ sprÃ¡vne rieÅ¡enia pre zadanÃ© Ãºlohy. SpoÄiatku respondent vidÃ­ len vrchnÃº vrstvu stromu (1. ÃºroveÅ). ÄalÅ¡ia ÃºroveÅ stromu sa odhalÃ­, keÄ respondent klikne na oznaÄenie (pod)kategÃ³rie. Respondent mÃ´Å¾e stromom traverzovaÅ¥, priÄom jednotlivÃ© (pod)kategÃ³rie sa postupne otvÃ¡rajÃº a zatvÃ¡rajÃº. Ak respondent lokalizuje list (cieÄ¾ovÃ½ uzol), o ktorom je presvedÄenÃ½, Å¾e zodpovedÃ¡ rieÅ¡eniu, klikne (najÄastejÅ¡ie) na tlaÄidlo âTu by som hladal danÃº informÃ¡ciuâ. Respondent musÃ­ prejsÅ¥ k sprÃ¡vnej odpovedi kliknutÃ­m cez vÅ¡etky Ãºrovne stromu. Samozrejme, ak si myslÃ­, Å¾e si vybral nesprÃ¡vny smer, vÅ¾dy sa mÃ´Å¾e vrÃ¡tiÅ¥ spÃ¤Å¥. Pre regionÃ¡lnu autobusovÃº spoloÄnosÅ¥ by sme mohli Ãºlohu formulovaÅ¥ takto: âZajtra skoro rÃ¡no by ste si chceli kÃºpiÅ¥ lÃ­stok na autobus. Kde by ste hÄ¾adali Äas, kedy sa otvÃ¡ra predajÅa cestovnÃ½ch lÃ­stkov?â(pozri Obr. 4.2) Stromy sÃº definovanÃ© vÃ½luÄne textovÃ½mi oznaÄeniami usporiadanÃ½mi do stromovej Å¡truktÃºry, takÅ¾e sa Ä¾ahko vytvÃ¡rajÃº a sÃº ideÃ¡lne na testovanie informaÄnej Å¡truktÃºry bez potreby jej implemen-"
184,321,0.417,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 3,"kde prÃ­kaz vykonaj spÃºÅ¡Å¥a dva programy A a B po sebe, jeden po druhom. PokiaÄ¾ oba programy produkujÃº vÃ½stup, oÄakÃ¡va sa, Å¾e vÃ½stup produkovanÃ½ procesom B bude priamo nasledovaÅ¥ za vÃ½stupom z procesu A a to v sÃºbore vystup. SpÃ´sob akÃ½m sa tento stav dosahuje na jednoprocesorovÃ½ch systÃ©moch, je zaloÅ¾enÃ½ na tom, Å¾e v Äase, keÄ Å¡tartuje proces B zdedÃ­ po procese A ukazovateÄ¾ ktorÃ½ je medzi nimi a shellom zdieÄ¾anÃ½. Pri takomto postupe bude prvÃ¡ slabika vÃ½stupu programu B zapÃ­sanÃ¡ hneÄ po poslednej slabike zapÃ­sanej programom A. V prÃ­pade session sÃ©mantiky a bez zdieÄ¾anÃ½ch ukazovateÄ¾ov sÃºborov je nutnÃ© pouÅ¾iÅ¥ Ãºplne inÃ½ mechanizmus aby sa dosiahlo rovnakÃ© sprÃ¡vanie tohto jednoduchÃ©ho shellovskÃ©ho prÃ­kazu. Ãplne odliÅ¡nÃ½m prÃ­stupom ku sÃ©mantike zdieÄ¾ania sÃºborov v distribuovanÃ½ch systÃ©moch je pouÅ¾Ã­vanie takzvanÃ½ch immutable sÃºborov. Pri tomto prÃ­stupe je umoÅ¾nenÃ© vytvoriÅ¥ novÃ½ sÃºbor a vloÅ¾iÅ¥ ho do adresÃ¡ra pod rovnakÃ½m menom ako meno pÃ´vodnÃ©ho sÃºboru, priÄom sa predchÃ¡dzajÃºca verzia sÃºboru stÃ¡va (pod tÃ½mto menom) nedostupnou. Takto je sÃ­ce nemoÅ¾nÃ© modifikovaÅ¥ sÃºbor X, ostÃ¡va vÅ¡ak moÅ¾nosÅ¥ atomicky nahradiÅ¥ sÃºbor X novÃ½m sÃºborom. InÃ½mi slovami: aj keÄ sÃºbor nemÃ´Å¾e byÅ¥ modifikovanÃ½, adresÃ¡r modifikovanÃ½ byÅ¥ mÃ´Å¾e. RozhodnutÃ­m, Å¾e sÃºbory nemÃ´Å¾u byÅ¥ modifikovanÃ© sa eliminuje problÃ©m ako sa dohodnÃºÅ¥ s dvomi procesmi â jednÃ½m z nich, ktorÃ½ zapisuje do sÃºboru a inÃ½m, ktorÃ½ z neho ÄÃ­ta. ProblÃ©m, ktorÃ½ ostÃ¡va je rozhodnutie Äo sa stane v prÃ­pade, ak sa dva procesy snaÅ¾ia nahradiÅ¥ rovnakÃ½ sÃºbor v rovnakom Äase. Ako aj v prÃ­pade session sÃ©mantiky, aj tu sa zdÃ¡ najlepÅ¡Ã­m rieÅ¡enÃ­m nahradenie starÃ©ho sÃºboru najnovÅ¡Ã­m sÃºborom alebo nahradiÅ¥ sÃºbor âdruhÃ½mâ sÃºborom nedeterministicky. Trocha zloÅ¾itejÅ¡Ã­m problÃ©mom je, Äo robiÅ¥ v prÃ­pade, ak je sÃºbor nahradenÃ½ inÃ½m sÃºborom v Äase, keÄ z neho prÃ¡ve ÄÃ­ta nejakÃ½ proces. JednÃ½m z moÅ¾nÃ½ch rieÅ¡enÃ­ je nejakÃ½m spÃ´sobom zabezpeÄiÅ¥ pre ÄÃ­tajÃºceho pokraÄovanie ÄÃ­tania starej verzie sÃºboru, napriek tomu, Å¾e sa uÅ¾ nenachÃ¡dza v Å¾iadnom adresÃ¡ri. Podobne to rieÅ¡i systÃ©m UNIX v ktorom proces, ktorÃ½ otvoril sÃºbor mÃ´Å¾e bez problÃ©mov pokraÄovaÅ¥ v prÃ¡ci s nÃ­m napriek tomu, Å¾e mohol byÅ¥ medziÄasom vymazanÃ½. InÃ½m rieÅ¡enÃ­m je detekcia stavu zmeny sÃºboru a zabrÃ¡nenie jeho ÄalÅ¡ieho ÄÃ­tania tÃ½m, Å¾e operÃ¡cia Read vrÃ¡ti chybu."
76,139,0.417,PRAVDEPODOBNOSÅ¤ A MATEMATICKÃ Å TATISTIKA,"2.3.2 Uistite sa, Å¾e ku vÅ¡etkÃ½m rozdeleniam z ÄlÃ¡nku 2.2 viete nÃ¡jsÅ¥ prÃ­sluÅ¡nÃ© distribuÄnÃ© funkcie. V kaÅ¾dej situÃ¡cii overte, Å¾e zÃ­skanÃ¡ funkcia mÃ¡ vlastnosti uvedenÃ© vo vete 2.3.3. 2.3.3 Uistite sa, Å¾e ku vÅ¡etkÃ½m rozdeleniam z ÄlÃ¡nku 2.2 viete nÃ¡jsÅ¥ kvantily, t. j. viete urÄiÅ¥ tak, aby platilo: ( ) = . V ktorÃ½ch ÃºlohÃ¡ch, teda pre ktorÃ© rozdelenia, je problÃ©m rieÅ¡iÅ¥ rovnicu ( ) = ? V ÃºlohÃ¡ch 2.2.6 a 2.2.7 ide o kubickÃ© rovnice (algebraickÃ© rovnice tretieho stupÅa), ktorÃ© vieme rieÅ¡iÅ¥ len numerickÃ½mi metÃ³dami. 2.3.4 Funkcia"
59,410,0.415,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"Na zÃ¡ver mÃ´Å¾eme konÅ¡tatovaÅ¥, Å¾e sÃ©mantickÃ© tablÃ¡ poskytujÃº jednoduchÃ½ a efektÃ­vny prostriedok pre kontrolu vzÅ¥ahu âtautologickÃ©ho vyplÃ½vaniaâ, ï ï¹ , priÄom nemusÃ­me poznaÅ¥ relatÃ­vne zloÅ¾itÃº syntaktickÃº teÃ³riu dÃ´kazu âlogickÃ©ho vyplÃ½vaniaâ. TaktieÅ¾, sÃ©mantickÃ© tablo je vhodnÃ¡ technika na rieÅ¡enie relÃ¡cie tautologickÃ©ho vyplÃ½vania ï»ïª1 ,...,ïªnï½ pomocou âpartikulÃ¡rnychâ rieÅ¡enÃ­ pre jednotlivÃ© otvorenÃ© vetvy dostaneme rieÅ¡enie, ktorÃ© je sÃ©manticky dÃ´sledok teÃ³rie ï ï½ ï»ïª1 ,...,ïªn ï½ ."
240,485,0.414,PROGRAMOVANIE V JAZYKU C V RIEÅ ENÃCH PRÃKLADOCH 1,"RieÅ¡enie: Pri nÃ¡vrhu rieÅ¡enia (akejkoÄ¾vek Ãºlohy) je dÃ´leÅ¾itÃ© si uvedomiÅ¥, Å¾e naÅ¡ou Ãºlohou je vytvoriÅ¥ program, ktorÃ½ sprÃ¡vne vyrieÅ¡i nielen Ãºlohu pre ukÃ¡Å¾kovÃ© Ãºdaje zo zadania, ale pre akÃ©koÄ¾vek vstupnÃ© Ãºdaje spÄºÅajÃºce Å¡pecifikÃ¡ciu Ãºlohy. SÃºÄasÅ¥ou tejto Å¡pecifikÃ¡cie je najmÃ¤ formÃ¡t vstupu a vÃ½stupu. FormÃ¡t vstupu jednoznaÄne opisuje, ako porozumieÅ¥ Ãºdajom na vstupe, aby sme ich mohli naÄÃ­taÅ¥ a spracovaÅ¥. SkutoÄnÃ¡ Ãºloha je teda vytvoriÅ¥ program, ktorÃ½ oÄakÃ¡va (a spracuje) Ãºdaje dodrÅ¾iavajÃºce tento formÃ¡t. Ak Ãºdaje na vstupe nespÄºÅajÃº Å¡pecifikÃ¡ciu Ãºlohy a formÃ¡t vstupu, ako je uvedenÃ© v zadanÃ­ Ãºlohy, tak nie je chybou programu, ak na takÃ½chto vstupnÃ½ch Ãºdajoch vypÃ­Å¡e nesprÃ¡vny vÃ½sledok. VrÃ¡Å¥me sa spÃ¤Å¥ k naÅ¡ej Ãºlohe. Text tejto Ãºlohy opisuje zadanie pre nÃ¡Å¡ program ako zistenie maxima spomedzi prvkov zadanej postupnosti. FormÃ¡t vstupu nie je bliÅ¾Å¡ie opÃ­sanÃ½, keÄÅ¾e text jednoznaÄne (formÃ¡lne) neuvÃ¡dza, akÃ½m spÃ´sobom sÃº jednotlivÃ© ÄÃ­sla zadanÃ©: mÃ´Å¾u byÅ¥ v desiatkovej sÃºstave alebo v binÃ¡rnej sÃºstave alebo akokoÄ¾vek inak zadanÃ©, napr. aj slovne. PresnÃ¡ Å¡pecifikÃ¡cia Äasto obsahuje podrobnÃ© opisy, ktorÃ© zaÄÃ­najÃºceho programÃ¡tora mÃ´Å¾u odradiÅ¥. V praxi vÅ¡ak Äasto ani nie sÃº potrebnÃ©, pretoÅ¾e skÃºsenÃ­ programÃ¡tori uÅ¾ vedia, Äo mÃ´Å¾u oÄakÃ¡vaÅ¥. Ako alternatÃ­vu presnej Å¡pecifikÃ¡cie formÃ¡tu vstupu a vÃ½stupu vÅ¾dy uvÃ¡dzame v ÃºlohÃ¡ch ukÃ¡Å¾ku vstupu/vÃ½stupu, ktorÃ¡ pre skÃºsenÃ©ho programÃ¡tora Ãºplne a jednoznaÄne vysvetÄ¾uje podstatu vstupnÃ©ho aj vÃ½stupnÃ©ho formÃ¡tu. OtÃ¡zka: Äo keÄ sÃº na vstupe dÃ¡ta, ktorÃ© nie sÃº v poÅ¾adovanom formÃ¡te?"
43,8,0.41,Objektovo orientovanÃ© programovanie v C++,"Tieto skriptÃ¡ boli napÃ­sanÃ© s prvotnÃ½m zÃ¡merom poskytnÃºÅ¥ Å¡tudijnÃ½ materiÃ¡l Å¡tudentom druhÃ©ho roÄnÃ­ka odboru Matematicko-poÄÃ­taÄovÃ© modelovanie na Stavebnej fakulte Slovenskej technickej univerzity v Bratislave. Obsah skrÃ­pt sa vo veÄ¾kej miere zhoduje s obsahom predmetu Objektovo orientovanÃ© programovanie tohto Å¡tudijnÃ©ho zamerania. UÄebnica vÅ¡ak mÃ´Å¾e rovnako dobre poslÃºÅ¾iÅ¥ aj komukoÄ¾vek inÃ©mu, kto si chce osvojiÅ¥ princÃ­py objektovo orientovanÃ©ho programovania a zoznÃ¡miÅ¥ sa s jazykom C++. CieÄ¾om tejto knihy je ponÃºknuÅ¥ zrozumiteÄ¾nÃ½ a intuitÃ­vny pohÄ¾ad na objektovo orientovanÃ© programovanie a jeho zÃ¡kladnÃ© stavebnÃ© kamene. Popri tom kniha obsahuje kapitoly, ktorÃ© sa netÃ½kajÃº priamo tejto tÃ©my, ale skÃ´r samotnÃ©ho jazyka C++. ÄitateÄ¾ by mal teda po jej preÄÃ­tanÃ­ nadobudnÃºÅ¥ schopnosÅ¥ vidieÅ¥ objektovÃº Å¡truktÃºru v praktickÃ½ch problÃ©moch, navrhnÃºÅ¥ objektovo orientovanÃ½ program a potom ho implementovaÅ¥ v C++. UÄebnica sa snaÅ¾Ã­ osloviÅ¥ skÃ´r novÃ¡Äika v tejto oblasti, ako profesionÃ¡lneho programÃ¡tora. Aby bola kaÅ¾dÃ¡ problematika Äo najlepÅ¡ie objasnenÃ¡, kniha obsahuje veÄ¾kÃ© mnoÅ¾stvo prÃ­kladov z rÃ´znych oblastÃ­. Ide o jednoduchÃ© Ãºlohy, ktorÃ© sÃº rozdelenÃ© do niekoÄ¾kÃ½ch kategÃ³riÃ­ (zÃ¡kladnÃ© princÃ­py, matematickÃ© Ãºlohy, hry a inÃ© aplikÃ¡cie), aby mal ÄitateÄ¾ moÅ¾nosÅ¥ predstaviÅ¥ si, ako sa dajÃº objektovo reprezentovaÅ¥ rÃ´znorodÃ© typy problÃ©mov. Treba vÅ¡ak zdÃ´razniÅ¥, Å¾e ide skÃ´r o ilustrÃ¡cie princÃ­pov, pretoÅ¾e objektovo orientovanÃ© programovanie zaÄne byÅ¥ skutoÄne uÅ¾itoÄnÃ© aÅ¾ pri rozsiahlych programÃ¡torskÃ½ch projektoch. Kniha uÅ¾ predpokladÃ¡, Å¾e ÄitateÄ¾ poznÃ¡ zÃ¡kladnÃ© princÃ­py programovania. Pri ÄÃ­tanÃ­ prvej kapitoly, ktorÃ¡ vysvetÄ¾uje kÄ¾ÃºÄovÃ© myÅ¡lienky objektovo orientovanÃ©ho programovania, nie je potrebnÃ¡ znalosÅ¥ Å¾iadneho Å¡peciÃ¡lneho programovacieho jazyka. Äalej je vÅ¡ak uÅ¾ uÅ¾itoÄnÃ© maÅ¥ zÃ¡kladnÃ© znalosti jazyka C alebo aspoÅ inÃ©ho prÃ­buznÃ©ho programovacieho jazyka. UÄebnica sa sÃ­ce podrobne venuje niektorÃ½m dÃ´leÅ¾itÃ½m programÃ¡torskÃ½m otÃ¡zkam, ako sÃº naprÃ­klad alokÃ¡cia pamÃ¤te alebo usporiadanie dÃ¡t do rÃ´znych dÃ¡tovÃ½ch Å¡truktÃºr, no nijako sa nevracia k princÃ­pom algoritmizÃ¡cie problÃ©mov a k zÃ¡kladnÃ½m prvkom programovacÃ­ch jazykov, ako sÃº cykly, podmienky, deklarÃ¡cie premennÃ½ch, tvorba funkciÃ­ a podobne. KeÄÅ¾e uÄebnica je primÃ¡rne urÄenÃ¡ pre Å¡tudentov odboru Matematicko-poÄÃ­taÄovÃ© modelovanie, niektorÃ© prÃ­klady a cviÄenia prepokladajÃº istÃ© matematickÃ© vedomosti (nejde vÅ¡ak o pokroÄilÃ© problematiky), alebo rieÅ¡ia jednoduchÃ© problÃ©my z oblastÃ­ sÃºvisiacich s aplikovanou matematikou, ako je naprÃ­klad spracovanie obrazu. Okrem toho je vÅ¡ak v knihe mnoÅ¾stvo ÄalÅ¡Ã­ch prÃ­kladov, ktorÃ© sÃº urÄenÃ© aj pre inak zameranÃ©ho ÄitateÄ¾a. VÅ¡etky uvedenÃ© prÃ­klady sÃº funkÄnÃ© programy alebo ich Äasti, teda boli skompilovanÃ© aj otestovanÃ©. PoÄakovanie. Äakujem recenzentom Ing. TomÃ¡Å¡ovi Oberhuberovi, PhD. a RNDr. Martinovi SamuelÄÃ­kovi, PhD., za cennÃ© pripomienky a rady. TieÅ¾ Äakujem Mgr. Jane Karasovej za pripomienky a pohÄ¾ad laika so zÃ¡ujmom o zÃ¡klady OOP."
59,131,0.409,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"ZÃ¡ver vyplÃ½vajÃºci z Obr. 3.8 mÃ´Å¾eme zovÅ¡eobecniÅ¥ tak, Å¾e evoluÄnÃ½ vznik zloÅ¾itÃ½ch Å¾ivoÄÃ­Å¡nych orgÃ¡nov neprebiehal priamoÄiaro za vzniku hotovÃ©ho orgÃ¡nu poÅ¾adovanej zloÅ¾itosti, ale postupne vyuÅ¾Ã­val3 starÅ¡ie Å¡truktÃºry organizmu, ktorÃ© boli prispÃ´sobenÃ© na novÃ© potreby. TÃ½mto spÃ´sobom je zabezpeÄenÃ½ neustÃ¡ly selekÄnÃ½ tlak vedÃºci v koneÄnom dÃ´sledku na vznik komplexnÃ©ho orgÃ¡nu prostrednÃ­ctvom medzistupÅov, ktorÃ½ch vÃ½znam mÃ´Å¾e byÅ¥ veÄ¾mi vzdialenÃ½ vÃ½znamu koneÄnÃ©ho orgÃ¡nu (pozri obrÃ¡zok 3.8). NiekoÄ¾ko poznÃ¡mok k problÃ©mom reprodukcie a dediÄnosti, ktorÃ½ch vÃ½znamnou ÄasÅ¥ou je tzv. embryogenÃ©za, Äo je spÃ´sob vzniku a vÃ½voja novÃ½ch jedincov zo zÃ¡rodkov. Budeme rozliÅ¡ovaÅ¥ dva druhy embryogenÃ©zy: 1. EpigenetickÃ¡ embryogenÃ©za, kde novÃ½ organizmus vznikÃ¡ delenÃ­m jednej âzÃ¡rodoÄnejâ bunky, tento druh embryogenÃ©zy sa vyskytuje na naÅ¡ej planÃ©te pri reprodukcii biologickÃ½ch systÃ©mov. MÃ´Å¾e byÅ¥ zjednoduÅ¡ene chÃ¡panÃ¡ ako recept na prÃ­pravu kolÃ¡Äa, kde je uvedenÃ© nielen to, Äo kolÃ¡Ä obsahuje, ale aj jeho prÃ­prava. 2. PreformaÄnÃ¡ embryogenÃ©za, kde novÃ½ organizmus je reprezentovanÃ½ zÃ¡rodkom, ktorÃ½ obsahuje vÅ¡etky detaily dospelÃ©ho organizmu. Tento typ embryogenÃ©zy mÃ´Å¾eme formÃ¡lne prirovnaÅ¥ k plÃ¡nu budovy alebo stroja, kde sÃº podrobne uvedenÃ© vÅ¡etky detaily. Existencia tohto druhu embryogenÃ©zy je pre nÃ¡s"
265,461,0.405,SoftvÃ©rovÃ© inÅ¾inierstvo v otÃ¡zkach a odpovediach,"hodnovernosÅ¥ prototypu (miera rozpracovania, Ãºplnosti prototypu â low, medium, high fidelity prototype), hodnovernosÅ¥ nÃ¡vrhu (miera aktuÃ¡lneho naplnenia pouÅ¾Ã­vateÄ¾skÃ½ch poÅ¾iadaviek v navrhnutom rieÅ¡enÃ­; najÄastejÅ¡ie v sÃºvislosti s nÃ¡vrhom pouÅ¾Ã­vateÄ¾skÃ©ho rozhrania),"
59,703,0.4,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"VÃ½skumy Gigerenzera a jeho spolupracovnÃ­kov moÅ¾no zosumarizovaÅ¥ [9,10] prostrednÃ­ctvom hypotÃ©zy, Å¾e Ä¾udskÃ½ mozog bol formovanÃ½ v priebehu evolÃºcie tak, Å¾e nie je veÄ¾mi efektÃ­vne vÃ½poÄtovÃ© zariadenie, ale je schopnÃ½ efektÃ­vne rieÅ¡iÅ¥ neustÃ¡le sa vyskytujÃºce adaptÃ­vne a rÃ½chlo sa meniace dynamickÃ© problÃ©my, od rieÅ¡enia ktorÃ½ch Äasto zÃ¡visÃ­ existencia danÃ©ho jedinca, priÄom vyuÅ¾Ã­va na rieÅ¡enie tÃ½chto problÃ©mov jednoduchÃ© a rÃ½chle heuristiky, ktorÃ© sÃº nenÃ¡roÄnÃ© na Äas, poznatky a vÃ½poÄty. MoÅ¾nosti sÃºÄasnej umelej inteligencie a kognitÃ­vnej vedy modelovaÅ¥ ohraniÄenÃº racionalitu IntegrÃ¡lna sÃºÄasÅ¥ modernej umelej inteligencie je poÄÃ­taÄovÃ¡ inteligencia (Äasto nazÃ½vanÃ¡ aj ako softcomputing), ktorÃ¡ obsahuje znÃ¡mu triÃ¡du modernÃ½ch subsymbolickÃ½ch prÃ­stupov: neurÃ³novÃ© siete [14], evoluÄnÃ© algoritmy [15] a fuzzy logiku [28]. Je potrebnÃ© poznamenaÅ¥, Å¾e tieto tri subsymbolickÃ© oblasti umelej inteligencie sÃº zaloÅ¾enÃ© na princÃ­poch, ktorÃ© sÃº veÄ¾mi blÃ­zke k teÃ³rii ohraniÄenej racionality. NeurÃ³novÃ© siete sÃº vhodnÃ½ prostriedok na konÅ¡trukciu kognitÃ­vneho orgÃ¡nu agentov, ktorÃ½ je schopnÃ½ uÄenia v priebehu vykonÃ¡vania svojich aktivÃ­t v danom prostredÃ­ a ktorÃ½ uÅ¾ svojou konÅ¡trukciou mÃ¡ ohraniÄenÃ© kognitÃ­vne moÅ¾nosti a preto je vhodnÃ½ prostriedok pre Å¡tÃºdium ohraniÄenej racionality. Podobne, evoluÄnÃ© algoritmy mÃ´Å¾u slÃºÅ¾iÅ¥ na konÅ¡trukciu stratÃ©giÃ­ v multiagentovÃ½ch systÃ©moch. KlasickÃ½ prÃ­klad tohto prÃ­stupu sÃº Axelrodove Å¡tÃºdie [2,3] kooperÃ¡cie zaloÅ¾enÃ© na vÃ¤zenskej dileme, ktorÃ© vyÃºstili v zistenÃ­ neoÄakÃ¡vanej tit-for-tat stratÃ©gie. Fuzzy logika je schopnÃ¡ spracovaÅ¥ neÃºplnÃº informÃ¡ciu (napr. verbÃ¡lne formulovanÃº). Pomocou jej metÃ³d sme schopnÃ­ zostrojiÅ¥ rÃ´zne typy riadiacich prvkov (kontrolÃ©rov) len pomocou vÃ¡gne formulovanÃ½ch pravidiel (napr. âzabrzdi, ak sa pribliÅ¾ujeÅ¡ k autu, ktorÃ© je pred tebouâ). Tieto âkontrolÃ©ryâ mÃ´Å¾eme chÃ¡paÅ¥ ako jednoduchÃ© heuristiky na riadenie zloÅ¾itÃ½ch dynamickÃ½ch systÃ©mov, ktorÃ½ch teÃ³riu v mnohÃ½ch prÃ­padoch nepoznÃ¡me (napr. riadenie zloÅ¾itÃ©ho zariadenia, kde vzÅ¥ah medzi vstupnÃ½mi a vÃ½stupnÃ½mi parametrami poznÃ¡me len ako âÄiernu skrinkuâ). PoÄÃ­taÄovÃ¡ inteligencia je v sÃºÄasnosti veÄ¾mi populÃ¡rna v kruhoch âautomatizÃ©rovâ, kde poskytuje skoro univerzÃ¡lny prostriedok na riadenie zloÅ¾itÃ½ch systÃ©mov, priÄom redukuje nutnosÅ¥ vyuÅ¾Ã­vaÅ¥ klasickÃ© matematickÃ© prÃ­stupy teÃ³rie riadenia na minimum."
59,203,0.398,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"3.9 ZÃ¡ver Metafora univerzÃ¡lneho darwinizmu rozÅ¡iruje princÃ­py darwinizmu ako univerzÃ¡lneho prÃ­stupu k Å¡tÃºdiu evolÃºcie nielen v biolÃ³gii, ale aj v inÃ½ch vednÃ½ch oblastiach (chÃ©mia, sociÃ¡lne vedy, informatika, umelÃ¡ inteligencia, kognitÃ­vna veda,...). V informatike univerzÃ¡lny darwinizmus poskytuje jedineÄnÃº moÅ¾nosÅ¥ simulÃ¡ciÃ­ darwinovskej evolÃºcie prostriedkami âin silicoâ (t. j. poÄÃ­taÄom), mÃ´Å¾eme konÅ¡tatovaÅ¥ tieto vÅ¡eobecnÃ© zÃ¡very: ï· EvoluÄnÃ© algoritmy tvoria robustnÃ½ optimalizaÄnÃ½ prostriedok pre rÃ´zne kombinatoriÃ¡lne Ãºlohy (napr. z teÃ³rie grafov, operaÄnÃ©ho vÃ½skumu, inÅ¾inierskej praxe nÃ¡vrhu zloÅ¾itÃ½ch zaradenÃ­, a pod.). ï· EvoluÄnÃ© multiagentovÃ© systÃ©my umoÅ¾ÅujÃº poÄÃ­taÄovÃ© simulÃ¡cie sociÃ¡lnych systÃ©mov, emergenciu kooperÃ¡cie a komunikÃ¡cie vypracovaÅ¥ evoluÄnÃ© zÃ¡klady memetiky ako Å¡peciÃ¡lneho prÃ­padu multiagentovÃ½ch systÃ©mov, Å¡tudovaÅ¥ etnickÃ© konflikty v multiagentovÃ½ch systÃ©moch, a pod. ï· UniverzÃ¡lny darwinizmus umoÅ¾Åuje informatike aktÃ­vne interagovaÅ¥ so sociÃ¡lnymi a behaviorÃ¡lnymi vedami. Z ilustraÄnÃ½ch vÃ½poÄtov molekulovej Darwinovej evolÃºcie vyplÃ½vajÃº tieto dÃ´leÅ¾itÃ© vÅ¡eobecnÃ© zÃ¡very pre univerzÃ¡lny darwinizmus: 1. Eigenova teÃ³ria replikÃ¡torov tvorÃ­ dobrÃ½ fenomenologickÃ½ zÃ¡klad molekulovej darwinovej evolÃºcie. Priebehy koncentraÄnÃ½ch profilov zÃ­skanÃ½ch rieÅ¡enÃ­m diferenciÃ¡lnych rovnÃ­c popisujÃºcich dynamiku chemostatu replikÃ¡torov, ktorÃ© boli zÃ­skanÃ© vhodnÃ½m vÃ½berom rÃ½chlostnÃ½ch konÅ¡tÃ¡nt, poskytujÃº priebehy koncentrÃ¡ciÃ­, ktorÃ© sÃº veÄ¾mi podobnÃ© experimentÃ¡lne pozorovanÃ½m [47] (pozri Obr. 3.14). 2. DarwinovskÃ¡ evolÃºcia prebieha ako MonodovskÃ¡ [42] vzÃ¡jomnÃ¡ hra medzi nÃ¡hodou a nutnosÅ¥ou, medzi deterministickÃ½m a stochastickÃ½m charakterom, ktorÃ© sÃº jej integrÃ¡lna sÃºÄasÅ¥. EvolÃºcia obsahuje Äasti, ktorÃ© sÃº plne deterministickÃ© â plne predpovedateÄ¾nÃ© (napr. zobrazenie genotypu na fenotyp), a taktieÅ¾ aj stochastickÃ© Äasti, ktorÃ© nemÃ´Å¾u byÅ¥ dobre predpovedateÄ¾nÃ©, mÃ´Å¾e hovoriÅ¥ len o ich Å¡tatistickÃ½ch charakteristikÃ¡ch (napr. mutÃ¡cie). V tejto sÃºvislosti sa obÄas pouÅ¾Ã­va terminolÃ³gia zavedenÃ¡ americkÃ½m informatikom a zakladateÄ¾om umelÃ©ho Å¾ivota Christopherom Langtonom âna hrane chaosuâ (angl. on the edge of chaos). PouÅ¾Ã­va sa termÃ­n âevolÃºcia prebieha na hrane chaosuâ, ktorÃ½ sa interpretuje takto: HlavnÃ¡ hnacia sila inovÃ¡ciÃ­ v evolÃºcii sÃº mutÃ¡cie, preto by sme sa mohli domnievaÅ¥, Å¾e ÄÃ­m ÄastejÅ¡Ã­ je vÃ½skyt mutÃ¡ciÃ­ pri reprodukÄnom procese, tÃ½m vÃ¤ÄÅ¡ia je pravdepodobnosÅ¥ vÃ½skytu inovÃ¡cie. AvÅ¡ak, ak miera mutÃ¡ciÃ­ prekroÄÃ­ urÄitÃº kritickÃº hodnotu, efektÃ­vnosÅ¥ evolÃºcie sa zniÄÃ­ a stÃ¡va sa z nej nieÄo Äo mÃ´Å¾eme nazvaÅ¥ âslepÃ© hÄ¾adanieâ, bez vplyvu stratÃ©gie prirodzenÃ©ho vÃ½beru, ktorÃ½ je schopnÃ½ efektÃ­vne selektovaÅ¥ pozitÃ­vne mutÃ¡cie. V opaÄnom prÃ­pade, ak miera vÃ½skytu mutÃ¡ciÃ­ je veÄ¾mi malÃ¡, evolÃºcia sa v podstate zastavÃ­ a zamrzne v aktuÃ¡lnom stave. Preto mÃ´Å¾eme povedaÅ¥, Å¾e frekvencia vÃ½skytu mutÃ¡ciÃ­ musÃ­ byÅ¥ dostatoÄne veÄ¾kÃ¡, ale zase nie veÄ¾mi, aby sa evolÃºcia nerozpadla, hovorÃ­me, Å¾e musÃ­ byÅ¥ na hrane chaosu. 3. Koncepcia Sewalla Wrighta [51] povrchu funkcie fitnes mÃ´Å¾e byÅ¥ povaÅ¾ovanÃ¡ ako jeden z najvÃ¤ÄÅ¡Ã­ch Ãºspechov Darwinovej evoluÄnej teÃ³rie a taktieÅ¾ aj ako jeden zo zdrojov jej univerzÃ¡lneho charakteru. TÃ¡to koncepcia mÃ¡ veÄ¾kÃ½ heuristickÃ½ vÃ½znam v tom, Å¾e Darwinova evolÃºcia mÃ´Å¾e byÅ¥ interpretovanÃ¡ ako Å¡peciÃ¡lny druh evoluÄnÃ©ho algoritmu [15,25,37], ktorÃ½ je schopnÃ½ rieÅ¡iÅ¥ extrÃ©mne komplikovanÃ© kombinatoriÃ¡lne optimalizaÄnÃ© problÃ©my. V prvej sekcii bol formulovanÃ½ Wrightov nÃ¡zor na evolÃºciu ako na optimalizaÄnÃ½ proces na povrchu funkcie fitnes (pozri Obr. 3.2). V tejto sÃºvislosti Wright poznamenal, Å¾e jeden z hlavnÃ½ch cieÄ¾ov teÃ³rie evolÃºcie je popÃ­saÅ¥ mechanizmy, ktorÃ© umoÅ¾ÅujÃº evolÃºcii nÃ¡jsÅ¥ âspojitÃ© cestyâ z jednÃ©ho vrcholu do druhÃ©ho vrcholu na povrchu fitnes funkcie nato, aby evolÃºcia bola"
59,688,0.393,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"1. JednoduchÃ© rieÅ¡enie, kde pouÅ¾Ã­vame len pravidlÃ¡ 0 alebo 1. t. j. kaÅ¾dom kroku hry sa nÃ¡m podarÃ­ urobiÅ¥ takÃ© zjednoduÅ¡enie hry, Å¾e sa zaplnÃ­ prÃ¡zdna pozÃ­cia ÄÃ­slom. 2. Stredne zloÅ¾itÃ© rieÅ¡enie, kde sa okrem pravidiel 1 a 0 pouÅ¾Ã­vajÃº taktieÅ¾ pravidlÃ¡ 2 a 3. Pre tento stupeÅ zloÅ¾itosti hry taktieÅ¾ dochÃ¡dza monotÃ³nnemu zjednoduÅ¡ovaniu hry, ovÅ¡em uÅ¾ urÄitÃ¡ ÄasÅ¥ krokov rieÅ¡enie (okolo 10 ï­ 15%) spoÄÃ­va v tom, Å¾e pre vybranÃ© bunky aj keÄ nedochÃ¡dza k ich zaplneniu fixovanÃ½m ÄÃ­slom, ale dochÃ¡dza k celkovÃ©mu znÃ­Å¾ovaniu poÄtu alternatÃ­vnych pozÃ­ciÃ­ v aktuÃ¡lnom rieÅ¡enÃ­."
135,95,0.39,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 4,"1.5.5 Zhodnotenie vzorov HCI Vzory pri nÃ¡vrhu rozhranÃ­ lovek-poÃ­ta zachytÃ¡vajÃº overenÃ© prÃ­stupy k rieÅ¡eniu opakujÃºcich sa problÃ©mov. Neuviedli sme vÅ¡etky doteraz existujÃºce vzory, nakoko to nie je"
59,130,0.386,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"ObrÃ¡zok 3.8. ZnÃ¡zornenie evoluÄnej tvorby komplexnÃ©ho orgÃ¡nu (napr. oka stavovcov), proces je inicializovanÃ½ evoluÄnÃ½m vznikom jednoduchÃ©ho âprotoorgÃ¡nuâ Aini , cez prechodnÃ© rieÅ¡enia Ai, aÅ¾ po koneÄnÃ© rieÅ¡enie Afin. ZloÅ¾itosÅ¥ orgÃ¡nu postupne rastie, dva evoluÄne susednÃ© orgÃ¡ny sÃº si podobnÃ©, evoluÄnÃ½ prechod Ai ï® Ai ï«1 je dobre interpretovateÄ¾nÃ½ pomocou mutÃ¡cie genotypu organizmu. KaÅ¾dÃ½ orgÃ¡n mÃ¡ Å¡pecifikovanÃº Ãºlohu, ktorÃ¡ urÄuje aj selekÄnÃ½ tlak na jeho vznik, tieto Ãºlohy sa mÃ´Å¾u v priebehu evolÃºcie podstatne meniÅ¥. Preto mÃ´Å¾eme evoluÄnÃº Ãºlohu vzniku komplexnÃ©ho orgÃ¡nu formulovaÅ¥ ako zloÅ¾itÃº optimalizaÄnÃº Ãºlohu pohyblivÃ©ho cieÄ¾a. PoÄiatoÄnÃ½ a koneÄnÃ½ stav je spojenÃ½ Äiarou, ktorÃ¡ reprezentuje moÅ¾nosÅ¥ priameho âevoluÄnÃ©ho skokuâ z Aini na Afin. TÃ¡to evoluÄnÃ¡ zmena by vyÅ¾adovala zÃ¡sadnÃº prestavbu genotypu, ktorÃ¡ je jednou mutÃ¡ciou nerealizovateÄ¾nÃ¡, preto pravdepodobnosÅ¥ takÃ©ho evoluÄnÃ©ho skoku je skoro nulovÃ¡."
76,37,0.386,PRAVDEPODOBNOSÅ¤ A MATEMATICKÃ Å TATISTIKA,"1.2.12 (Rozmiestnenie k rozlÃ­Å¡iteÄ¾nÃ½ch obÃ¡lok do n prieÄinkov bez zÃ¡kazu) Skratkou âbez zÃ¡kazuâ budeme oznaÄovaÅ¥ prÃ­pad, keÄ prieÄinok mÃ´Å¾e obsahovaÅ¥ viac obÃ¡lok, hoci aj vÅ¡etky. KoÄ¾ko je v takomto prÃ­pade rÃ´znych rozmiestnenÃ­? Najprv si ujasnime, kedy ide o dve rÃ´zne rozmiestnenia. Prirodzene vtedy, ak existuje aspoÅ jeden prieÄinok, ktorÃ©ho obsah je inÃ½ v prvom a inÃ½ pri druhom rozmiestnenÃ­. To vÅ¡ak znamenÃ¡, Å¾e existuje obÃ¡lka (obÃ¡lka napr. s ÄÃ­slom ), ktorÃ¡ pri prvom rozmiestnenÃ­ putovala do prieÄinku a v druhom rozmiestnenÃ­ do prieÄinku (samozrejme, â  ). PrvÃ¡ obÃ¡lka mÃ´Å¾e byÅ¥ umiestnenÃ¡ do Ä¾ubovoÄ¾nÃ©ho prieÄinku â to je moÅ¾nostÃ­. DruhÃ¡ obÃ¡lka opÃ¤Å¥ do Ä¾ubovoÄ¾nÃ©ho prieÄinku (ide teraz o prÃ­pad bez zÃ¡kazu), takÅ¾e poÄet umiestnenÃ­ dvoch rozlÃ­Å¡iteÄ¾nÃ½ch obÃ¡lok sa rovnÃ¡ . PokraÄujÃºc v Ãºvahe, dostÃ¡vame nakoniec, Å¾e poÄet rozmiestnenÃ­ bez zÃ¡kazu rozlÃ­Å¡iteÄ¾nÃ½ch obÃ¡lok do prieÄinkov sa rovnÃ¡ . Ako by sme realizovali nÃ¡hodnÃ© rozmiestnenie tohoto typu? To sme opÃ­sali v odstavci 1.2.11 â rozmiestÅovanie mÃ´Å¾e byÅ¥ realizovanÃ© prostrednÃ­ctvom nÃ¡hodnÃ©ho vÃ½beru lÃ­stka zo Å¡katule. Len treba upresniÅ¥, Å¾e teraz by iÅ¡lo o usporiadanÃ½ vÃ½ber s vrÃ¡tenÃ­m. Je dobrÃ© maÅ¥ na mysli jedno â jednoznaÄnÃº koreÅ¡podenciu (t. j. bijekciu) medzi usporiadanÃ½mi vÃ½bermi s vrÃ¡tenÃ­m a rozmiestneniami rozlÃ­Å¡iteÄ¾nÃ½ch obÃ¡lok bez zÃ¡kazu. TÃ¡ koreÅ¡podencia (bijekcia) je definovanÃ¡ postupom, mechanizmom rozmiestÅovania, opÃ­sanom v 1.2.11. 1.2.13 (Rozmiestnenie k rozlÃ­Å¡iteÄ¾nÃ½ch obÃ¡lok do n prieÄinkov so zÃ¡kazom) Teraz prieÄinok nesmie obsahovaÅ¥ viac ako jednu obÃ¡lku (teda jednu, alebo Å¾iadnu). MusÃ­ platiÅ¥ , lebo inak sa rozmiestnenie nedÃ¡ realizovaÅ¥. KoÄ¾ko je teraz moÅ¾nÃ½ch rozmiestnenÃ­? PrvÃ¡ obÃ¡lka mÃ´Å¾e putovaÅ¥ do Ä¾ubovoÄ¾nÃ©ho prieÄinku, druhÃ¡ uÅ¾ len do Ä¾ubovoÄ¾nÃ©ho z â 1 prieÄinkov, tretia uÅ¾ len do Ä¾ubovoÄ¾nÃ©ho z â 2 prieÄinkov atÄ. Zrejme poÄet vÅ¡etkÃ½ch rozmiestnenÃ­ sa rovnÃ¡ V( ). RealizovaÅ¥ nÃ¡hodnÃ© rozmiestnenie tohoto typu mÃ´Å¾eme pomocou mechanizmu z 1.2.11, ale teraz by iÅ¡lo o vÃ½bery bez vrÃ¡tenia (aby iÅ¡lo o rozmiestÅovanie so zÃ¡kazom). 1.2.14 PrÃ­klad. (NarodeninovÃ½ paradox) Predstavme si, Å¾e v triede je 30 Å¾iakov a nie sÃº v nej dvojiÄky. AkÃ¡ je pravdepodobnosÅ¥ toho, Å¾e sÃº medzi Å¾iakmi takÃ­ dvaja, ktorÃ­ majÃº narodeniny v ten istÃ½ deÅ? RieÅ¡enie. Predstavme si 365 prieÄinkov (Äo prieÄinok, to jeden deÅ v roku). Pani NÃ¡hoda pred rokmi nÃ¡hodne rozmiestnila 30 rozlÃ­Å¡iteÄ¾nÃ½ch loptiÄiek do tÃ½ch 365 prieÄinkov. OtÃ¡zka je, akÃ¡ je pravdepodobnosÅ¥ toho, Å¾e existuje prieÄinok, ktorÃ½ obsahuje viac ako jednu loptiÄku. JednoduchÅ¡ie je vÅ¡ak najprv nÃ¡jsÅ¥ pravdepodobnosÅ¥ toho, Å¾e takÃ½ prieÄinok neexistuje. UvÃ¡Å¾me, Å¾e mnoÅ¾ina vÅ¡etkÃ½ch moÅ¾nÃ½ch rozmiestnenÃ­ loptiÄiek do prieÄinkov mÃ¡ prvkov. To preto, lebo prvÃ¡ loptiÄka mohla skonÄiÅ¥ v Ä¾ubovoÄ¾nom prieÄinku, druhÃ¡ tieÅ¾ v hociktorom z 365 prieÄinkov atÄ. a to je 365ï365ï365ï ... ï365 = . KoÄ¾ko z tÃ½chto rozmiestnenÃ­ je takÃ½ch, Å¾e Å¾iaden prieÄinok neobsahuje dve a viac loptiÄiek? TakÃ½ch je 365ï364ï363ï ... ï(365 â 29) = 365ï364ï363ï ... ï336 = V(365, 30) To preto, Å¾e kÃ½m prvÃ¡ loptiÄka mohla skonÄiÅ¥ v Ä¾ubovoÄ¾nom prieÄinku, druhÃ¡ mala len 364 moÅ¾nostÃ­, tretia len 363 atÄ. Preto pravdepodobnosÅ¥ toho, Å¾e Å¾iaden prieÄinok neobsahuje viac ako jednu loptiÄku sa rovnÃ¡"
130,342,0.385,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 1,"7 MULTIAGENTOVÃ SYSTÃMY Trend postupnÃ©ho distribuovania vÃ½poÄtov neobiÅ¡iel ani umelÃº inteligenciu. MyÅ¡lienka jednÃ©ho superinteligentnÃ©ho centrÃ¡lneho systÃ©mu, ktorÃ½ samostatne rieÅ¡i Ãºlohy, zÃ­skala konkurenta uÅ¾ viac neÅ¾ pred tretinou storoÄia. PribliÅ¾ne v tejto dobe sa zaÄali objavovaÅ¥ systÃ©my zaloÅ¾enÃ© na spoluprÃ¡ci viacerÃ½ch expertov na rieÅ¡enÃ­ spoloÄnej Ãºlohy. Dodnes pribudlo mnoho ÄalÅ¡Ã­ch spÃ´sobov ako v umelej inteligencii vyuÅ¾iÅ¥ princÃ­p distribuovanÃ½ch vÃ½poÄtov a vykonÃ¡vania, a to pre dosiahnutie kvantitatÃ­vnych, ale aj kvalitatÃ­vnych zlepÅ¡enÃ­. DistribuovanÃ© vÃ½poÄty a vykonÃ¡vanie v multiagentovÃ½ch systÃ©moch vÅ¡ak so sebou prinÃ¡Å¡ajÃº aj rad problÃ©mov. Je potrebnÃ© urÄiÅ¥, ako problÃ©m rozdeliÅ¥ na jednoduchÅ¡ie Äasti. Je potrebnÃ© zabezpeÄiÅ¥ prenesenie jednotlivÃ½ch podproblÃ©mov na miesto ich rieÅ¡enia a nakoniec zozbieraÅ¥ a spojiÅ¥ ÄiastkovÃ© vÃ½sledky. Je tieÅ¾ potrebnÃ© koordinovaÅ¥ ÄinnosÅ¥ jednotlivÃ½ch agentov tam kde sÃº ich Äinnosti od seba vzÃ¡jomne zÃ¡vislÃ© a synchronizovaÅ¥ prÃ­stup k spoloÄnÃ½m zdrojom. Napriek tomu, Å¾e multiagentovÃ© systÃ©my ako vednÃ¡ disciplÃ­na sÃº starÅ¡ie ako Å¡tvrÅ¥ storoÄia, definÃ­cie jednotlivÃ½ch konceptov v rÃ´znych zdrojoch nie sÃº jednotnÃ© a Äasto ani jednoznaÄnÃ©. Vymedzenie jednotlivÃ½ch konceptov uvedenÃ½ch v tejto kapitole vychÃ¡dza predovÅ¡etkÃ½m z monografiÃ­ (Ferber, 1999; NÃ¡vrat, 2002; MaÅÃ­k, 1993; MaÅÃ­k, 2003a; MaÅÃ­k, 2003b), ale aj z ÄalÅ¡Ã­ch zdrojov a v neposlednej miere z diskusiÃ­ s kolegami ktorÃ½m by som chcel touto cestou poÄakovaÅ¥."
76,123,0.384,PRAVDEPODOBNOSÅ¤ A MATEMATICKÃ Å TATISTIKA,"2.2 SpojitÃ© nÃ¡hodnÃ© veliÄiny a ich rozdelenia Doteraz sme hovorili o nÃ¡hodnÃ½ch veliÄinÃ¡ch, ktorÃ½ch mnoÅ¾ina moÅ¾nÃ½ch hodnÃ´t bola koneÄnÃ¡, alebo ak nekoneÄnÃ¡, tak spoÄÃ­tateÄ¾nÃ¡. Ako vieme, takÃ© veliÄiny nazÃ½vame diskrÃ©tne. Na druhej strane sa Äasto stretÃ¡vame so situÃ¡ciami, keÄ nÃ¡hodnÃ½m je napr. Äas, ktorÃ½ trÃ¡vime ÄakanÃ­m na obsluhu (ÄakanÃ­m vo fronte, Äi uÅ¾ v supermarkete, v banke, alebo na poÅ¡te), resp. nÃ¡hodnÃ½m je Äas bezporuchovÃ©ho fungovania hociakÃ©ho vÃ½robku. V tÃ½chto prÃ­padoch ide o nÃ¡hodnÃ© veliÄiny, ktorÃ½ch potenciÃ¡lne hodnoty sÃº akÃ©koÄ¾vek body intervalu, Äi uÅ¾ ohraniÄenÃ©ho, alebo neohraniÄenÃ©ho (Äasto berieme interval â¨ ) len preto, Å¾e potom sa s modelom dobre pracuje). TakÃ©to nÃ¡hodnÃ© veliÄiny budeme nazÃ½vaÅ¥ spojitÃ© (presnÃ¡ definÃ­cia nasleduje). PripomeÅme znÃ¡my fakt â kaÅ¾dÃ½ interval kladnej dÄºÅ¾ky je nespoÄÃ­tateÄ¾nÃ¡ mnoÅ¾ina. NuÅ¾ a to je dÃ´vod, pre ktorÃ½ pravdepodobnostnÃ½ opis spojitej nÃ¡hodnej veliÄiny nie je moÅ¾nÃ© urobiÅ¥ pomocou pravdepodobnostÃ­ jednotlivÃ½ch vÃ½sledkov (tÃ½ch moÅ¾nÃ½ch vÃ½sledkov je totiÅ¾ nespoÄÃ­tateÄ¾ne veÄ¾a, voÄ¾ne povedanÃ©, prÃ­liÅ¡ veÄ¾a) a naviac â a to vyzerÃ¡ ako paradox â pre pravdepodobnosti jednotlivÃ½ch vÃ½sledkov platÃ­ P( = ) = 0, pre kaÅ¾dÃ© reÃ¡lne . 2.2.1 DefinÃ­cia. Nech (ï, S, P) je pravdepodobnostnÃ½ priestor a je zobrazenie z ï do R. Zobrazenie nazÃ½vame nÃ¡hodnÃ¡ veliÄina, ak pre vÅ¡etky ïR, < , mÃ¡ zmysel hovoriÅ¥ o P({ï·: ï£ (ï·) < }), to znamenÃ¡, Å¾e mnoÅ¾ina {ï·: ï£ (ï·) < } patrÃ­ do S."
111,36,0.381,ZÃ¡kladnÃ© metÃ³dy na zlepÅ¡enie pouÅ¾itelânosti webov,"Obr. 3.4: VÅ¡etky karty by mali byÅ¥ na rovnakej konceptuÃ¡lnej Ãºrovni, aby sa dali zaradiÅ¥ do rovnakÃ½ch mentÃ¡lnych modelov. Triedenie kariet je koncepÄnÃ¡ ÄinnosÅ¥, nie test pouÅ¾iteÄ¾nosti. CieÄ¾om triedenia kariet je skÃºmaÅ¥, ako Ä¾udia chÃ¡pu informÃ¡cie, nie testovaÅ¥ navigÃ¡ciu webovej strÃ¡nky. To je dÃ´vod, preÄo by vÅ¡etky karty mali byÅ¥ na rovnakej konceptuÃ¡lnej Ãºrovni, aby sa dali zaradiÅ¥ do rovnakÃ½ch mentÃ¡lnych modelov, podÄ¾a ktorÃ½ch ich respondenti triedia. Okrem toho, Å¾e vÅ¡etky karty musia byÅ¥ konzistentnÃ© a rovnakÃ©, aby sa vytvorili koncepÄnÃ© skupiny, je tieÅ¾ dÃ´leÅ¾itÃ©, aby bolo dostatok kariet podobnÃ½ch alebo navzÃ¡jom prÃ­buznÃ½ch. Pri kaÅ¾dej karte by ste si mali vedieÅ¥ predstaviÅ¥ aspoÅ jednu ÄalÅ¡iu kartu, ktorÃº by s Åou bolo moÅ¾nÃ© zaradiÅ¥ do kategÃ³rie. V opaÄnom prÃ­pade, ak budÃº vÅ¡etky karty veÄ¾mi odliÅ¡nÃ© a Ä¾udia (respondenti) medzi nimi nebudÃº vidieÅ¥ Å¾iadnu sÃºvislosÅ¥, nebudÃº schopnÃ­ vytvoriÅ¥ Å¾iadne ucelenÃ© kategÃ³rie a vy sa nedozviete niÄ uÅ¾itoÄnÃ© pre zoskupovanie poloÅ¾iek na vaÅ¡ej webovej strÃ¡nke. Takisto ak bude triedenie prÃ­liÅ¡ nÃ¡roÄnÃ©, bude vÃ¤ÄÅ¡ia pravdepodobnosÅ¥, Å¾e respondenti Å¡tÃºdiu opustia, resp. triedenie nedokonÄia. NajlepÅ¡Ã­ spÃ´sob, ako sa s tÃ½mto problÃ©mom vysporiadaÅ¥, je overiÅ¥ prÃ­tomnosÅ¥ kariet, pre ktorÃ© je Å¥aÅ¾kÃ© nÃ¡jsÅ¥ âprÃ­buznÃ½châ. Ak to chcete urobiÅ¥, zdieÄ¾ajte odkaz na nÃ¡hÄ¾ad Å¡tÃºdie triedenia kariet s kolegami z vÃ¡Å¡ho tÃ­mu a nechajte ich karty zatriediÅ¥. Ak sa niektorÃ© karty zdajÃº byÅ¥ nÃ¡roÄnÃ© na triedenie, ale napriek tomu ich povaÅ¾ujete za dÃ´leÅ¾itÃ© pre Å¡tÃºdiu, mÃ´Å¾ete ich vyvÃ¡Å¾iÅ¥ pridanÃ­m kariet,"
59,165,0.38,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"ObrÃ¡zok 3.16. Priebeh frekvenciÃ­ vÃ½skytu dominantnÃ½ch binÃ¡rnych reÅ¥azcov (16) dÄºÅ¾ky 4. Chemostat bol inicializovanÃ½ 1000 reÅ¥azcami (0010), po 2.5 ï´ 106 ÄasovÃ½ch krokoch dominantnÃ© koneÄnÃ© rieÅ¡enie je reÅ¥azec xfin = (1100), kde real(xopt) = 12/15 a f(12/15) = 0,9755. Toto koneÄnÃ© rieÅ¡enie je blÃ­zke optimÃ¡lnemu rieÅ¡eniu xopt = (1011), kde (xopt) = 11/15 a f(11/15) = 0,9973, ale s âveÄ¾kouâ Hammingovou vzdialenosÅ¥ou d = 3 (v genetickom algoritme tento efekt sa nazÃ½va âHammingov Ãºtesâ). TÃ¡to relatÃ­vne veÄ¾kÃ¡ Hammingova vzdialenosÅ¥ je hlavnÃ½ dÃ´vod preÄo replikÃ¡torovÃ½ algoritmus nie je schopnÃ½ poskytnÃºÅ¥ globÃ¡lne rieÅ¡enie (1011)."
240,229,0.379,PROGRAMOVANIE V JAZYKU C V RIEÅ ENÃCH PRÃKLADOCH 1,"je moÅ¾nÃ½ pre nenulovÃ© b). Ak je b nulovÃ©, tak dostÃ¡vame rovnicu c = 0, ktorÃ¡ mÃ¡ pre koeficient c s hodnotou 0 nekoneÄne veÄ¾a rieÅ¡enÃ­ (x) a pre koeficient c â  0 nemÃ¡ rieÅ¡enie. Do vÃ½slednej funkcie preto doplnÃ­me nasledujÃºce prÃ­kazy:"
76,329,0.378,PRAVDEPODOBNOSÅ¤ A MATEMATICKÃ Å TATISTIKA,"KtorÃ¡ z nich je nevychÃ½lenÃ½m odhadom ploÅ¡nÃ©ho obsahu P? RieÅ¡enie. PripomeÅme, Å¾e veliÄiny modelujÃº (predstavujÃº) merania dÄºÅ¾ky , t. j. pre = 1, 2, ..., 10, mÃ¡me: = + , kde nÃ¡hodnÃ¡ veliÄina modeluje chybu -tÃ©ho merania. Merania sme realizovali tak, Å¾e , , ... , mÃ´Å¾eme povaÅ¾ovaÅ¥ za 10-ticu nezÃ¡vislÃ½ch veliÄÃ­n, priÄom predpokladÃ¡me, Å¾e E( ) = 0 a var( ) = ï³2. Zrejme pre = 1, 2, ... , 10 platÃ­ E( ) = E( +"
43,500,0.375,Objektovo orientovanÃ© programovanie v C++,"CviÄenia 1. Vytvorte vektor celÃ½ch ÄÃ­sel. Nech uÅ¾Ã­vateÄ¾ zadÃ¡ dÄºÅ¾ku vektora a jeho prvÃ© dva prvky. Potom doplÅte ostatnÃ© prvky tak, Å¾e kaÅ¾dÃ½ prvok bude sÃºÄtom dvoch predchÃ¡dzajÃºcich. 2. Vytvorte si sÃºbor, v ktorom budÃº zapÃ­sanÃ© celÃ© ÄÃ­sla. Vytvorte si vektor celÃ½ch ÄÃ­sel a naÄÃ­tajte doÅho vÅ¡etky ÄÃ­sla zo sÃºboru. Potom spoÄÃ­tajte, koÄ¾ko je v zozname pÃ¡rnych a koÄ¾ko nepÃ¡rnych ÄÃ­sel. V prvej verzii naprogramujte poÄÃ­tanie pÃ¡rnych a nepÃ¡rnych ÄÃ­sel sami. V druhej verzii pouÅ¾ite funkciu count if z kniÅ¾nice algorithm. 3. V sÃºbore sÃº zapÃ­sanÃ© slovÃ¡, kaÅ¾dÃ© v jednom riadku. Vytvorte vektor s prvkami typu string a naÄÃ­tajte doÅho vÅ¡etky slovÃ¡. Potom nech uÅ¾Ã­vateÄ¾ zadÃ¡ nejakÃ© pÃ­smeno. VymaÅ¾te zo zoznamu vÅ¡etky slovÃ¡, ktorÃ© sa zaÄÃ­najÃº danÃ½m pÃ­smenom. 4. Nech uÅ¾Ã­vateÄ¾ postupne zadÃ¡va vrcholy mnohouholnÃ­ka (predpokladajme, Å¾e ich zadÃ¡va sprÃ¡vne, teda Å¾e sa jednotlivÃ© strany nepretÃ­najÃº). Nech sa naÄÃ­tanie konÄÃ­ vtedy, ak znova zadÃ¡ prvÃ½ bod, ÄÃ­m sa mnohouholnÃ­k uzavrie. Vytvorte triedu bod, ktorÃ¡ bude maÅ¥ dva Ãºdaje - sÃºradnice x a y. Nech sa vrcholy mnohouholnÃ­ka ukladajÃº vo vektore, ktorÃ©ho prvkami budÃº objekty triedy bod. Po naÄÃ­tanÃ­ vrcholov vypoÄÃ­tajte obvod mnohouholnÃ­ka. 5. Zoberte si nejakÃ½ program v C alebo C++. Vytvorte si vektor s prvkami typu string a naÄÃ­tajte doÅho postupne vÅ¡etky riadky programu (kaÅ¾dÃ½ prvok bude obsahovaÅ¥ jeden riadok). Potom vytvorte novÃ½ sÃºbor tak, Å¾e odstrÃ¡nite vÅ¡etky komentÃ¡re, teda budÃº v Åom len samotnÃ© prÃ­kazy. JednoduchÅ¡ia verzia mÃ´Å¾e vymazÃ¡vaÅ¥ len jednoriadkovÃ© komentÃ¡re, teda riadky, ktorÃ© zaÄÃ­najÃº znakmi â//â. PokroÄilejÅ¡ia verzia mÃ´Å¾e odstraÅovaÅ¥ aj viacriadkovÃ© komentÃ¡re ohraniÄenÃ© znakmi â/*â a â*/â. MÃ´Å¾ete predpokladaÅ¥, Å¾e komentÃ¡re nikdy nezaberajÃº len ÄasÅ¥ riadku. 6. Vytvorte mnoÅ¾inu znakov obsahujÃºcu len malÃ© pÃ­smenÃ¡ abecedy. PÃ­smenÃ¡ v nej budÃº usporiadanÃ© abecedne, ale s malou obmenou â samohlÃ¡sky budÃº vÅ¾dy pred spoluhlÃ¡skami. Nech program postupne ÄÃ­ta od uÅ¾Ã­vateÄ¾a znaky a zaraÄuje ich do mnoÅ¾iny. Ak uÅ¾Ã­vateÄ¾ zadÃ¡ nieÄo inÃ© ako malÃ© pÃ­smeno abecedy, bude tento vstup ignorovanÃ½ okrem prÃ­padu, keÄ zadÃ¡ pÃ­smeno âKâ. Vtedy program ukonÄÃ­ naÄÃ­tavanie a vypÃ­Å¡e obsah mnoÅ¾iny. 7. Vytvorte multimapu, v ktorej budÃº uloÅ¾enÃ© Ãºdaje o knihÃ¡ch â jeden prvok dvojice bude nÃ¡zov knihy a druhÃ½ rok vydania. Navrhnite multimapu najprv"
43,277,0.374,Objektovo orientovanÃ© programovanie v C++,"V kapitole 1 sme si hovorili, Å¾e polymorï¬zmus alebo mnohotvÃ¡rnosÅ¥ je princÃ­p, ktorÃ½ nÃ¡m umoÅ¾Åuje nazvaÅ¥ jednÃ½m menom viacero rovnako zameranÃ½ch funkciÃ­ â ako vyplÃ½va zo samotnÃ©ho nÃ¡zvu, jedna funkcia mÃ´Å¾e maÅ¥ viacero âtvÃ¡rÃ­â alebo podÃ´b. JednotlivÃ© varianty funkcie vykonÃ¡vajÃº principiÃ¡lne rovnakÃº ÄinnosÅ¥, majÃº vÅ¡ak rÃ´zny kÃ³d. KvÃ´li jednoznaÄnej odlÃ­Å¡iteÄ¾nosti, ktorÃº si podrobnejÅ¡ie rozoberieme neskÃ´r, platÃ­ pravidlo, Å¾e varianty jednej funkcie sa musia lÃ­Å¡iÅ¥ v parametroch â Äi uÅ¾ ide o ich typ alebo poÄet. Inak vÅ¡ak, Äo sa tÃ½ka rozdielov medzi jednotlivÃ½mi variantmi, nie sÃº danÃ© nijakÃ© podmienky. OdliÅ¡nosti mÃ´Å¾u byÅ¥ nepatrnÃ©, naprÃ­klad mÃ´Å¾e Ã­sÅ¥ len o typ jednÃ©ho parametra, inokedy vÅ¡ak mÃ´Å¾e byÅ¥ odliÅ¡nÃ½ aj celÃ½ obsah funkcie. Ãlohou polymorï¬zmu je sprehÄ¾adniÅ¥ kÃ³d, obmedziÅ¥ mnoÅ¾stvo rÃ´znych pomenovanÃ­ v prÃ­pade charakterovo prÃ­buznÃ½ch funkciÃ­ a zabezpeÄiÅ¥ Äo najvÃ¤ÄÅ¡iu ï¬exibilitu a Ä¾ahkÃº rozÅ¡Ã­riteÄ¾nosÅ¥ programu. Polymorï¬zmus je logickÃ¡ zÃ¡leÅ¾itosÅ¥ a jedinÃ©, Äo kompilÃ¡tor dokÃ¡Å¾e skontrolovaÅ¥, je jednoznaÄnÃ¡ odlÃ­Å¡iteÄ¾nosÅ¥ jednotlivÃ½ch variantov. VÅ¡etko ostatnÃ© zÃ¡visÃ­ vÃ½hradne od programÃ¡tora. Ak by sa vÅ¡etky funkcie v programe, resp. vÅ¡etky metÃ³dy v rÃ¡mci jednej triedy (okrem konÅ¡truktora) lÃ­Å¡ili v poÄte alebo type parametrov, kompilÃ¡tor pokojne dovolÃ­ programÃ¡torovi prideliÅ¥ vÅ¡etkÃ½m rovnakÃ© nÃ¡zvy. To by samozrejme nebolo najÅ¡ikovnejÅ¡ie usporiadanie programu. Rovnako by sa mali volaÅ¥ skutoÄne len funkcie s rovnakÃ½m alebo podobnÃ½m ÃºÄelom a mieru podobnosti musÃ­ zvÃ¡Å¾iÅ¥ tvorca programu vo fÃ¡ze jeho analÃ½zy alebo dizajnu. Polymorï¬zmus sa tÃ½ka vÅ¡etkÃ½ch funkciÃ­ v programe, vrÃ¡tane konÅ¡truktorov tried, jedinou vÃ½nimkou sÃº deÅ¡truktory, ktorÃ© nemajÃº nijakÃ© parametre, a preto nie je moÅ¾nosÅ¥ navrhnÃºÅ¥ dva deÅ¡truktory, ktorÃ© by sa lÃ­Å¡ili v poÄte alebo type parametrov. Treba eÅ¡te poznamenaÅ¥, Å¾e polymorï¬zmus nie je vÃ½hradne Ärtou objektovo orientovanÃ©ho programovania a v C++ ho mÃ´Å¾e pokojne vyuÅ¾Ã­vaÅ¥ aj procedurÃ¡lny program. NajvÃ¤ÄÅ¡ie uplatnenie polymorï¬zmu je vÅ¡ak v objektovo orientovanom programovanÃ­, keÄÅ¾e v Åom je otÃ¡zka dobrÃ©ho usporiadania a prehÄ¾adnosti programu kÄ¾ÃºÄovÃ¡. Nakoniec eÅ¡te zopakujme, Å¾e vytvorenie viacerÃ½ch variantov jednej funkcie sa nazÃ½va aj preÅ¥aÅ¾enie funkcie alebo overloading."
43,13,0.374,Objektovo orientovanÃ© programovanie v C++,"dom nÃ¡Å¡ho suseda, rodiÄovskÃ½ dom atÄ. Takto by sme mohli pokraÄovaÅ¥ Äalej. Ak by sme nÃ¡Å¡ svet povaÅ¾ovali za program, potom by sme skutoÄne vÅ¡etky predmety, hmotnÃ© aj nehmotnÃ©, mohli vidieÅ¥ ako objekty istÃ½ch tried a takisto platÃ­, Å¾e kaÅ¾dÃº akciu, ktorÃ¡ sa udeje, vykonÃ¡va objekt nejakej triedy. Å½iadna akcia nemÃ´Å¾e existovaÅ¥ nezÃ¡visle, kaÅ¾dÃ¡ schopnosÅ¥ alebo ÄinnosÅ¥ je spojenÃ¡ s nejakou triedou. NaprÃ­klad Ã­sÅ¥ mÃ´Å¾e Älovek alebo auto, svietiÅ¥ mÃ´Å¾e lampa alebo vesmÃ­rne teleso, stÃ¡Å¥ mÃ´Å¾e budova atÄ. Rovnako to platÃ­ pre vlastnosti â hÄºbku mÃ´Å¾u maÅ¥ jazerÃ¡ alebo nÃ¡doby, farbu vÅ¡etky viditeÄ¾nÃ© objekty. Presne tieto princÃ­py boli inÅ¡pirÃ¡ciou pre vytvorenie objektovo orientovanÃ©ho programovania a dobre navrhnutÃ© objektovo orientovanÃ© programy by mali pripomÃ­naÅ¥ organizÃ¡ciu a logiku reÃ¡lneho sveta."
115,169,0.373,Algebra a diskrÃ©tna  matematika,"rieÅ¡enie. Ako ÄalÅ¡iu zaÄneme pozÃ­ciu (2,1) pre prvÃº dÃ¡mu. Po niekoÄ¾kÃ½ch nÃ¡vratoch v strome rieÅ¡enÃ­ nÃ¡jdeme umiestnenie zvyÅ¡nÃ½ch dÃ¡m na pozÃ­ciÃ¡ch (4,2), (6,3), (1,4), (3,5), a (5,6). 13.14. PouÅ¾ite prehÄ¾adÃ¡vanie do hÄºbky na nÃ¡jdenie podmnoÅ¾iny, pokiaÄ¾ existuje, pre mnoÅ¾inu {27, 24, 19, 14, 11, 8} so sÃºÄtom rovnÃ½m (a) 41 Po prekroÄenÃ­ hÄ¾adanÃ©ho sÃºÄtu sa uÅ¾ nepokraÄuje hlbÅ¡ie do stromu prehÄ¾adÃ¡vania a pridÃ¡vajÃº sa vÅ¾dy iba menÅ¡ie ÄÃ­sla, ako je uÅ¾ najmenÅ¡ie obsiahnutÃ© vo vytvÃ¡ranej podmnoÅ¾ine."
76,274,0.367,PRAVDEPODOBNOSÅ¤ A MATEMATICKÃ Å TATISTIKA,"mery v celkovej produkcii sa prakticky nezmenili (piaty vÃ½robok vyberÃ¡me za rovnakÃ½ch okolnostÃ­ ako prvÃ½). Preto sa na vÃ½ber bez vrÃ¡tenia mÃ´Å¾eme pozeraÅ¥ ako na vÃ½ber s vrÃ¡tenÃ­m. VÃ½ber chÃ¡peme ako 10-nÃ¡sobnÃ© nezÃ¡vislÃ© opakovanie toho istÃ©ho pokusu â tÃ½m pokusom je nÃ¡hodnÃ½ vÃ½ber vÃ½robku z celkovej produkcie. UrÄime pravdepodobnosÅ¥ toho, Å¾e a) Å¾ivotnosÅ¥ kaÅ¾dÃ©ho vybratÃ©ho bude aspoÅ 300 hod. b) Å¾ivotnosÅ¥ aspoÅ jednÃ©ho vybratÃ©ho prevÃ½Å¡i 1500 hod. RieÅ¡enie. Toto je typickÃ¡ pravdepodobnostnÃ¡ Ãºloha, keÄ predpokladÃ¡me, Å¾e rozdelenie Å¾ivotnosti je exponenciÃ¡lne rozdelenie (so znÃ¡mym parametrom). AnalogickÃº situÃ¡ciu sme rozoberali v kapitole 3 (pozri 3.2.4 a 3.2.5). V Äl. 6.2 vysvetlÃ­me, Å¾e nÃ¡hodnÃ½ vÃ½ber budeme modelovaÅ¥ 10-ticou , , ..., nezÃ¡vislÃ½ch nÃ¡hodnÃ½ch veliÄÃ­n , pre ktorÃ© â podÄ¾a predpokladu â platÃ­: ~ Exp(ï¬), kde ï¬ = 0.001. Teraz chceme urÄiÅ¥ a) P( â b) P( â Zrejme P(â resp. P(â"
236,123,0.367,Nie prÃ­liÅ¡ struÄnÃ½ Ãºvod do systÃ©mu LATEX2e,"PrÃ­kaz \nonumber spÃ´sobÃ­, Å¾e LATEX danÃº rovnicu neoÄÃ­sluje. MÃ´Å¾e byÅ¥ nÃ¡roÄnÃ© vytvoriÅ¥ pomocou tÃ½chto metÃ³d vertikÃ¡lne zarovnanÃ© rovnice, ktorÃ© vyzerajÃº dobre. BalÃ­k amsmath poskytuje viac moÅ¾nostÃ­ na rieÅ¡enie tohoto problÃ©mu (pozri prostredia split a align)."
43,420,0.366,Objektovo orientovanÃ© programovanie v C++,"9.1 Å ablÃ³ny a generickÃ© programovanie V celom doterajÅ¡om texte sme postupovali tak, Å¾e pri vytvÃ¡ranÃ­ nejakej triedy alebo funkcie sme presne urÄili vÅ¡etky dÃ¡tovÃ© typy. Ãdaje tried, parametre funkciÃ­, ich nÃ¡vratovÃ© hodnoty a vÃ´bec vÅ¡etky premennÃ© v programe mali jednoznaÄne danÃ½ svoj typ. Ak by sme to neurobili, nÃ¡Å¡ program by ani nepreÅ¡iel kompilÃ¡ciou. MoÅ¾nosti objektovo orientovanÃ©ho programovania v C++ sÃº Å¡irokÃ© a pri ich sprÃ¡vnom pouÅ¾itÃ­ dokÃ¡Å¾eme skutoÄne zefektÃ­vniÅ¥ a prehÄ¾adne usporiadaÅ¥ zÃ¡pis programu. Autor C++ vÅ¡ak v snahe o eÅ¡te vÃ¤ÄÅ¡iu efektÃ­vnosÅ¥ zaÅ¡iel eÅ¡te Äalej a sÃºstredil sa prÃ¡ve na dÃ¡tovÃ© typy. V programoch sa totiÅ¾ Äasto stÃ¡valo, Å¾e vznikali naprÃ­klad funkcie, ktorÃ© mali v podstate identickÃ½ obsah a lÃ­Å¡ili sa len typom niektorÃ½ch premennÃ½ch, parametrov alebo nÃ¡vratovej hodnoty. Polymorï¬zmus umoÅ¾Åuje takÃ©to funkcie pomenovaÅ¥ rovnakÃ½m nÃ¡zvom a tÃ½m odbÃºra mnoÅ¾stvo rÃ´znych mien, ktorÃ© by sa v programe mohli nahromadiÅ¥. Faktom ale zostÃ¡va, Å¾e vÅ¡etky verzie funkcie musÃ­ programÃ¡tor napÃ­saÅ¥ a kÃ³d tak obsahuje opakujÃºce sa Äasti. RieÅ¡enie tohto problÃ©mu ponÃºkajÃº Å¡ablÃ³ny (angl. template). VÄaka Å¡ablÃ³nam mÃ´Å¾eme deï¬novaÅ¥ vÅ¡eobecnÃ© funkcie alebo aj triedy, v ktorÃ½ch sa typ dÃ¡t urÄÃ­ aÅ¾ v okamihu ich pouÅ¾itia. V reÃ¡lnom svete je Å¡ablÃ³nou naprÃ­klad strih Å¡iat â podÄ¾a jednÃ©ho strihu sa dajÃº uÅ¡iÅ¥ Å¡aty rÃ´znych farieb alebo z rÃ´znych materiÃ¡lov. VÅ¡etky budÃº maÅ¥ rovnakÃ½ tvar, ale v konkrÃ©tnom prevedenÃ­ sa budÃº lÃ­Å¡iÅ¥. Strih mÃ´Å¾eme pouÅ¾iÅ¥ kedykoÄ¾vek a Ä¾ubovoÄ¾ne veÄ¾akrÃ¡t. RovnakÃ© je to aj so Å¡ablÃ³nami funkciÃ­ a tried. MÃ´Å¾eme podÄ¾a nich kedykoÄ¾vek vyrobiÅ¥ funkciu alebo triedu, ktorÃ¡ bude maÅ¥ presne danÃ½ tvar, rovnako ako je danÃ½ tvar Å¡iat, a Ãºlohu farby alebo materiÃ¡lu tu budÃº hraÅ¥ dÃ¡tovÃ© typy â v nich bude kaÅ¾dÃ¡ funkcia alebo trieda originÃ¡lna a odliÅ¡nÃ¡ od ostatnÃ½ch funkciÃ­ alebo tried s rovnakÃ½m tvarom. GenerickÃ© programovanie (angl. generic programming) je programovanie vyuÅ¾Ã­vajÃºce Å¡ablÃ³ny. GenerickÃ© znamenÃ¡ vÅ¡eobecnÃ©, Äo nÃ¡m napovedÃ¡, Å¾e v programe sa budÃº vyskytovaÅ¥ zovÅ¡eobecnenÃ© funkcie alebo triedy."
393,483,0.362,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 2,"Podpora mikroarchitektÃºr MikroarchitektÃºry (Alur et al., 2001) sÃº definovanÃ© v kontexte enterprise softvÃ©rovÃ½ch architektÃºr ako mnoÅ¾iny spolupracujÃºcich vzorov pre rieÅ¡enie rozsiahlejÅ¡Ã­ch problÃ©mov, pre realizÃ¡ciu celÃ½ch systÃ©mov alebo podsystÃ©mov. MikroarchitektÃºra je urÄenÃ¡ na rieÅ¡enie hrubozrnnÃ½ch problÃ©mov, ktorÃ© nemÃ´Å¾u byÅ¥ vyrieÅ¡enÃ© jedinÃ½m vzorom. (Alur et al., 2001) Za prÃ­klad mikroarchitekÃºry mÃ´Å¾eme povaÅ¾ovaÅ¥ spoluprÃ¡cu vzorov Composite a Iterator podÄ¾a obrÃ¡zka 9-5, kedy Iterator zabezpeÄuje prechÃ¡dzanie po Å¡truktÃºrach uloÅ¾enÃ½ch v inÅ¡tancii triedy Composite vrapujÃºcej konkrÃ©tny kontajner. Vzor Composite rieÅ¡i problÃ©m zovÅ¡eobecnenia zloÅ¾enÃ­n a jednotlivÃ½ch prvkov a na sprÃ­stupÅovanie jednotlivÃ½ch prvkov vo vrapovanom kontajneri vyuÅ¾Ã­va moÅ¾nosti vzoru Iterator. NÃ¡vrhÃ¡r pouÅ¾Ã­vajÃºci vzor Composite navyÅ¡e nemusÃ­ vedieÅ¥ o pouÅ¾Ã­vanÃ­ mikroarchitektÃºry so vzorom Iterator. CASE nÃ¡stroje by mali Äo moÅ¾no v najvÃ¤ÄÅ¡ej miere umoÅ¾niÅ¥ prÃ¡cu s mikroarchitektÃºrami bez explicitnej znalosti nÃ¡vrhÃ¡ra."
190,81,0.362,O softvÃ©ri od A po Z ; Ãvahy nastupujÃºcich profesionÃ¡lov,"konfliktov medzi vÃ½vojÃ¡rmi a testermi mÃ´Å¾eme kategorizovaÅ¥ do troch vrstiev: (i) proces testovania softvÃ©ru, (ii) Ä¾udia a (iii) organizÃ¡cia [1]. V kaÅ¾dej z tÃ½chto vrstiev sa dajÃº identifikovaÅ¥ moÅ¾nÃ© zdroje konfliktu a nÃ¡sledne moÅ¾nosti podpory rieÅ¡enia zo strany manaÅ¾Ã©ra."
369,283,0.36,AplikaÄnÃ© architektÃºry softvÃ©rovÃ½ch systÃ©mov,"Obr. 4.33. Vzor ÃverovÃ½ prÃ­pad â 1. ÄasÅ¥ ViacerÃ© z tried zodpovedajÃºcich hlavnÃ½m vÃ½stupom krokov ÃºverovÃ©ho procesu majÃº rovnakÃ© alebo podobnÃ© atribÃºty, ich hodnoty sa vÅ¡ak mÃ´Å¾u navzÃ¡jom lÃ­Å¡iÅ¥. NaprÃ­klad: ï· ÃrokovÃ¡ sadzba v indikatÃ­vnej ponuke je orientaÄnÃ¡ (urÄenÃ¡ intervalom), kÃ½m v nÃ¡vrhu je spresnenÃ¡ predajcom na zÃ¡klade finanÄnej analÃ½zy klienta. ÃrokovÃ¡ sadzba z nÃ¡vrhu mÃ´Å¾e byÅ¥ eÅ¡te zmenenÃ¡ v rozhodnutÃ­ o Ãºvere. (PoznÃ¡mka: pri hypo-"
111,116,0.359,ZÃ¡kladnÃ© metÃ³dy na zlepÅ¡enie pouÅ¾itelânosti webov,"RÃ½chlejÅ¡ia reprodukcia chÃ½b ZloÅ¾itosÅ¥ webovÃ½ch strÃ¡nok/aplikÃ¡ciÃ­ spÃ´sobuje, Å¾e niektorÃ© veci jednoducho nebudÃº vÅ¾dy fungovaÅ¥ tak, ako by mali. Je potrebnÃ© zohÄ¾adniÅ¥ mnoÅ¾stvo podmienok, ako sÃº rÃ´zne typy zariadenÃ­, operaÄnÃ½ch systÃ©mov a prehliadaÄov, ako aj rÃ´zne rozlÃ­Å¡enia obrazovky alebo lokalizÃ¡cie. A to ani neberieme do Ãºvahy faktor pouÅ¾Ã­vateÄ¾a, ktorÃ½ mÃ¡ pri danej prÃ­leÅ¾itosti nekoneÄnÃº schopnosÅ¥ âpokaziÅ¥ veciâ spÃ´sobom, ktorÃ½ by vÃ½vojÃ¡r nikdy neÄakal (samozrejme pouÅ¾Ã­vateÄ¾, nÃ¡Å¡ zÃ¡kaznÃ­k nÃ¡Å¡ pÃ¡n, preto pokazil v ÃºvodzovkÃ¡ch). Testovanie toÄ¾kÃ½ch moÅ¾nostÃ­ sa rÃ½chlo stÃ¡va nemoÅ¾nÃ½m. KeÄ je objavenÃ¡ a nahlÃ¡senÃ¡ chyba, Äasto narazÃ­te na ÄalÅ¡Ã­ problÃ©m. Ako problÃ©m reprodukovaÅ¥. Pridanie nahrÃ¡vania sedenÃ­ mÃ´Å¾e zmeniÅ¥ spÃ´sob rieÅ¡enia chÃ½b, ktorÃ© sa objavia na vaÅ¡ich webovÃ½ch strÃ¡nkach. Namiesto toho, aby ste poÅ¾iadali pouÅ¾Ã­vateÄ¾a o zopakovanie krokov, ktorÃ© viedli k chybe, alebo aby ste ho poÅ¾iadali o poskytnutie snÃ­mky obrazovky, mÃ´Å¾ete si pozrieÅ¥ jeho sedenie a vidieÅ¥ chybu na vlastnÃ© oÄi."
76,36,0.359,PRAVDEPODOBNOSÅ¤ A MATEMATICKÃ Å TATISTIKA,"1.2.10 PrÃ­klad. V Å¡katuli mÃ¡me loptiÄky oÄÃ­slovanÃ© ÄÃ­slami 1 aÅ¾ 9. Realizujme nÃ¡hodnÃ½ vÃ½ber rozsahu 3 bez vrÃ¡tenia a za vÃ½sledok povaÅ¾ujme usporiadanÃº trojicu ÄÃ­sel. AkÃ¡ je pravdepodobnosÅ¥ toho, Å¾e vÃ½sledok vÃ½beru vytvorÃ­ rastÃºcu postupnosÅ¥? RieÅ¡enie. PoÄet vÅ¡etkÃ½ch moÅ¾nÃ½ch usporiadanÃ½ch vÃ½berov bez vrÃ¡tenia sa rovnÃ¡ sÃºÄinu 9ï8ï7 = 504 (podÄ¾a 1.2.4). Nech A znamenÃ¡ udalosÅ¥, Å¾e vÃ½ber skonÄÃ­ rastÃºcou postupnosÅ¥ou troch ÄÃ­sel. Treba nÃ¡jsÅ¥ |A|. PretoÅ¾e ide o trojice rÃ´znych prvkov, vÅ¾dy Å¡iestim prÃ­padom odpovedÃ¡ jeden, priaznivÃ½ pre udalosÅ¥ A. Napr. trojiciam (1, 3, 4) (1, 4, 3) (3, 1, 4) (3, 4, 1) (4, 1, 3) (4, 3, 1) odpovedÃ¡ jedna rastÃºca trojica (1, 3, 4). KeÄÅ¾e poÄet vÅ¡etkÃ½ch usporiadanÃ½ch trojÃ­c sa rovnÃ¡ V(9, 3), poÄet rastÃºcich trojÃ­c sa rovnÃ¡ V(9, 3)/3! = C(9, 3). To znamenÃ¡, Å¾e |A|= C(9, 3) = 84. Pre P(A) mÃ¡me P(A) = 1.2.11 (NÃ¡hodnÃ© rozmiestnenia â mechanizmus) UvaÅ¾ujme o prieÄinkoch, oÄÃ­slovanÃ½ch od 1 po . Majme obÃ¡lok, ktorÃ© budeme nÃ¡hodne rozmiestÅovaÅ¥ do prieÄinkov. Äo znamenÃ¡ nÃ¡hodne? Predstavme si, Å¾e bokom umiestnime Å¡katuÄ¾u, ktorÃ¡ obsahuje lÃ­stkov s ÄÃ­slami 1 aÅ¾ . NÃ¡hodne Å¥ahÃ¡me prvÃ½ lÃ­stok zo Å¡katule a ÄÃ­slo na lÃ­stku bude znamenaÅ¥ ÄÃ­slo prieÄinku, do ktorÃ©ho dÃ¡me prvÃº obÃ¡lku. DruhÃ¡ obÃ¡lka bude putovaÅ¥ do prieÄinka s takÃ½m ÄÃ­slom, akÃ© bolo uvedenÃ© na druhom vytiahnutom lÃ­stku atÄ. Zrejme na umiestnenie obÃ¡lok bude potrebnÃ½ nÃ¡hodnÃ½ vÃ½ber rozsahu . Budeme diskutovaÅ¥ prÃ­pad, keÄ obÃ¡lky sÃº rozlÃ­Å¡iteÄ¾nÃ© (oznaÄenÃ©) a prÃ­pad, keÄ nie sÃº. ÄalÅ¡ou okolnosÅ¥ou bude, Äi prieÄinok mÃ´Å¾e obsahovaÅ¥ viac ako jednu obÃ¡lku, alebo nie. Rozoberme jednotlivÃ© prÃ­pady."
76,279,0.356,PRAVDEPODOBNOSÅ¤ A MATEMATICKÃ Å TATISTIKA,"beru je deÅ¡truktÃ­vnej povahy (ako napr. pri meranÃ­ Å¾ivotnosti vÃ½robkov, alebo pevnosti nosnÃ­kov). V takÃ½ch prÃ­padoch je sÃ­ce poruÅ¡enÃ¡ nezÃ¡vislosÅ¥ avÅ¡ak obyÄajne rozsah nÃ¡hodnÃ©ho vÃ½beru je podstatne menÅ¡Ã­ ako rozsah zÃ¡kladnÃ©ho sÃºboru, a preto nepatrnÃ© poruÅ¡enie nezÃ¡vislosti mÃ´Å¾eme zanedbaÅ¥ (pozri Ãºlohu 6.6.1). TermÃ­n nÃ¡hodnÃ½ vÃ½ber sa pouÅ¾Ã­va aj tam, kde sa v skutoÄnosti niÄ nevyberÃ¡, ale za tÃ½ch istÃ½ch podmienok sa -krÃ¡t (a nezÃ¡visle na sebe) meria sledovanÃ¡ nÃ¡hodnÃ¡ veliÄina (pozri prÃ­klad 6.2.8). 6.2.6 DefinÃ­cia. NÃ¡hodnÃ½ vÃ½ber z rozdelenia, ktorÃ© urÄuje distribuÄnÃ¡ funkcia , je -tica nÃ¡hodnÃ½ch veliÄÃ­n , , ... , s vlastnosÅ¥ami: 1. VÅ¡etky majÃº rovnakÃ© rozdelenie. Funkcia je distribuÄnou funkciou kaÅ¾dej 2. VeliÄiny , , ... , sÃº nezÃ¡vislÃ© nÃ¡hodnÃ© veliÄiny."
190,37,0.355,O softvÃ©ri od A po Z ; Ãvahy nastupujÃºcich profesionÃ¡lov,"Ak by sme chceli maÅ¥ vo firme pre kaÅ¾dÃº oblasÅ¥ Å¡piÄkovÃ©ho odbornÃ­ka, museli by sme maÅ¥ zÃ¡roveÅ dostatoÄnÃ© mnoÅ¾stvo projektov, aby boli vÅ¡etci primerane vyÅ¥aÅ¾enÃ­. ZÃ¡roveÅ treba, aby sa vÅ¡etci tÃ­to Ä¾udia venovali problÃ©mom na najvyÅ¡Å¡ej Ãºrovni zloÅ¾itosti alebo problÃ©mom, ktorÃ½ch zlÃ© rieÅ¡enie mÃ´Å¾e maÅ¥ veÄ¾mi vÃ¡Å¾ne dopady na projekt. Ak by sa nÃ¡m podarilo zabezpeÄiÅ¥ takÃ½to stav, mÃ´Å¾eme pokojne uvaÅ¾ovaÅ¥ nad zamestnanÃ­m potrebnÃ©ho poÄtu Outsorcovanie Å¡piÄkovÃ½ch odbornÃ­kov na plnÃ½ pracovnÃ½ ÃºvÃ¤zok. MyslÃ­m si vÅ¡ak, Å¾e najmÃ¤ Å¡piÄkovÃ©ho v oblasti IT je takÃ½to stav dosiahnuteÄ¾nÃ½ len veÄ¾mi Å¥aÅ¾ko a zamestnÃ¡vaÅ¥ vÃ¤ÄodbornÃ­ka je Å¡iu skupinu Å¡piÄkovÃ½ch odbornÃ­kov si mÃ´Å¾u dovoliÅ¥ len veÄ¾kÃ© firmy. Äasto lepÅ¡Ã­m spÃ´sobom, ako pristupovaÅ¥ k angaÅ¾ovaniu Å¡piÄkovÃ©ho Äasto lepÅ¡ie ako odbornÃ­ka, je zvÃ¡Å¾enie jeho outsourcovania. Samozrejme outsourcovanie jeho priame takÃ©hoto Äloveka bude z krÃ¡tkodobÃ©ho pohÄ¾adu eÅ¡te drahÅ¡ie ako keby bol angaÅ¾ovanie. v naÅ¡ej firme normÃ¡lne zamestnanÃ½, ale takÃ½mto spÃ´sobom Å¡etrÃ­m peniaze v Äase, keÄ takto kvalifikovanÃº pracovnÃº silu nepotrebujem a bez problÃ©mov si vystaÄÃ­m s terajÅ¡Ã­mi zamestnancami. Peniaze investovanÃ© do outsourcingu by sa mali vrÃ¡tiÅ¥ pridanou hodnotou, ktorÃº prenajatÃ½ Älovek vyprodukuje a ak je to skutoÄne Å¡piÄkovÃ½ odbornÃ­k a je nasadenÃ½ na sprÃ¡vny problÃ©m, mÃ´Å¾em hovoriÅ¥ o viac ako ÃºspeÅ¡nom obchode. Vo firme, kde pracujem, pouÅ¾Ã­vame tento spÃ´sob outsourcingu relatÃ­vne Äasto. Pri novÃ½ch, vÃ¤ÄÅ¡Ã­ch projektoch sa nÃ¡m osvedÄilo outsourcovaÅ¥ analÃ½zu problÃ©movej oblasti na Å¡piÄkovÃ©ho odbornÃ­ka a myslÃ­m si, Å¾e prÃ¡ve kvalita jeho analÃ½z, na ktorÃ½ch nÃ¡sledne stojÃ­ celÃ½ ÄalÅ¡Ã­ projekt, je dostatoÄnou pridanou hodnotou za cenu, ktorÃº takÃ©to outsourcovanie stojÃ­. Len na margo spomeniem, Å¾e tÃ¡to forma outsourcingu so sebou uÅ¾ prinÃ¡Å¡a oveÄ¾a vÃ¤ÄÅ¡ie rizikÃ¡ ako v prvom prÃ­pade. Outsourcujeme totiÅ¾ oblasti, ktorÃ© mÃ´Å¾u tvoriÅ¥ nÃ¡Å¡ hlavnÃ½ biznis, kde hrozÃ­"
43,238,0.353,Objektovo orientovanÃ© programovanie v C++,"â¢ MetÃ³du Nacitaj, ktorÃ¡ naÄÃ­ta obrÃ¡zok zo sÃºboru. â¢ MetÃ³du Inverzia, ktorÃ¡ invertuje obrÃ¡zok a vÃ½sledok zapÃ­Å¡e do sÃºboru. â¢ MetÃ³du PreklopX, ktorÃ¡ preklopÃ­ obrÃ¡zok podÄ¾a osi x a vÃ½sledok zapÃ­Å¡e do sÃºboru. â¢ MetÃ³du PreklopY, ktorÃ¡ preklopÃ­ obrÃ¡zok podÄ¾a osi y a vÃ½sledok zapÃ­Å¡e do sÃºboru. 5. PrepÃ­Å¡te hru Pexeso (kapitola 4, cviÄenie 6) do objektovo orientovanej podoby. 6. Vytvorte objektovo orientovanÃ½ program, ktorÃ½ bude vedieÅ¥ spracovÃ¡vaÅ¥ objednÃ¡vky tovaru od zÃ¡kaznÃ­kov. Ãdaje o objednÃ¡vkach sÃº uloÅ¾enÃ© v textovom sÃºbore, pre kaÅ¾dÃº z nich je uloÅ¾enÃ© meno zÃ¡kaznÃ­ka, tovar, ktorÃ½ si objednal a objednanÃ© mnoÅ¾stvo (kaÅ¾dÃ½ Ãºdaj je v samostatnom riadku). Dajme tomu, Å¾e objednÃ¡vky sa vybavujÃº presne v takom poradÃ­, v akom prichÃ¡dzajÃº. VÃ¡Å¡ program by mal vedieÅ¥ pridaÅ¥ novÃº objednÃ¡vku na koniec sÃºboru a vymazaÅ¥ z jeho zaÄiatku objednÃ¡vku, ktorÃ¡ uÅ¾ bola vybavenÃ¡. 7. NapÃ­Å¡te objektovo orientovanÃ½ program, ktorÃ½ bude vytvÃ¡raÅ¥ playlisty pre prehrÃ¡vaÄ hudby. Program bude maÅ¥ k dispozÃ­cii niekoÄ¾ko sÃºborov so zoznamami skladieb. Pre kaÅ¾dÃº skladbu sÃº v Åom zapÃ­sanÃ© tri Ãºdaje â nÃ¡zov, interpret a dÄºÅ¾ka v sekundÃ¡ch. Ãdaje pre vÅ¡etky skladby sÃº zapÃ­sanÃ© za sebou, kaÅ¾dÃ½ Ãºdaj je v samostatnom riadku. MÃ´Å¾ete predpokladaÅ¥, Å¾e v Å¾iadnom sÃºbore nie je viac ako 30 skladieb. VÃ¡Å¡ program bude vytvÃ¡raÅ¥ novÃ© playlisty tak, Å¾e vytvorÃ­ novÃ½ textovÃ½ sÃºbor a doÅho uloÅ¾Ã­ novovytvorenÃ½ zoznam skladieb. UÅ¾Ã­vateÄ¾ bude maÅ¥ niekoÄ¾ko moÅ¾nostÃ­: â¢ NÃ¡hodnÃ© preusporiadanie vÅ¡etkÃ½ch skladieb zo vÅ¡etkÃ½ch sÃºborov. â¢ NÃ¡hodnÃ© preusporiadanie vÅ¡etkÃ½ch skladieb z jednÃ©ho sÃºboru. â¢ NÃ¡hodnÃ½ vÃ½ber zadanÃ©ho poÄtu skladieb zo vÅ¡etkÃ½ch sÃºborov alebo len z jednÃ©ho vybranÃ©ho. â¢ VÃ½ber skladieb len od konkrÃ©tneho interpreta. â¢ VÃ½ber skladieb podÄ¾a dÄºÅ¾ky. NapÃ­Å¡te program tak, aby vedel vypÃ­saÅ¥ na obrazovku obsah ktorÃ©hokoÄ¾vek sÃºboru a tieÅ¾ novÃ½ playlist. V tomto vÃ½pise sa dÄºÅ¾ka skladby objavÃ­ v Å¡tandardnom formÃ¡te minÃºty:sekundy. 8. Vytvorte triedu skladba s Ãºdajmi podÄ¾a predchÃ¡dzajÃºceho cviÄenia, ktorÃ© sa budÃº daÅ¥ nastaviÅ¥ v konÅ¡truktore. V hlavnom programe potom vytvorte pole piatich skladieb tak, Å¾e priamo pri vytvÃ¡ranÃ­ poÄ¾a vymenujete vÅ¡etky jeho prvky. NÃ¡jdite potom v tomto poli vÅ¡etky skladby kratÅ¡ie ako tri minÃºty a vypÃ­Å¡te vÅ¡etky informÃ¡cie o nich. 9. NapÃ­Å¡te objektovo orientovanÃ½ program, ktorÃ½ umoÅ¾nÃ­ Å¡tudentom prihlasovaÅ¥ sa na skÃºÅ¡ky z rÃ´znych predmetov. KaÅ¾dÃ½ Å¡tudent mÃ¡ meno, Å¡tudijnÃ½ odbor a roÄnÃ­k, v ktorom prÃ¡ve je. KaÅ¾dÃ½ predmet mÃ¡ svoj textovÃ½ sÃºbor so zoznamom vÅ¡etkÃ½ch termÃ­nov. Pre kaÅ¾dÃ½ termÃ­n zase existuje textovÃ½ sÃºbor, v ktorom je zoznam uÅ¾ prihlÃ¡senÃ½ch Å¡tudentov. Å tudentovi sa na poÅ¾iadanie vypÃ­Å¡u vÅ¡etky termÃ­ny pre zadanÃ½ predmet. Ak si potom vyberie niektorÃ½ z termÃ­nov, vÅ¡etky jeho Ãºdaje sa pripÃ­Å¡u na koniec sÃºboru so Å¡tudentami, ktorÃ­ sÃº uÅ¾ na tento termÃ­n prihlÃ¡senÃ­."
130,386,0.352,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 1,"Å truktÃºra zaloÅ¾enÃ¡ na vÃ½sledkoch V organizÃ¡cii sÃº urÄenÃ© iba zÃ¡kladnÃ© ciele, ktorÃ© je potrebnÃ© dosiahnuÅ¥. Je urÄenÃ¡ Å¡truktÃºra vÃ½sledkov akÃ© majÃº jednotlivÃ© agenty dodÃ¡vaÅ¥, avÅ¡ak nie spÃ´sob ich dosiahnutia. KaÅ¾dÃ½ agent mÃ¡ vo svojej kompetencii spÃ´sob (teda aj svoje ÄiastkovÃ© ciele a Ãºlohy), akÃ½m dosiahne poÅ¾adovanÃ½ vÃ½sledok. TakÃ¡to Å¡truktÃºra je typickÃ¡ pre zabezpeÄovanie vÃ½sledkov kvantitatÃ­vnou metÃ³dou, tÃº istÃº Ãºlohu rieÅ¡i veÄ¾kÃ© mnoÅ¾stvo agentov a kvalita vÃ½sledku je spravidla ÃºmernÃ¡ poÄtu agentov, ktorÃ© sa na jej rieÅ¡enÃ­ podieÄ¾a. ÄalÅ¡ie pouÅ¾itie Å¡truktÃºry zaloÅ¾enej na vÃ½sledkoch je rieÅ¡enie veÄ¾kÃ©ho poÄtu Ãºloh s rovnakou Å¡truktÃºrou vÃ½sledku. V takomto prÃ­pade kaÅ¾dÃ½ agent dostÃ¡va inÃ© Ãºlohy a generuje vÃ½sledky s pevne danou Å¡truktÃºrou. PrÃ­kladom mÃ´Å¾e byÅ¥ predaj vÃ½robkov alebo sluÅ¾ieb, kedy mÃ¡ kaÅ¾dÃ½ agent za Ãºlohu predaÅ¥ Äo najviac vÃ½robkov. ÄinnosÅ¥ jednotlivÃ½ch predajcov je potom pomerne nezÃ¡vislÃ¡ a o spÃ´sobe maximalizÃ¡cie svojho predaja rozhoduje kaÅ¾dÃ½ agent individuÃ¡lne."
76,172,0.351,PRAVDEPODOBNOSÅ¤ A MATEMATICKÃ Å TATISTIKA,"RieÅ¡enie. V tejto situÃ¡cii je Ä¾ahkÃ© vidieÅ¥ ( ) ako zobrazenie, keÄ ï definujeme ako vÅ¡etky usporiadanÃ© pÃ¤tice nÃºl a jednotiek. Ak napr. ï· = (0, 1, 0, 1, 1), hodnotou vektora ( ) je dvojica (1, 3), pretoÅ¾e (ï·) = 1 a (ï·) = 3. Ak ï· = (1, 0, 1, 1, 1), hodnotou vektora ( ) je dvojica (2, 4), pretoÅ¾e (ï·) = 2 a (ï·) = 4. Priestor ï mÃ¡ zrejme 32 ( = ) bodov."
184,74,0.35,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 3,"TechnolÃ³gie distribuovanÃ½ch objektov sÃº dlhodobÃ½m Älenom rieÅ¡enÃ­ pre spojovacÃ­ softvÃ©r. Asi najznÃ¡mejÅ¡Ã­m z nich je CORBA (Common Object Request Broker Architecture) ako predstaviteÄ¾ distribuovanÃ©ho objektovo orientovanÃ©ho spojovacieho softvÃ©ru, ktorÃ½ sa pouÅ¾Ã­val na zaÄiatku devÃ¤Å¥desiatych rokov."
190,162,0.35,O softvÃ©ri od A po Z ; Ãvahy nastupujÃºcich profesionÃ¡lov,"CieÄ¾om tvorby nÃ¡Ärtu je dodaÅ¥ koncovÃ©mu pouÅ¾Ã­vateÄ¾ovi Äo moÅ¾no najrÃ½chlejÅ¡ie predstavu, ako bude koncovÃ© rieÅ¡enie vyzeraÅ¥, a tak sa ubezpeÄiÅ¥, Å¾e naÅ¡a predstava o vytvÃ¡ranom rieÅ¡enÃ­ koreÅ¡ponduje s predstavou pouÅ¾Ã­vateÄ¾a. PodÄ¾a mÃ´jho nÃ¡zoru je prÃ¡ve prezentÃ¡cia nÃ¡Ärtu alebo funkÄnÃ©ho prototypu najbezpeÄnejÅ¡ou formou overenia sprÃ¡vnosti formÃ¡lnej Å¡pecifikÃ¡cie pri interaktÃ­vnych aplikÃ¡ciÃ¡ch. Do nÃ¡Ärtu a Äalej prototypu sa zapracujÃº pripomienky pouÅ¾Ã­vateÄ¾a aÅ¾ do vytvorenia prvej oficiÃ¡lnej verzie. TÃ¡to sa odovzdÃ¡ pouÅ¾Ã­vateÄ¾ovi a upravuje sa na jeho Å¾iadosÅ¥. ObrÃ¡zok 1 zobrazuje deÄ¾bu projektu po Äasovej osi na etapy a po funkÄnej osi na komponenty. Po nÃ¡slednom analyzovanÃ­ sa etapa rozdelÃ­ na menÅ¡ie Äasti â moduly, ktorÃ© sa prideÄ¾ujÃº tÃ­mom. Rozsah modulu predpokladÃ¡ pribliÅ¾ne dva tÃ½Å¾dne prÃ¡ce pre jednÃ©ho Äloveka. Na rozsahu modulu je realizovanÃ½ mikro-manaÅ¾ment projektu."
76,135,0.349,PRAVDEPODOBNOSÅ¤ A MATEMATICKÃ Å TATISTIKA,"2.3.4 PoznÃ¡mka. DÃ¡ sa dokÃ¡zaÅ¥, Å¾e kaÅ¾dÃº funkciu G: R ï® â© âª, ktorÃ¡ mÃ¡ vlastnosti 1, 2, 3 z vety 2.3.3, mÃ´Å¾eme povaÅ¾ovaÅ¥ za distribuÄnÃº funkciu nejakej nÃ¡hodnej veliÄiny. MoÅ¾no totiÅ¾ zostrojiÅ¥ (ï, S, P) a definovaÅ¥ na Åom tak, aby funkcia G bola distribuÄnou funkciou veliÄiny . Ak teda zadanie Ãºlohy zaÄÃ­na slovami ânech je distribuÄnou funkciouâ (veliÄiny ), staÄÃ­ overiÅ¥, Å¾e mÃ¡ vlastnosti 1, 2, 3 a akceptujeme, Å¾e takÃ¡ nÃ¡hodnÃ¡ veliÄina (ktorej je distribuÄnÃ¡ funkcia) naozaj existuje (aj keÄ ju nemÃ¡me zadanÃº). 2.3.5 Veta. Nech je diskrÃ©tna veliÄina s pravdepodobnostnou funkciou mnoÅ¾inou ( ) = { â¦ }. Potom pre jej distribuÄnÃº funkciu platÃ­ ( ) pre vÅ¡etky xïR. Ak"
369,307,0.349,AplikaÄnÃ© architektÃºry softvÃ©rovÃ½ch systÃ©mov,"PoistnÃ¡ zmluva obsahuje jeden alebo viac predmetov poistenia, priÄom kaÅ¾dÃ½ predmet poistenia sa tÃ½ka jednÃ©ho poistnÃ©ho objektu. Ak naprÃ­klad fyzickÃ¡ osoba uzatvÃ¡ra zÃ¡konnÃ© poistenie motorovÃ©ho vozidla, poistnÃ¡ zmluva mÃ¡ iba jeden predmet poistenia. Dva alebo niekoÄ¾ko predmetov poistenia mÃ¡ poistnÃ¡ zmluva naprÃ­klad pri Å¾ivotnom poistenÃ­ manÅ¾elov alebo rodiÄa s dieÅ¥aÅ¥om. Viac predmetov poistenia vystupuje pri skupinovom poistenÃ­, naprÃ­klad (tzv. flotily) motorovÃ½ch vozidiel firmy alebo pri Ãºrazovom poistenÃ­ pracovnÃ­kov firmy. KeÄÅ¾e jeden poistnÃ½ objekt mÃ´Å¾e byÅ¥ pouÅ¾itÃ½ vo viacerÃ½ch poistnÃ½ch zmluvÃ¡ch (naprÃ­klad ten istÃ½ automobil v zmluve o povinnom zmluvnom poistenÃ­ aj v zmluve o havarijnom poistenÃ­), Äasto sa odÄleÅuje od samotnÃ©ho predmetu poistenia. Pre poistnÃ© objekty sa, v zÃ¡vislosti od ich typov, evidujÃº tieÅ¾ rÃ´zne popisnÃ© atribÃºty. Pre motorovÃ© vozidlo sa naprÃ­klad evidujÃº Ãºdaje podÄ¾a osvedÄenia o evidencii (technickÃ©ho preukazu): druh vozidla, znaÄka a typ vozidla, Å¡tÃ¡tna poznÃ¡vacia znaÄka, vÃ½robnÃ© ÄÃ­slo karosÃ©rie, vÃ½robnÃ© ÄÃ­slo motora, rok vÃ½roby, farba, objem valcov, vÃ½kon motora a ÄalÅ¡ie. UvedenÃ© atribÃºty slÃºÅ¾ia nielen na identifikÃ¡ciu poistnÃ©ho objektu, ale niekedy tieÅ¾ na vÃ½poÄet poistnÃ©ho (poistnÃ© mÃ´Å¾e naprÃ­klad zÃ¡visieÅ¥ od typu vozidla, objemu valcov, prÃ­padne inÃ½ch atribÃºtov) a Å¡tatistiky a poistnÃº matematiku, ktorÃ¡ tak mÃ´Å¾e presnejÅ¡ie urÄovaÅ¥ sadzby poistnÃ©ho (vozidlÃ¡ urÄitÃ½ch typov sa naprÃ­klad kradnÃº viac ako vozidlÃ¡ inÃ½ch typov a majÃº preto vyÅ¡Å¡ie sadzby poistnÃ©ho). Predmet poistenia zÃ¡roveÅ spÃ¡ja poistnÃ½ objekt s poistnÃ½mi rizikami, ktorÃ© sÃº dohodnutÃ© pre tento poistnÃ½ objekt. PoistnÃ½ objekt mÃ´Å¾e byÅ¥ na jednej zmluve poistenÃ½ voÄi viacerÃ½m poistnÃ½m rizikÃ¡m, naprÃ­klad motorovÃ© vozidlo voÄi Å¾ivlu, odcudzeniu a krÃ¡deÅ¾i. JednotlivÃ© poistnÃ© rizikÃ¡ mÃ´Å¾u maÅ¥ svoje Å¡pecifickÃ© poistnÃ© sumy, poistnÃ© a zÄ¾avy. Pri havarijnom poistenÃ­ motorovÃ©ho vozidla je naprÃ­klad havÃ¡ria pravdepodobnejÅ¡ia ako poÅ¡kodenie vozidla Å¾ivelnou udalosÅ¥ou, preto mÃ¡va poistnÃ© riziko havÃ¡rie vyÅ¡Å¡ie poistnÃ©. TaktieÅ¾ bonus/malus sa Å¡tandardne poskytuje na poistnÃ© riziko havÃ¡rie a nie na poistnÃ© riziko krÃ¡deÅ¾e motorovÃ©ho vozidla. Pri poistenÃ­ zodpovednosti za Å¡kodu mÃ´Å¾u byÅ¥ jednotlivÃ½mi poistnÃ½mi rizikami: Å¡koda na zdravÃ­, Å¡koda na veciach a uÅ¡lÃ½ zisk. KaÅ¾dÃ© z tÃ½chto poistnÃ½ch rizÃ­k mÃ´Å¾e maÅ¥ inÃº poistnÃº sumu. Podobne mÃ´Å¾e byÅ¥ pri Ãºrazovom poistenÃ­ dohodnutÃ½ch viacero poistnÃ½ch rizÃ­k: Ãºmrtie nÃ¡sledkom Ãºrazu, trvalÃ© nÃ¡sledky poÅ¡kodenia zdravia, dennÃ© odÅ¡kodnenie po dobu nevyhnutnÃ©ho lieÄenia. KaÅ¾dÃ© z tÃ½chto poistnÃ½ch rizÃ­k mÃ¡ inÃº poistnÃº sumu. Pri viacerÃ½ch poistnÃ½ch rizikÃ¡ch na jeden poistnÃ½ objekt, predovÅ¡etkÃ½m pri Å¾ivotnom poistenÃ­, sa zvyÄajne jedno poistnÃ© riziko povaÅ¾uje za hlavnÃ© riziko a na jeho zÃ¡klade sa odvÃ¡dzajÃº hlavnÃ© parametre zmluvy: poistnÃ¡ suma, minimÃ¡lna dÄºÅ¾ka poistnÃ©ho obdobia a poistnÃ©. Pri Å¾ivotnom poistenÃ­ je takÃ½mto poistnÃ½m rizikom poistenie na doÅ¾itie7, poistenie na Ãºmrtie alebo ich kombinÃ¡cia. HlavnÃ© poistnÃ© riziko je povinnÃ© a nie je moÅ¾nÃ© ho zruÅ¡iÅ¥. Zmena parametrov hlavnÃ©ho poistnÃ©ho je spravidla moÅ¾nÃ¡, vyÅ¾aduje vÅ¡ak prepoÄÃ­tanie ostatnÃ½ch parametrov zmluvy (najmÃ¤ poistnÃ©ho) a mÃ´Å¾e dokonca viesÅ¥ k vytvoreniu novej verzie zmluvy (nahradeniu starej poistnej zmluvy novou zmluvou). PoistnÃ© riziko, ktorÃ© nie je hlavnÃ½m rizikom, moÅ¾no zvyÄajne v priebehu existencie poistnej zmluvy pri-"
190,48,0.348,O softvÃ©ri od A po Z ; Ãvahy nastupujÃºcich profesionÃ¡lov,"Tento problÃ©m je v kontexte outsourcingu eÅ¡te zloÅ¾itejÅ¡Ã­ ako v prÃ­pade vlastnÃ½ch zamestnancov. OdpadÃ¡ totiÅ¾ jeden z najvÃ¤ÄÅ¡Ã­ch motivaÄnÃ½ch faktorov, ktorÃ½ mÃ´Å¾e firma uplatniÅ¥, aby motivovala svojich zamestnancov. Iba veÄ¾mi nepriamo totiÅ¾ moÅ¾no ovplyvniÅ¥ finanÄnÃ© odmeÅovanie outsourcovanÃ½ch Ä¾udÃ­. Rozhodli sme sa teda vniesÅ¥ do projektu nielen outsourcovanÃ½ch pracovnÃ­kov, ale aj ich materskÃº firmu s tÃ½m, Å¾e boli vytvorenÃ© zmluvy, ktoMotivovaÅ¥ rÃ½ch sÃºÄasÅ¥ou boli platby za produkty a nie za Äas strÃ¡venÃ½ na ich vytvÃ¡ranÃ­. outsourcovanÃ½ch DodÃ¡vateÄ¾skÃ¡ firma teda zodpovedala za dodanie produktu v dohodnutom pracovnÃ­kov je termÃ­ne a nie za prenÃ¡jom Ä¾udÃ­ pre projekt. ZÃ¡roveÅ sme chceli zvÃ½Å¡iÅ¥ zodpovednosÅ¥ aj tÃ½m, Å¾e sme sa od zaÄiatku veÄ¾mi nÃ¡roÄnÃ©. snaÅ¾ili vytvoriÅ¥ atmosfÃ©ru jednÃ©ho veÄ¾kÃ©ho tÃ­mu a nie nejakÃ©ho dodÃ¡vateÄ¾/odberateÄ¾ vzÅ¥ahu. ZatiaÄ¾ ale nemÃ´Å¾em zhodnotiÅ¥ vÃ½sledky postupov, ktorÃ© sme zvolili, pretoÅ¾e projekt je eÅ¡te Äaleko od svojho konca. PoÄiatoÄnÃ¡ fÃ¡za nÃ¡behu vÅ¡ak prebehla veÄ¾mi dobre a myslÃ­m, Å¾e mÃ¡ Å¡ancu na ÃºspeÅ¡nÃ½ koniec."
135,51,0.347,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 4,"za nÃ¡sledok vyÅ¡Å¡ie pamÃ¤ovÃ© nÃ¡roky v prÃ­pade pouÅ¾Ã­vania vzoru abstraktnej tovÃ¡rne. RieÅ¡enie tohto problÃ©mu dÃ¡va nÃ¡vrhovÃ½ vzor Prototyp. Vzor Prototyp ako alternatÃ­va k Abstraktnej tovÃ¡rni AbstraktnÃ¡ tovÃ¡re je vemi podobnÃ¡ vzoru Prototyp. Prototyp je vzor, kde sa novÃ© objekty vytvÃ¡rajÃº kopÃ­rovanÃ­m prototypovÃ©ho objektu. MÃ´Å¾eme poveda, Å¾e prototyp sa dÃ¡ pouÅ¾i vÅ¡ade, kde moÅ¾no pouÅ¾i abstraktnÃº tovÃ¡re. Vzor Prototyp poskytuje vÃ¤Å¡iu flexibilitu za cenu niÅ¾Å¡ieho vÃ½konu. Prototyp mÃ¡ vÅ¡ak niÅ¾Å¡ie pamÃ¤ovÃ© nÃ¡roky, vytvÃ¡ra totiÅ¾ menej abstraktnÃ½ch tried ako abstraktnÃ¡ tovÃ¡re."
195,201,0.346,OdporÃºÄanie pre softvÃ©rovÃ½ch inÅ¾inierov,"11.4 ExistujÃºce rieÅ¡enia Spomedzi mnohÃ½ch rieÅ¡enÃ­ pre odporÃºÄanie systematickÃ½ch zmien uvedieme prÃ­klad pouÅ¾itia systÃ©mu Sydit [6], ktorÃ½ identifikuje abstraktnÃ½ vzor transformÃ¡cie z prÃ­kladu zadanÃ©ho programÃ¡torom s uvaÅ¾ovanÃ­m jeho kontextu. V Ãºvode kapitoly sme uviedli prÃ­klad zmeny metÃ³dy getLaunchConfigurations (ukÃ¡Å¾ky 11.2 a 11.3). Sydit reprezentuje zdrojovÃ½ kÃ³d metÃ³dy pomocou abstraktnÃ©ho syntaktickÃ©ho stromu, zvlÃ¡Å¡Å¥ pre pÃ´vodnÃº verziu a zvlÃ¡Å¡Å¥ pre upravenÃº. KoreÅom abstraktnÃ©ho syntaktickÃ©ho stromu metÃ³dy je predpis metÃ³dy, postupnÃ© riadky metÃ³dy sa nachÃ¡dzajÃº v potomkoch koreÅa. PodobnÃ½m spÃ´sobom sa potom rozvetvujÃº cykly a podmienky. Sydit porovnÃ¡ stromy a identifikuje medzi nimi rozdiel Îð´ = [ð1 , ð2 , â¦ , ðð ] ako postupnosÅ¥ Ãºprav e syntaktickÃ©ho stromu â operÃ¡cie vloÅ¾enie vrcholu, zmazanie, upravenie alebo presunutie. IdentifikovanÃº transformÃ¡ciu Îð´ nÃ¡sledne Sydit zovÅ¡eobecnÃ­ nahradenÃ­m nÃ¡zvov premennÃ½ch, typov a metÃ³dy vÅ¡eobecnÃ½mi identifikÃ¡tormi, napr. $M1$, $M2$, $V1$, $T1$, $T2$. Tak dokÃ¡Å¾eme transformÃ¡ciu pouÅ¾iÅ¥ aj v inÃ½ch sÃºÄiastkach zdrojovÃ©ho kÃ³du. Na obrÃ¡zku 15 uvÃ¡dzame prÃ­klad identifikovanej transformÃ¡cie vo vÅ¡eobecnom tvare s operÃ¡ciami presunutia, upravenia a vloÅ¾enia. PouÅ¾itie transformÃ¡cie nÃ¡sledne tkvie z automatickej identifikÃ¡cie miest v zdrojovom kÃ³de, ktorÃ© zodpovedajÃº abstraktnÃ©mu syntaktickÃ©mu stromu Ãºpravy a jej aplikÃ¡cie. VÅ¡eobecnÃ© symboly sa zamenia podÄ¾a identifikovanÃ©ho miesta, napr. $T2$ $v2$ = null na ILaunchConfiguration cfg = null."
240,235,0.345,PROGRAMOVANIE V JAZYKU C V RIEÅ ENÃCH PRÃKLADOCH 1,"RekurzÃ­vne vnorenie prebieha len v prÃ­pade ak x nie je jednocifernÃ© binÃ¡rne ÄÃ­slo (x > 1). Potom ako vypÃ­Å¡e binÃ¡rnu reprezentÃ¡ciu vyÅ¡Å¡Ã­ch rÃ¡dov (x/2) dopÃ­Å¡e aj poslednÃº cifru (x%2) binÃ¡rneho zÃ¡pisu x. VÅ¡imnime si, Å¾e toto rekurzÃ­vne rieÅ¡enie nemÃ¡ obmedzenie na vstupnÃ© ÄÃ­slo x do 1 000 000. Je to spÃ´sobenÃ© tÃ½m, Å¾e zÃ¡sobnÃ­k volanÃ­ funguje ako akÃ¡si pamÃ¤Å¥ poslednej cifry (x%2) predtÃ½m ako ju vypÃ­Å¡eme (pretoÅ¾e rekurzÃ­vne vnorenie (x/2) prebieha tesne pred vÃ½pisom printf()). Z formÃ¡lneho hÄ¾adiska teda rekurzÃ­vne rieÅ¡enie vyÅ¾aduje viac pomocnej pamÃ¤te, ÄÃ­m vÅ¡ak zÃ­skame vÅ¡eobecnejÅ¡ie rieÅ¡enie, ktorÃ©ho kÃ³d je jednoduchÅ¡Ã­ a prehÄ¾adnejÅ¡Ã­."
76,117,0.345,PRAVDEPODOBNOSÅ¤ A MATEMATICKÃ Å TATISTIKA,"RieÅ¡enie. PretoÅ¾e mÃ¡ platiÅ¥ ( ) ï³ 0 pre vÅ¡etky ïR, musÃ­ byÅ¥ ï³ 0. Zrejme prÃ­pad = 0 vylÃºÄime, veÄ identicky nulovÃ¡ funkcia nemÃ´Å¾e byÅ¥ pravdepodobnostnou funkciou. Preto nutne > 0. ÄalÅ¡ie ohraniÄenie pre zÃ­skame z podmienky, Å¾e sÃºÄet vÅ¡etkÃ½ch hodnÃ´t ( ) sa musÃ­ rovnaÅ¥ 1. PretoÅ¾e"
59,293,0.344,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"ProblÃ©my ProblÃ©m 5.1. Ako je definovanÃ© podÄ¾a americkÃ©ho psycholÃ³ga Thorndike uÄenie s odmenou a trestom? ProblÃ©m 5.2. Ako sa pouÅ¾Ã­vajÃº neurÃ³novÃ© siete ako prostriedok pre rozhodovanie v hre? ProblÃ©m 5.3. AkÃ½ je klasickÃ½ prÃ­stup k uÄeniu neurÃ³novej siete, aby vedela vyhodnocovaÅ¥ prechod z jednÃ©ho stavu do druhÃ©ho stavu pri konÅ¡trukcii stromu rieÅ¡enia? ProblÃ©m 5.4. Å pecifikujte adaptÃ¡ciu neurÃ³novej siete pomocou metÃ³dy odmeny a trestu vo verzii âtemporal difference TD(ï¬)â. ProblÃ©m 5.5. (NÃ¡met pre esej) Pre danÃ© jednoduchÃ© bludisko obsahujÃºce 10 aÅ¾ 20 uzlov, ktorÃ© sÃº oznaÄenÃ© symbolmi zostrojte pomocou uÄenia s odmenou a trestom takÃº doprednÃº neurÃ³novÃº sieÅ¥, ktorÃ¡ je schopnÃ¡ efektÃ­vne riadiÅ¥ agenta pri pohybe bludiskom. ProblÃ©m 5.6. (NÃ¡met pre zloÅ¾itejÅ¡iu esej) Proces emergencie stratÃ©giu hry piÅ¡kvorky Å¡tudujte pre populÃ¡ciu agentov s kognitÃ­vnym orgÃ¡nom (implementovanÃ½m pomocou doprednej neurÃ³novej siete) tak, Å¾e v populÃ¡cii agentov prebieha neustÃ¡ly turnaj pre nÃ¡hodne vybranÃº dvojicu agentov A1 a A2, po skonÄenÃ­ danej hry agenti A1 a A2 si adaptujÃº pomocou TD(ï¬) metÃ³dy svoje neurÃ³novÃ© siete, priÄom vÃ­Å¥az nahradÃ­ v populÃ¡cii porazenÃ©ho agenta; ak agenti remizovali, potom oba agenti v populÃ¡cii zostÃ¡vajÃº. NÃ¡rast efektÃ­vnosti hry agentov sledujte tak, Å¾e v kaÅ¾dom n-tom kroku (nech n = 100) poslednÃ½ vÃ­Å¥az hrÃ¡ 10 hier proti agentovi riadenom formÃ¡lnymi pravidlami."
94,45,0.344,Sprievodca svetom vedeckÃ©ho publikovania,"1.4.11 VedeckÃ¡ komunikÃ¡cia v Äase internetu PrÃ­chod poÄÃ­taÄov a moÅ¾nosÅ¥ internetovÃ©ho pripojenia mnohÃ­ vÃ­tali ako spÃ¡su akademickÃ©ho publikovania. Priestor na policiach aj tÃ½ch najÅ¡tedrejÅ¡ie dotovanÃ½ch kniÅ¾nÃ­c mal svoje hranice a bolo Äoraz Å¥aÅ¾Å¡ie do nich vtesnaÅ¥ vÅ¡etky vÃ½sledky vÃ½skumu, ktorÃ© vedcov zaujÃ­mali. ElektronickÃ© publikovanie sa javilo ako praktickÃ© rieÅ¡enie problÃ©mu. V porovnanÃ­ s papierovou cestou malo aj vÃ½hodu rÃ½chlosti, eliminovali sa problÃ©my s tlaÄou a veÄ¾kÃ¡ ÄasÅ¥ poÅ¡tovÃ½ch nÃ¡kladov. ZaÄali vznikaÅ¥ prvÃ© vedeckÃ© listservy (sluÅ¾ba zasielania tematickÃ½ch emailov urÄenej skupine zÃ¡ujemcov), newslettery (elektronickÃ© informaÄnÃ© bulletiny) a vÃ½luÄne elektronickÃ© Äasopisy, napr. Flora Online (1987 â 1993, zasielala sa poÅ¡tou na disketÃ¡ch, archÃ­v je prÃ­stupnÃ½ na internete13), Äi Postmodern Culture (1990-). NiektorÃ­ akademici tuÅ¡ili potenciÃ¡l elektronickej formy, ale nepovaÅ¾ovali ju za rovnocennÃº tlaÄenÃ©mu ÄlÃ¡nku. Mali obavy z jej nestÃ¡losti, nespoÄ¾ahlivosti, pominuteÄ¾nosti a nedostatku ochrany autorskÃ½ch prÃ¡v. PraktickÃ© vÃ½hody elektronickej vedeckej komunikÃ¡cie vÅ¡ak prevÃ¡Å¾ili. NajrÃ½chlejÅ¡ie sa ujala vo vednÃ½ch disciplÃ­nach, ktorÃ© mali k poÄÃ­taÄom principiÃ¡lne blÃ­zko a zÃ¡roveÅ sa rÃ½chlo rozvÃ­jali, takÅ¾e Å¥aÅ¾kopÃ¡dne recenznÃ© konanie v nich predstavovalo naliehavejÅ¡Ã­ problÃ©m ako v inÃ½ch (napr. humanitnÃ½ch) odboroch s pomalÅ¡Ã­m tempom. V roku 1991 zaloÅ¾il fyzik Paul Ginsparg z Los Alamos National Laboratory repozitÃ¡r arXiv14, ÃºloÅ¾isko elektronickÃ½ch preprintovÃ½ch verziÃ­ vedeckÃ½ch ÄlÃ¡nkov z oblasti fyziky (neskÃ´r aj matematiky, astronÃ³mie, informatiky a kvantitatÃ­vnej biolÃ³gie) vo formÃ¡te TeX. Tento formÃ¡t si vÄaka Ãºspornosti a vynikajÃºcej matematickej sadzbe zÃ­skal obÄ¾ubu medzi vÅ¡etkÃ½mi vedcami, ktorÃ­ potrebovali pri pÃ­sanÃ­ publikÃ¡ciÃ­ pouÅ¾Ã­vaÅ¥ vzorce. ArXiv sa stal Å¡tandardom vo svojej oblasti a poslÃºÅ¾il ako prÃ­klad pre ÄalÅ¡ie vednÃ© disciplÃ­ny. Tam, kde vizionÃ¡ri videli ÃºÅ¾asnÃ© novÃ© moÅ¾nosti, komerÄnÃ­ vydavatelia vytuÅ¡ili ohrozenie zdroja prÃ­jmov. Preto znaÄnÃº ÄasÅ¥ z financiÃ­, ktorÃ© zÃ­skali za predplatnÃ© od univerzÃ­t, investovali do âochrany obsahuâ (teda jeho spoplatnenia a zneprÃ­stupnenia pre tÃ½ch, ktorÃ­ nezaplatili). Kontrast moÅ¾nostÃ­ elektronickÃ©ho sveta oproti bariÃ©ram komerÄnÃ©ho publikovania provokoval vedcov uÅ¾ v prvÃ½ch rokoch rozvoja svetovej siete. V roku 1994 kognitÃ­vny vedec Stevan Harnad predloÅ¾il vedeckej verejnosti na internete âpodvratnÃ½"
184,315,0.344,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 3,"na adresÃ¡r odstrÃ¡nenÃ½ len v prÃ­pade, ak je adresÃ¡r, na ktorÃ½ danÃ½ odkaz odkazuje prÃ¡zdny. V prÃ­pade grafovej reprezentÃ¡cie je povolenÃ© zruÅ¡iÅ¥ odkaz na adresÃ¡r v prÃ­pade, Å¾e existuje aspoÅ jeden inÃ½ odkaz tento na adresÃ¡r. ZavedenÃ­m referenÄnÃ©ho ÄÃ­sla znÃ¡zornenÃ©ho v pravom hornom rohu kaÅ¾dÃ©ho adresÃ¡ra â obrÃ¡zok 4-3 je jednoduchÃ© urÄiÅ¥ kedy je odstraÅovanÃ½ odkaz na adresÃ¡r poslednÃ½. Po tom, ako sa zruÅ¡Ã­ odkaz z A do B je referenÄnÃ© ÄÃ­slo B znÃ­Å¾enÃ© z 2 na 1, Äo vyzerÃ¡ ako jednoduchÃ© rieÅ¡enie problÃ©mu, avÅ¡ak adresÃ¡r B by bol v tomto prÃ­pade neprÃ­stupnÃ½ z koreÅovÃ©ho adresÃ¡ra sÃºborovÃ©ho systÃ©mu (A). Tri adresÃ¡re, B, D a E a vÅ¡etky sÃºbory v nich by sa stratili. Tento problÃ©m existuje aj v centralizovanÃ½ch systÃ©moch, je vÅ¡ak kritickejÅ¡Ã­ v distribuovanÃ½ch. PokiaÄ¾ je vÅ¡etko na jednom poÄÃ­taÄi, je moÅ¾nÃ©, aj keÄ potenciÃ¡lne zloÅ¾ito, objaviÅ¥ stratenÃ© adresÃ¡re, pretoÅ¾e sÃº vÅ¡etky informÃ¡cie o nich uloÅ¾enÃ© na jednom mieste. Aktivita vÅ¡etkÃ½ch sÃºborov mÃ´Å¾e byÅ¥ v takÃ½chto systÃ©moch zastavenÃ¡ a graf mÃ´Å¾e byÅ¥ obnovenÃ½ poÄnÃºc koreÅovÃ½m adresÃ¡rom oznaÄenÃ­m vÅ¡etkÃ½ch dostupnÃ½ch adresÃ¡rov. Na konci tohto procesu sa vÅ¡etky neoznaÄenÃ© adresÃ¡re povaÅ¾ujÃº za nedostupnÃ©. V distribuovanÃ½ch systÃ©moch, kde je spojenÃ½ch viacero poÄÃ­taÄov nie je moÅ¾nÃ© zastaviÅ¥ vÅ¡etku aktivitu sÃºborovÃ©ho systÃ©mu, Äim je zÃ­skanie âsnÃ­mky (snapshot)â sÃºborovÃ©ho systÃ©mu veÄ¾mi zloÅ¾itÃ©, ak nie nemoÅ¾nÃ©. KÄ¾ÃºÄovÃ½m problÃ©mom nÃ¡vrhu kaÅ¾dÃ©ho distribuovanÃ©ho sÃºborovÃ©ho systÃ©mu je, Äi vÅ¡etky poÄÃ­taÄe a procesy majÃº identickÃ½ pohÄ¾ad na adresÃ¡rovÃº hierarchiu. Ako prÃ­klad na pochopenie tohto nÃ¡vrhovÃ©ho rozhodnutia poslÃºÅ¾i obrÃ¡zok 4-7. Na obrÃ¡zku 4-7a sÃº znÃ¡zornenÃ© dva sÃºborovÃ© servery. KaÅ¾dÃ½ z nich obsahuje tri adresÃ¡re a niekoÄ¾ko sÃºborov. Na obrÃ¡zku 4-7b je znÃ¡zornenÃ½ systÃ©m v ktorom mÃ¡ kaÅ¾dÃ½ klient rovnakÃ½ pohÄ¾ad na distribuovanÃ½ sÃºborovÃ½ systÃ©m. PokiaÄ¾ cesta /D/E/x je platnÃ¡ na jednom poÄÃ­taÄi, je automaticky platnÃ¡ na vÅ¡etkÃ½ch ostatnÃ½ch poÄÃ­taÄoch. Na rozdiel od tohto pohÄ¾adu, je na obrÃ¡zku 4-7c znÃ¡zornenÃ¡ moÅ¾nosÅ¥, keÄ mÃ¡ kaÅ¾dÃ½ poÄÃ­taÄ v systÃ©me rÃ´zny pohÄ¾ad na distribuovanÃ½ sÃºborovÃ½ systÃ©m. V porovnanÃ­ s predchÃ¡dzajÃºcim prÃ­kladom mÃ´Å¾e byÅ¥ cesta /D/E/x platnÃ¡ na jednom poÄÃ­taÄi, ale nemusÃ­ byÅ¥ platnÃ¡ na ostatnÃ½ch. V systÃ©moch, ktorÃ© spravujÃº viacero sÃºborovÃ½ch serverov pomocou vzdialenÃ©ho pripÃ¡jania je beÅ¾nÃ¡ prÃ¡ve situÃ¡cia znÃ¡zornenÃ¡ na obrÃ¡zku 4-7c. Tento variant je sÃ­ce flexibilne a priamoÄiaro implementovateÄ¾nÃ½, mÃ¡ vÅ¡ak nevÃ½hody, ktorÃ© zamedzujÃº celÃ©mu systÃ©mu aby sa sprÃ¡val sa ako obyÄajnÃ½ â staromÃ³dny systÃ©m zdieÄ¾ania Äasu. V systÃ©moch zdieÄ¾ania Äasu je pohÄ¾ad na sÃºborovÃ½ systÃ©m pre vÅ¡etky procesy rovnakÃ½ (ako na obrÃ¡zku 4-7b). TÃ¡to vlastnosÅ¥ uÄ¾ahÄuje jednoduchÅ¡ie pochopenie systÃ©mu a tieÅ¾ jeho jednoduchÃ© programovanie. Transparencia mien V systÃ©me zloÅ¾enom z viacerÃ½ch sÃºborovÃ½ch serverov, kde je kaÅ¾dÃ½ z nich samostatnÃ½ (neobsahuje Å¾iadne referencie na adresÃ¡re alebo sÃºbory na inÃ½ch sÃºborovÃ½ch serveroch) mÃ´Å¾me pouÅ¾iÅ¥ ako binÃ¡rne meno sÃºboru ÄÃ­slo lokÃ¡lneho i-uzla, ako je tomu naprÃ­klad aj v systÃ©moch UNIX. Viac vÅ¡eobecnÃ¡ schÃ©ma pomenovania sa dosiahne v prÃ­pade, ak bude binÃ¡rne meno udÃ¡vaÅ¥ tak meno servera ako aj Å¡pecifickÃ½ sÃºbor na tomto serveri. AlternatÃ­vnym spÃ´sobom na dosiahnutie rovnakÃ©ho cieÄ¾a mÃ´Å¾e byÅ¥ pouÅ¾itie symbolickÃ½ch odkazov. SymbolickÃ½ odkaz je poloÅ¾ka adresÃ¡ra ktorÃ¡ sa mapuje na reÅ¥azec (server, meno sÃºboru), ktorÃ½ mÃ´Å¾e byÅ¥ pouÅ¾itÃ½ na vyhÄ¾adanie binÃ¡rneho mena na serveri. SymbolickÃ© meno predstavuje samo o sebe cestu k sÃºboru."
111,53,0.341,ZÃ¡kladnÃ© metÃ³dy na zlepÅ¡enie pouÅ¾itelânosti webov,"AnalÃ½za uzavretÃ½ch triedenÃ­ kariet UzavretosÅ¥ uzavretÃ©ho triedenia kariet vyplÃ½va zo skutoÄnosti, Å¾e vÅ¡etky kategÃ³rie sÃº urÄenÃ© vopred. NiektorÃ© z otÃ¡zok, ktorÃ© si moÅ¾no poloÅ¾iÅ¥ na zÃ¡klade uzavretÃ©ho triedenia kariet: â¢ Do ktorÃ½ch kategÃ³riÃ­ boli jednotlivÃ© karty zaradenÃ© najviac?"
190,154,0.338,O softvÃ©ri od A po Z ; Ãvahy nastupujÃºcich profesionÃ¡lov,"V princÃ­pe mÃ´Å¾eme povedaÅ¥, Å¾e ak sme sa rozhodli riadiÅ¥ projekt plÃ¡nom, mali by sme sa toho drÅ¾aÅ¥ poÄas celÃ©ho obdobia rieÅ¡enia projektu, a teda by sme vytvorenÃ½ plÃ¡n mali nÃ¡leÅ¾ite udrÅ¾iavaÅ¥. Istotne si mnohÃ­ povedia, Å¾e udrÅ¾iavanie plÃ¡nu je Äasovo nÃ¡roÄnÃ©, ale ak sa nad problÃ©mom zamyslÃ­me hlbÅ¡ie, zistÃ­me, Å¾e plÃ¡n projektu vonkoncom nie je vec statickÃ¡, a teda sa postupom Äasu mÃ´Å¾e meniÅ¥. Z toho logicky vyplÃ½va, Å¾e sa poÄas celÃ©ho obdobia rieÅ¡enia projektu nemÃ´Å¾eme spoliehaÅ¥ na plÃ¡n, ktorÃ½ sme vytvorili na zaÄiatku projektu a nÃ¡sledne ho neudrÅ¾iavali. TakÃ½to plÃ¡n, aj keÄ bol v momente vzniku priam dokonalÃ½, strÃ¡ca hodnotu a vÃ½znam. Z dokonalÃ©ho plÃ¡nu sa stÃ¡va iba legenda o dokonalom plÃ¡ne."
195,157,0.338,OdporÃºÄanie pre softvÃ©rovÃ½ch inÅ¾inierov,"8.4 Zhrnutie V tejto prÃ¡ci sme sa venovali oblastnÃ½m Å¡tÃºdiÃ¡m v kontexte odporÃºÄacÃ­ch systÃ©mov v softvÃ©rovom inÅ¾inierstve. NaÅ¡Ã­m cieÄ¾om bolo ukÃ¡zaÅ¥, ako viesÅ¥ krok za krokom oblastnÃº Å¡tÃºdiu na vytvorenie odporÃºÄacÃ­ch systÃ©mov. Na zaÄiatku sme predstavili akÃ© metÃ³dy, metodolÃ³gie a epistemolÃ³gie sa vyuÅ¾Ã­vajÃº na vÃ½skum vÅ¡eobecne. Tento prehÄ¾ad a poznatky by nÃ¡m mali daÅ¥ urÄitÃº perspektÃ­vu a konzistenciu v oblastnej Å¡tÃºdii. Äalej sme opÃ­sali, akÃ© kroky zahÅÅajÃº vedenie oblastnej Å¡tÃºdie. Nakoniec sme zvÃ½raznili vÃ½zvy tohto procesu. OblastnÃ© Å¡tÃºdie sÃº jedinÃ½m spÃ´sobom, ako vÃ½skumnÃ­ci mÃ´Å¾u pochopiÅ¥ oblasti svojho zÃ¡ujmu a navrhnÃºÅ¥ technickÃ© rieÅ¡enia pre reÃ¡lne potreby praktikantov. Bolo zistenÃ©, Å¾e technickÃ© vÃ½zvy sa Ä¾ahko prekonÃ¡vajÃº, za to sociÃ¡lne, organizaÄnÃ© a poznÃ¡vacie vÃ½zvy sÃº tie, ktorÃ© robia prijatie a pouÅ¾itie odporÃºÄacie systÃ©mu Å¥aÅ¾Å¡Ã­m. Preto je potrebnÃ© viesÅ¥ viac oblastnÃ½ch Å¡tÃºdiÃ­ na prekonÃ¡vanie tÃ½chto problÃ©mov a navrhnÃºÅ¥ ich rieÅ¡enia. KombinÃ¡cia softvÃ©rovÃ©ho inÅ¾inierstva, strojovÃ©ho uÄenia a dolovania dÃ¡t vie pomÃ´cÅ¥ prÃ­stupu k veÄ¾kÃ½m dÃ¡tam a hÄºbkovej analÃ½ze. Preto by odporÃºÄacie systÃ©my nemali byÅ¥ vytvorenÃ© obmedzenÃ½m poÄtom offline experimentov. Potrebujeme pochopiÅ¥ zÃ¡kladnÃ© pojmy a skÃºmaÅ¥ ich s dostupnÃ½mi dÃ¡tami a modelmi. V tomto zmysle sÃº oblastnÃ© Å¡tÃºdie jedinÃ½m spÃ´sobom k prekonaniu limitov a predpokladov."
94,85,0.337,Sprievodca svetom vedeckÃ©ho publikovania,"editor Umberto32 dokonca existuje aj pre slovenskÃ½ jazyk. OceniÅ¥ ho mÃ´Å¾u Å¡tudenti pri pÃ­sanÃ­ zÃ¡vereÄnÃ½ch prÃ¡c, Äi autori uÄebnÃ­c, ktorÃ­ chcÃº aj v odbornom texte udrÅ¾aÅ¥ priamoÄiary, Ä¾ahko pochopiteÄ¾nÃ½ Å¡tÃ½l). PoÄÃ­taÄovÃ½ program prirodzene nenahradÃ­ Å¾ivÃ©ho ÄitateÄ¾a. VeÄ¾kÃº vÃ½hodu znamenÃ¡ kolega (alebo priateÄ¾ z akademickej sociÃ¡lnej siete), ktorÃ½ ovlÃ¡da angliÄtinu ako rodenÃ½ reÄnÃ­k. Ak vedec nikoho takÃ©ho nepoznÃ¡, mÃ´Å¾e sa pokÃºsiÅ¥ nÃ¡jsÅ¥ profesionÃ¡lneho korektora â ideÃ¡lne takÃ©ho, ktorÃ½ rozumie vedeckÃ©mu Å¾argÃ³nu z danÃ©ho odboru. Do oblasti elektronickÃ©ho vedeckÃ©ho publikovania zaÄalo vstupovaÅ¥ takÃ© mnoÅ¾stvo autorov z krajÃ­n mimo anglofÃ³nneho priestoru, Å¾e vytvorili dostatoÄne veÄ¾kÃ½ trh pre vznik segmentu editaÄnÃ½ch sluÅ¾ieb Å¡pecializovanÃ½ch na vedeckÃ© rukopisy33. Tieto sluÅ¾by sÃº spoplatnenÃ©: za gramatickÃº korektÃºru ÄlÃ¡nku v rozsahu do 6000 slov zaplatÃ­ autor 200 â 400 Eur (minimÃ¡lna taxa). Okrem gramatickÃ©ho a Å¡tylistickÃ©ho skultivovania ÄlÃ¡nku ponÃºkajÃº editaÄnÃ© firmy v rÃ¡mci rozÅ¡Ã­renÃ½ch sluÅ¾ieb aj technickÃ© Ãºpravy, vytvorenie reprezentatÃ­vnych obrÃ¡zkov podÄ¾a nÃ¡vrhu autora, kontrolu Å¡tatistickÃ©ho spracovania, pomoc pri vÃ½bere Äasopisu, napÃ­sanie sprievodnÃ©ho listu, alebo pomoc pri komunikÃ¡cii s redakciou. EditaÄnÃ© sluÅ¾by tieÅ¾ podliehajÃº vlastnÃ©mu etickÃ©mu kÃ³dexu. Ich vÃ½pomoc by nemala dosahovaÅ¥ ÃºroveÅ autorskÃ©ho prÃ­nosu, pri Å¡tylistickÃ½ch ÃºpravÃ¡ch by nemali zasahovaÅ¥ do obsahu, Äi neprimerane posÃºvaÅ¥ vyznenie textu. V Å¾iadnom prÃ­pade by sa nemali podieÄ¾aÅ¥ na fabrikÃ¡cii dÃ¡t alebo prekrÃºcanÃ­ vÃ½sledkov. Pri komunikÃ¡cii s redakciami by nemali prepisovaÅ¥ autorskÃ© prÃ¡va k ÄlÃ¡nku na vydavateÄ¾a v mene autorov. Pre slovenskÃ©ho vÃ½skumnÃ­ka s obmedzenÃ½mi zdrojmi na publikovanie sÃº editaÄnÃ© sluÅ¾by zvÃ¤ÄÅ¡a nedostupnÃ©, no na ich strÃ¡nkach sa dajÃº aj bezplatne nÃ¡jsÅ¥ uÅ¾itoÄnÃ© redaktorskÃ© tipy a triky, prÃ­padne varovania pred ÄastÃ½mi chybami."
240,462,0.337,PROGRAMOVANIE V JAZYKU C V RIEÅ ENÃCH PRÃKLADOCH 1,"budÃº uvedenÃ© ako vÃ½stupnÃ© argumenty (aby sme do nich mohli zapisovaÅ¥) ale budeme ich pouÅ¾Ã­vaÅ¥ aj ako vstupnÃ© argumenty (budeme z nich hodnoty aj ÄÃ­taÅ¥). V prÃ­pade, Å¾e by ÄÃ­slo, ktorÃ© do poÄ¾a vkladÃ¡me, malo presiahnuÅ¥ dÄºÅ¾ku poÄ¾a (n+1 > kapacita), tak pole zvÃ¤ÄÅ¡Ã­me funkciou realloc(). V tomto rieÅ¡enÃ­ demonÅ¡trujeme zvÃ¤ÄÅ¡enie poÄ¾a o konÅ¡tantnÃ½ prÃ­rastok (o 10 prvkov) lebo predpokladÃ¡me, Å¾e funkcia sa bude v programe volaÅ¥ len sporadicky. Potom ako funkcia vloz() zaruÄÃ­, Å¾e pole mÃ¡ dostatoÄnÃº kapacitu na pridanie ÄalÅ¡ieho prvku je potrebnÃ© nÃ¡jsÅ¥ umiestnenie novÃ©ho prvku vzhÄ¾adom na usporiadanie prvkov v poli. Ak sprÃ¡vne miesto nÃ¡jdeme, je moÅ¾nÃ©, Å¾e prvky, ktorÃ© sa nachÃ¡dzajÃº za tÃ½mto miestom budeme musieÅ¥ posunÃºÅ¥ na nasledujÃºce miesto v poli, ÄÃ­m vytvorÃ­me miesto pre novÃ½ prvok, do ktorÃ©ho priradÃ­me novÃº hodnotu. PosÃºvanie prvkov o jedno miesto Äalej mÃ´Å¾eme realizovaÅ¥ v cykle sÃºÄasne s hÄ¾adanÃ­m sprÃ¡vneho miesta pre pridÃ¡vanÃ½ prvok tak, Å¾e prvky poÄ¾a budeme prechÃ¡dzaÅ¥ (i) od konca (poslednÃ©ho prvku) smerom na zaÄiatok (prvÃ½ prvok): ak hodnota i-teho prvku je menÅ¡ia ako pridÃ¡vanÃ¡ hodnota (cislo), tak vieme Å¾e potom ako i-tÃ½ prvok presunieme na i+1 miesto (a[i+1] = a[i]), tak na uvoÄ¾nenÃ© i-te miesto vloÅ¾Ã­me hodnotu cislo, inak pokraÄujeme Äalej pre prvok i-1 (ktorÃ½ presunieme na i-te miesto atÄ). VÃ½slednÃ¡ implementÃ¡cia funkcie vloz() podÄ¾a uvedenÃ©ho opisu:"
393,456,0.336,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 2,"PredchÃ¡dzajÃºce Äasti sÃº zameranÃ© na objasnenie vÅ¡eobecnÃ½ch prÃ­stupov a metÃ³d pouÅ¾itia Äi uÅ¾ vzorov alebo konkrÃ©tne nÃ¡vrhovÃ½ch vzorov. V nasledujÃºcich Äastiach sa budeme zaoberaÅ¥ konkrÃ©tne moÅ¾nosÅ¥ami znovupouÅ¾itia ÄastÃ­ nÃ¡vrhovÃ½ch vzorov. Objektovo orientovanÃ© programovanie mÃ¡ ako jeden z cieÄ¾ov umoÅ¾niÅ¥ jednoduchÃ© a z hÄ¾adiska vÃ½voja efektÃ­vne znovupouÅ¾itie ÄastÃ­ systÃ©mov. K naplneniu tohto cieÄ¾a mÃ´Å¾eme v OO programovanÃ­ vyuÅ¾Ã­vaÅ¥ dedenie, polymorfizmus, asociÃ¡cie a ÄalÅ¡ie viac alebo menej elementÃ¡rne prostriedky. NÃ¡vrhovÃ© vzory, ktorÃ½mi sa tu zaoberÃ¡me, sa implicitne spÃ¡jajÃº s objektovo orientovanÃ½m programovanÃ­m, no ich znovupouÅ¾itie je neformÃ¡lne definovanÃ© iba na Ãºrovni postupov, myÅ¡lienok a konceptov rieÅ¡enÃ­."
59,406,0.334,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"ï¨ p ï q ï© ï ï¨ q ï r ï© ï ï ï¨ p ï r ï© , ak sa nÃ¡m podarÃ­ ukÃ¡zaÅ¥, Å¾e prÃ­sluÅ¡nÃ© sÃ©mantickÃ© tablo mÃ¡ vÅ¡etky vetvy uzavretÃ©, potom platÃ­ relÃ¡cia ï» p ï q,q ï rï½ ï¨ p ï r ï© , pozri Obr. 7.3. PrÃ­klad 7.6. Pomocou sÃ©mantickÃ©ho tabla budeme hÄ¾adaÅ¥ zÃ¡ver z teÃ³rie ï ï½ ï» p ï q, p ï rï½ , t. j. budeme rieÅ¡iÅ¥ relÃ¡ciu ï ï½ ï» p ï q, p ï rï½ . VÃ½sledky sÃº znÃ¡zornenÃ© na Obr. 7.4, potom teÃ³ria ï ï½ ï» p ï q, p ï rï½ mÃ¡ Å¡tyri rÃ´zne interpretÃ¡cie â modely, pre ktorÃ© sÃº predpoklady teÃ³rie pravdivÃ© ï´1 ï½ ï¨ p 0 ,q ?, r ?ï©"
40,38,0.333,UmelÃ¡ inteligencia a kognitÃ­vna veda II,"DefinÃ­cia 2. (KontraktÃ­vnosÅ¥). S tÃ½mi istÃ½mi predpokladmi ako v definÃ­cii 1,    neurÃ³novÃ¡ sieÅ¥ (W in ,W ,W back ) je kontraktÃ­vna vzhÄ¾adom na U a D , ak pre vÅ¡etky vstupno/vÃ½stupnÃ© sekvencie (u (n), d (n â 1)) â U Ã D sprava idÃºce do nekoneÄna, kde n = 0,1,2,... existuje (Î´ n ) nâ¥0 , takÃ©, Å¾e pre vÅ¡etky poÄiatoÄnÃ© stavy x (0), x â²(0) a pre vÅ¡etky n â¥ 0 platÃ­, Å¾e x (n) â x â²(n) < Î´ n , kde x (n) (resp. x â²(n) ) je stav neurÃ³novej siete v Äase n. IntuitÃ­vne mÃ´Å¾eme povedaÅ¥, Å¾e Äasom dÃ´jde k takzvanÃ©mu âvymytiuâ vplyvu poÄiatoÄnej inicializÃ¡cie neurÃ³novej siete (obr. 5). SchopnosÅ¥ dosiahnuÅ¥ echo stavy Ãºzko sÃºvisÃ­ s algebraickÃ½mi vlastnosÅ¥ami vÃ¡hovej matice W . Å½iaÄ¾, zatiaÄ¾ nie sÃº znÃ¡me Å¾iadne nutnÃ© a postaÄujÃºce podmienky,    na zÃ¡klade ktorÃ½ch by sa dalo jednoznaÄne rozhodnÃºÅ¥, Äi pri zadanÃ½ch W in ,W ,W back mÃ¡ danÃ¡ neurÃ³novÃ¡ sieÅ¥ schopnosÅ¥ dosiahnuÅ¥ echo stavy alebo nie."
190,419,0.333,O softvÃ©ri od A po Z ; Ãvahy nastupujÃºcich profesionÃ¡lov,"Iba jedna Å¡estina softvÃ©rovÃ½ch projektov sa konÄÃ­ ÃºspeÅ¡ne, teda sa pri splnenej funkcionalite zmestÃ­ do svojho pridelenÃ©ho Äasu a prostriedkov [1]. Äo je vÅ¡ak dÃ´vodom takejto nelichotivej miery neÃºspechu? VÃ½voj softvÃ©ru je pohybom v Å¥aÅ¾ko predvÃ­dateÄ¾nom prostredÃ­. PlÃ¡novanie projektu samo o sebe nezaruÄÃ­ Ãºspech. PlÃ¡n je takpovediac nutnou podmienkou Ãºspechu, pretoÅ¾e poskytuje zÃ¡kladnÃ½ kurz a oporu pre vÃ½vojÃ¡rov. Bez efektÃ­vneho vedenia vÅ¡ak nemÃ¡ Å¡ancu na Ãºspech, pretoÅ¾e ho bude treba zmeniÅ¥ hneÄ v prÃ­pade prvej situÃ¡cie, s ktorou sa nepoÄÃ­talo. Aj pri dobrom plÃ¡ne je manaÅ¾ment poÄas vykonÃ¡vania projektu kritickÃ½. Vznik nepredvÃ­danej situÃ¡cie mÃ´Å¾e maÅ¥ fatÃ¡lne nÃ¡sledky a zÃ¡leÅ¾Ã­ od okamÅ¾itÃ½ch rozhodnutÃ­. PrÃ¡ve tu sÃº ÄastÃ© zlyhania manaÅ¾Ã©rov. VznikajÃº stresovÃ© situÃ¡cie, je Ä¾udskÃ© podliehaÅ¥ panike, ktorÃ¡ plodÃ­ rozhodnutia Äasto eÅ¡te zhorÅ¡ujÃºce stav [3]. DÃ´leÅ¾itÃ½m faktorom je tieÅ¾, ako zavÄasu bol problÃ©m v rÃ¡mci projektu rozpoznanÃ½. VÄasne rozpoznanÃ© problÃ©my mÃ¡vajÃº spravidla menÅ¡Ã­ dopad, pokiaÄ¾ sa rieÅ¡ia eÅ¡te v zÃ¡rodku. ÃspeÅ¡nÃ© sa vyrovnanie sa s neoÄakÃ¡vanÃ½m problÃ©mom si vyÅ¾aduje jeho vÄasnÃº identifikÃ¡ciu a podniknutie sprÃ¡vnych krokov na jeho odstrÃ¡nenie. PrvÃ½ moment zÃ¡leÅ¾Ã­ od kvality monitorovania priebehu projektu, druhÃ½ od metodiky rieÅ¡enia krÃ­z softvÃ©rovej spoloÄnosti (ak existuje). Nedostatky v obidvoch fÃ¡zach majÃº za nÃ¡sledok neÃºspechy. SÃºÄasnÃ© trendy indikujÃº, Å¾e v tejto oblasti sÃº naozaj rezervy. Je nejakÃ¡ moÅ¾nosÅ¥ PlÃ¡n je nutnou podmienkou posunÃºÅ¥ tÃºto problematiku Äalej? Domnievam sa, Å¾e Ã¡no."
76,42,0.331,PRAVDEPODOBNOSÅ¤ A MATEMATICKÃ Å TATISTIKA,"1.3 DiskrÃ©tny pravdepodobnostnÃ½ priestor Z ÄlÃ¡nku 1.1 vieme, Å¾e model nÃ¡hodnÃ©ho pokusu je trojica symbolov: (ï, S, P). ï predstavuje mnoÅ¾inu vÅ¡etkÃ½ch potenciÃ¡lne moÅ¾nÃ½ch vÃ½sledkov pokusu, S je systÃ©m podmnoÅ¾Ã­n mnoÅ¾iny ï a modeluje nÃ¡hodnÃ© udalosti. PovedaÅ¥, Å¾e A je nÃ¡hodnÃ¡ udalosÅ¥, je to istÃ©, ako napÃ­saÅ¥ AïS. Symbol P predstavuje pravdepodobnosÅ¥. Pritom P chÃ¡peme ako zobrazenie, ktorÃ© udalostiam A (t. j. prvkom systÃ©mu S) priraÄuje ich pravdepodobnosÅ¥ P(A). ZdÃ´razÅujeme, Å¾e ï· jedna vec je pre udalosti konkrÃ©tneho pokusu vedieÅ¥ stanoviÅ¥ ich pravdepodobnosti, teda pre AïS vedieÅ¥ stanoviÅ¥ hodnotu P(A) tak, aby model sprÃ¡vne popisoval skutoÄnosÅ¥ a ï· druhÃ¡ vec je â poznaÅ¥ vlastnosti, ktorÃ© mÃ¡ kaÅ¾dÃ¡ pravdepodobnosÅ¥. PrvÃ¡ vec je nÃ¡roÄnejÅ¡ia. Aj preto, Å¾e nie je vÅ¾dy jednoduchÃ© postrehnÃºÅ¥, Å¾e v naÅ¡om modelovanÃ­ je nieÄo zlÃ©, Å¾e nieÄo nesedÃ­. Äo sa tÃ½ka druhej veci, teda vlastnostÃ­ pravdepodobnosti vo vÅ¡eobecnosti, tÃº prÃ¡cu uÅ¾ urobili inÃ­. Budeme si vÅ¡Ã­maÅ¥, Äo o tom hovoria vety tejto kapitoly. V tomto ÄlÃ¡nku bude mnoÅ¾ina ï alebo koneÄnÃ¡, alebo ak nekoneÄnÃ¡, tak spoÄÃ­tateÄ¾nÃ¡. Za systÃ©m S mÃ´Å¾eme v tÃ½chto prÃ­padoch vziaÅ¥ systÃ©m vÅ¡etkÃ½ch podmnoÅ¾Ã­n mnoÅ¾iny ï. AkÃ© vlastnosti mÃ¡ (kaÅ¾dÃ¡) pravdepodobnosÅ¥ P na systÃ©me S? MotivÃ¡ciou pre nasledujÃºcu definÃ­ciu sÃº vlastnosti tÃ½ch konkrÃ©tnych pravdepodobnostÃ­, ktorÃ© sme rozoberali v ÄlÃ¡nkoch 1.1 a 1.2. ZÃ­skali sme ich buÄ uplatnenÃ­m klasickej Laplaceovej definÃ­cie, alebo pravdepodobnosti sme chÃ¡pali ako limity postupnostÃ­ relatÃ­vnych poÄetnostÃ­. V oboch prÃ­padoch â keÄ P chÃ¡peme ako zobrazenie â je pravdepodobnosÅ¥ P aditÃ­vna. V definÃ­cii 1.3.1 pouÅ¾ijme zÃ¡pis P( ) namiesto presnÃ©ho P({ }) a toto zjednoduÅ¡enie budeme pouÅ¾Ã­vaÅ¥ aj Äalej. 1.3.1 DefinÃ­cia. PravdepodobnostnÃ½ priestor (ï, S, P) sa nazÃ½va diskrÃ©tny, ak ï je koneÄnÃ¡, t. j. ï = { }, alebo nekoneÄnÃ¡, ale spoÄÃ­tateÄ¾nÃ¡, t. j. ï = { S je systÃ©m vÅ¡etkÃ½ch podmnoÅ¾Ã­n mnoÅ¾iny ï, P: S â â© âª je zobrazenie s vlastnosÅ¥ami: 1. â"
43,439,0.331,Objektovo orientovanÃ© programovanie v C++,"Vektor je najuniverzÃ¡lnejÅ¡ou dÃ¡tovou Å¡truktÃºrou. Ide vlastne o jednorozmernÃ© dynamickÃ© pole, ktorÃ© mÃ´Å¾e obsahovaÅ¥ prvky Ä¾ubovoÄ¾nÃ©ho typu. VeÄ¾kosÅ¥ tohto poÄ¾a je premenlivÃ¡, to znamenÃ¡, Å¾e sa mÃ´Å¾e zmeniÅ¥ kedykoÄ¾vek, keÄ je to potrebnÃ©. Nie je teda napevno danÃ¡ v Äase kompilÃ¡cie, ale ani poÄiatoÄnou alokÃ¡ciou, ako to je charakteristickÃ© pre dynamickÃ© pole alokovanÃ© pomocou operÃ¡tora new[ ]. To je veÄ¾kou vÃ½hodou tejto Å¡truktÃºry â mÃ´Å¾eme do nej pridÃ¡vaÅ¥ prvky prakticky bez obmedzenia (pravdaÅ¾e, obmedzenie je danÃ© fyzickÃ½mi moÅ¾nosÅ¥ami operaÄnej pamÃ¤te) a jej veÄ¾kosÅ¥ sa automaticky prispÃ´sobÃ­ tak, aby sa do nej novÃ© prvky zmestili. PrÃ¡ca s tÃ½mto poÄ¾om sa veÄ¾mi podobÃ¡ na prÃ¡cu s poÄ¾ami, ktorÃ© uÅ¾ poznÃ¡me. Ide o pole s nÃ¡hodnÃ½m prÃ­stupom, Äo znamenÃ¡, Å¾e mÃ´Å¾eme priamo pristupovaÅ¥ k Ä¾ubovoÄ¾nÃ©mu prvku, pouÅ¾iÅ¥ alebo zmeniÅ¥ jeho hodnotu. Tento nÃ¡hodnÃ½ prÃ­stup je rÃ½chly. Äo je vÅ¡ak pomerne pomalÃ©, je vkladanie alebo vymazÃ¡vanie prvku do/z poÄ¾a. Tak ako pri inÃ½ch poliach, s ktorÃ½mi sme sa stretli, novÃ½ prvok mÃ´Å¾eme vloÅ¾iÅ¥ len tak, Å¾e preÅ uvoÄ¾nÃ­me miesto tÃ½m, Å¾e vÅ¡etky prvky za vybranÃ½m miestom poposÃºvame o jedno miesto Äalej. RÃ½chle je len vkladanie na koniec, a preto je to aj najÄastejÅ¡Ã­ spÃ´sob, ako sa do vektora novÃ© prvky vkladajÃº. Rovnako je to aj s vymazanÃ­m prvku. VoÄ¾nÃ© miesto sa zaplnÃ­ len tak, Å¾e vÅ¡etky prvky za nÃ­m posunieme o jedno miesto spÃ¤Å¥. RÃ½chle je opÃ¤Å¥ len vymazanie poslednÃ©ho prvku. Tieto princÃ­py sÃº znÃ¡zornenÃ© na obr. 10.1."
240,106,0.33,PROGRAMOVANIE V JAZYKU C V RIEÅ ENÃCH PRÃKLADOCH 1,"Ãloha 2-7 NapÃ­Å¡te program, ktorÃ½ pre celÃ© ÄÃ­slo N zadanÃ© na vstupe vypÃ­Å¡e vÅ¡etky nepÃ¡rne ÄÃ­sla od 1 do N. Program by mal pracovaÅ¥ sprÃ¡vne pre vÅ¡etky prÃ­pustnÃ© hodnoty pre N. Pri overovanÃ­ sprÃ¡vnosti rieÅ¡enia experimentujte s rÃ´znymi hodnotami pre N. Ãloha 2-8 DoplÅte chÃ½bajÃºce Äasti v nasledujÃºcom programe, ktorÃ½ naÄÃ­ta celÃ© ÄÃ­slo N zo vstupu a na vÃ½stup vypÃ­Å¡e hodnotu N! (faktoriÃ¡l). Predpokladajte, Å¾e N < 20."
205,30,0.329,"Weboveda: vÃ½chodiskÃ¡, predmet, metÃ³dy","Weboveda: vÃ½chodiskÃ¡, predmet, metÃ³dy aj pozvÃ¡nku na diskusiu. Niekedy sÃº diskusie tak ohnivÃ©, Å¾e prekroÄia hranice sluÅ¡nosti a Äo je horÅ¡ie, aj etnickej alebo nÃ¡boÅ¾enskej znÃ¡Å¡anlivosti. Kto nesie zodpovednosÅ¥ za zverejÅovanie takÃ½chto nÃ¡zorov? Je prÃ­pustnÃ© alebo naopak Å¾elateÄ¾nÃ© ich mazaÅ¥ (cenzurovaÅ¥)? WebovÃ© sÃ­dlo mÃ´Å¾e byÅ¥ eÅ¡te interaktÃ­vnejÅ¡ie. Wiki je webovÃ© sÃ­dlo, ktorÃ©ho obsah mÃ´Å¾u spoloÄne vytvÃ¡raÅ¥ viacerÃ­ Ä¾udia. Podporuje spoluprÃ¡cu Ä¾udÃ­, ktorÃ­ vÃ´bec nemusia byÅ¥ technicky zdatnÃ­. SociÃ¡lna sieÅ¥ je pÃ´vodne pojem, ktorÃ½ zaviedli v sociÃ¡lnych vedÃ¡ch pri Å¡tÃºdiu vzÅ¥ahov medzi jednotlivcami, skupinami, organizÃ¡ciami alebo dokonca spoloÄnosÅ¥ami. Opisuje sociÃ¡lnu Å¡truktÃºru, urÄenÃº ich interakciami. Å tudoval sa uÅ¾ v prvej polovici dvadsiateho storoÄia, keÄ sa eÅ¡te o poÄÃ­taÄoch a tobÃ´Å¾ o webe nechyrovalo. ZvyÅ¡ujÃºca sa moÅ¾nosÅ¥ interaktÃ­vnosti webovÃ½ch sÃ­del priniesla nÃ¡pad podporiÅ¥ interakciu medzi Ä¾uÄmi poskytnutÃ­m webovÃ©ho sÃ­dla, ktorÃ© umoÅ¾Åuje komukoÄ¾vek vytvoriÅ¥ si akÃ½si osobnÃ½ profil, prehlÃ¡siÅ¥ sa za âpriateÄ¾aâ inej osoby so zverejnenÃ½m profilom alebo pridaÅ¥ sa do jednej Äi viacerÃ½ch skupÃ­n. MomentÃ¡lne je najpopulÃ¡rnejÅ¡ou realizÃ¡ciou takÃ©ho nÃ¡padu sÃ­dlo alebo sluÅ¾ba sociÃ¡lneho zosieÅ¥ovania, nazÃ½vanÃ¡ Facebook. VÃ½voj poslednÃ½ch rokov priniesol aj podporu pÃ­sania a Å¡Ã­renia tzv. mikroblogov, t.j. kratuÄkÃ½ch poznÃ¡mok, ktorÃ© nemajÃº viac neÅ¾ 140 znakov. Tieto aj ÄalÅ¡ie novÃ© moÅ¾nosti sociÃ¡lnej komunikÃ¡cie alebo vzÅ¥ahov v spojitosti s webom sÃº novÃ½mi javmi. StÃ¡vajÃº sa pomaly predmetom skÃºmania sociÃ¡lnych vied [1], ale skÃºmanie sa nezaobÃ­de bez hlbokÃ©ho pochopenia vlastnostÃ­ webu. Na druhej strane, ich pochopenie je nevyhnutnÃ© pre hlbÅ¡ie pochopenie toho, Äo je web. MÃ¡lokto asi bude vÃ¡Å¾ne tvrdiÅ¥, Å¾e oznaÄenie niekoho za âpriateÄ¾aâ v sluÅ¾be sociÃ¡lneho zosieÅ¥ovania robÃ­ z tÃ½chto dvoch Ä¾udÃ­ priateÄ¾ov. Ak vÅ¡ak odhliadneme od tohto oznaÄenia, nejakÃ¡ sociÃ¡lna vÃ¤zba medzi dvoma Ä¾uÄmi vznikÃ¡. Je prÃ­kladom Å¡pecifickÃ©ho sociÃ¡lneho vzÅ¥ahu, ktorÃ½ je podmienenÃ½ existenciou webu. Äaleko viac, hypotÃ©za webovedy znie, Å¾e poznanie vlastnostÃ­ aj takÃ½chto sociÃ¡lnych vÃ¤zieb vznikajÃºcich v prostredÃ­ webu je potrebnÃ© pre jeho lepÅ¡ie pochopenie."
369,110,0.328,AplikaÄnÃ© architektÃºry softvÃ©rovÃ½ch systÃ©mov,"Partneri firmy Na reprezentÃ¡ciu externÃ½ch ÃºÄastnÃ­kov â partnerov, t. j. zÃ¡kaznÃ­kov a dodÃ¡vateÄ¾ov, sa kladÃº inÃ© poÅ¾iadavky. PredovÅ¡etkÃ½m bÃ½va uÅ¾itoÄnÃ©, aby vÅ¡etci partneri boli evidovanÃ­ na jednom mieste, Äo zabraÅuje redundancii dÃ¡t a zjednoduÅ¡uje programovÃ½ kÃ³d. KeÄÅ¾e osoby a firmy majÃº nielen spoloÄnÃ©, ale aj odliÅ¡nÃ© atribÃºty, rieÅ¡enie ponÃºka relÃ¡cia generalizÃ¡cie (obr. 2.26). SpoloÄnÃ½mi atribÃºtmi a relÃ¡ciami sÃº naprÃ­klad ÄÃ­slo partnera a jeho adresa. OdliÅ¡nÃ½mi atribÃºtmi sÃº jeho prirodzenÃ© identifikÃ¡tory: meno, priezvisko, dÃ¡tum narodenia a rodnÃ© ÄÃ­slo3 pri osobe a nÃ¡zov firmy, dÃ¡tum zaloÅ¾enia a identifikaÄnÃ© ÄÃ­slo organizÃ¡cie (IÄO), prÃ­padne inÃ© ÄÃ­slo identifikujÃºce danÃº organizÃ¡ciu. Pri partneroch je potrebnÃ¡ moÅ¾nosÅ¥ evidencie (minimÃ¡lne) dvoch adries: adresy trvalÃ©ho bydliska osoby/sÃ­dla firmy a kontaktnej adresy. Na obr. 2.26 sme v porovnanÃ­ s exaktnÃ½m modelom z Äasti 1.3 ukÃ¡zali v praxi ÄastejÅ¡ie pouÅ¾Ã­vanÃ½ prÃ­stup k modelovaniu adries: partner mÃ¡ samostatnÃ© relÃ¡cie do registra obcÃ­ a registra ulÃ­c, kÃ½m orientaÄnÃ© ÄÃ­sla sa zadÃ¡vajÃº iba ako znakovÃ© reÅ¥azce. UvedenÃ½ model nespÄºÅa princÃ­py normalizÃ¡cie (orientaÄnÃ© ÄÃ­sla by mali byÅ¥ samostatnÃ© inÅ¡tancie, ktorÃ© jednoznaÄne urÄujÃº ulice a obce a tieÅ¾ ulica jednoznaÄne urÄuje obec), je vÅ¡ak urÄitÃ½m kompromisom medzi presnÃ½m (a zriedkavo pouÅ¾Ã­vanÃ½m) modelom a modelom zaloÅ¾enÃ½m iba na znakovÃ½ch reÅ¥azcoch, ktorÃ½ prinÃ¡Å¡a mnoÅ¾stvo chÃ½b. Pri partneroch nebÃ½va potrebnÃ© evidovaÅ¥ ich organizaÄnÃº Å¡truktÃºru, pretoÅ¾e partnerom je firma/organizÃ¡cia ako celok. VÃ½nimkou je, ak mÃ¡ firma viacero teritoriÃ¡lnych poboÄiek alebo prevÃ¡dzok a firma, ktorÃ¡ prevÃ¡dzkuje softvÃ©rovÃ½ systÃ©m spolupracuje jednotlivo s viacerÃ½mi z nich. InÃ½m prÃ­padom je, ak firma patrÃ­ do nejakÃ©ho zdruÅ¾enia alebo (nadnÃ¡rodnÃ©ho) koncernu. (Oba prÃ­pady ponechÃ¡vame ÄitateÄ¾ovi ako cviÄenie.) Pri partneroch niekedy evidujeme aj jej zÃ¡stupcov, ktorÃ­ sÃº oprÃ¡vnenÃ­ konaÅ¥ v jej mene. TakÃ½chto zÃ¡stupcov mÃ´Å¾e byÅ¥ pre jednu firmu viac a dokonca mÃ´Å¾u byÅ¥ medzi nimi definovanÃ© vzÅ¥ahy. (Firma mÃ¡ naprÃ­klad Å¡tyroch konateÄ¾ov, priÄom za firmu musia vystupovaÅ¥ vÅ¾dy minimÃ¡lne dvaja z nich a nesmÃº to byÅ¥ sÃºÄasne konatelia X a Y.). EvidovaÅ¥ zÃ¡stupcov firmy v softvÃ©rovom systÃ©me mÃ´Å¾e byÅ¥ dosÅ¥ ambiciÃ³zny cieÄ¾, pretoÅ¾e tÃ½chto zÃ¡stupcov pri veÄ¾kej firme (naprÃ­klad banke) mÃ´Å¾e byÅ¥ veÄ¾a s rÃ´znymi kompetenciami a navyÅ¡e sa po Äase menia. Z uvedenÃ©ho dÃ´vodu sa zvyÄajne takÃ¡to evidencia redukuje na evidenciu"
190,94,0.328,O softvÃ©ri od A po Z ; Ãvahy nastupujÃºcich profesionÃ¡lov,"OdliÅ¡nÃ½ spÃ´sob rozkladu je zameranÃ½ na rozvoj pracovnÃ­kov. Na zvlÃ¡dnutÃ­ takto rozloÅ¾enÃ©ho projektu mÃ¡ obrovskÃ½ vplyv skÃºsenosÅ¥ pracovnÃ­ka, ktorÃ½ tento strom rozloÅ¾enia vytvoril. VedÃºci musÃ­ dobre poznaÅ¥ svojich pracovnÃ­kov, musÃ­ poznaÅ¥, kto Äo vie a Äo dokÃ¡Å¾e. Ako rÃ½chlo sa dokÃ¡Å¾u konkrÃ©tni pracovnÃ­ci nauÄiÅ¥ nieÄo novÃ©, ako sa dokÃ¡Å¾u vyrovnaÅ¥ s tlakom a stresom, ako dokÃ¡Å¾u spolupracovaÅ¥, prÃ­padne uÄiÅ¥ sa od inÃ½ch. UÅ¾ maÅ¥ tieto vedomosti je veÄ¾kÃ© umenie. Älovek, ktorÃ½ mÃ¡ takÃ½to dobrÃ½ odhad a kontrolu nad pracovnÃ­kmi, je nenahraditeÄ¾nÃ½. MusÃ­ Äalej odhadnÃºÅ¥, koÄ¾ko si s pracovnÃ­kmi mÃ´Å¾e dovoliÅ¥ a koÄ¾ko Ãºstupkov mÃ´Å¾e spraviÅ¥ smerom k projektu. MusÃ­ oÄakÃ¡vaÅ¥ rizikÃ¡ spojenÃ© s neskÃºsenosÅ¥ou pracovnÃ­kov, vznikajÃºce konflikty v tÃ­moch. Po zvÃ¡Å¾enÃ­ vÅ¡etkÃ½ch moÅ¾nostÃ­ vznikÃ¡ rozklad kompletnÃ©ho SkÃºsenÃ½ pracovnÃ­k, projektu po najmenÅ¡ie detaily. PodÄ¾a mÅa je ÃºspeÅ¡ne fungujÃºci rozklad ktorÃ½ dokÃ¡Å¾e dobre hotovÃ½m umeleckÃ½m dielom. Predstava zharmonizovanÃ½ch paralelne rozloÅ¾iÅ¥ aj zloÅ¾itÃ½ vykonÃ¡vanÃ½ch Ãºloh vedÃºcich k cieÄ¾u projektu a zÃ¡roveÅ trÃ©ning pra- projekt, by mal byÅ¥ covnÃ­kov sa zdÃ¡ byÅ¥ priam nemoÅ¾nÃ¡. vyvÃ¡Å¾enÃ½ zlatom. PoÄme sa eÅ¡te ale pozrieÅ¥ hlbÅ¡ie do rozkladu Ãºloh. UÅ¾ aj vo vyÅ¡Å¡Ã­ch Ãºrovniach vznikÃ¡ zÃ¡vaÅ¾nÃ½ problÃ©m, ktorÃ½ by sa dal nazvaÅ¥ blokovanie prÃ¡c. Ak je vÃ½sledok jednej prÃ¡ce potrebnÃ½ na zaÄiatok druhej prÃ¡ce, treba, aby bola prvÃ¡ prÃ¡ca ukonÄenÃ¡ pred zaÄatÃ­m druhej. Tieto dve prÃ¡ce nemusÃ­ maÅ¥ pridelenÃ© jedinÃ½ pracovnÃ­k, a tak sa mÃ´Å¾e staÅ¥, Å¾e pracovnÃ­k, ktorÃ½ mÃ¡ vykonaÅ¥ druhÃº Ãºlohu stojÃ­ nad inÃ½m so zaloÅ¾enÃ½mi rukami. Je to zÃ¡vaÅ¾nÃ½ problÃ©m, obrovskÃ© mrhanie zdrojov a strata Äasu. SkÃºsenÃ½ vedÃºci pracovnÃ­k by podÄ¾a mÃ´jho nÃ¡zoru mal tento problÃ©m rieÅ¡iÅ¥ od zaÄiatku procesu rozkladu. Je to sÃ­ce hlavnÃ½ problÃ©m tÃ½kajÃºci sa procesu plÃ¡novania, ale vytvorenie Äo najmenÅ¡Ã­ch zÃ¡vislostÃ­ medzi Ãºlohami mÃ´Å¾e tento problÃ©m podstatne odÄ¾ahÄiÅ¥."
184,25,0.327,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 3,"PrÃ¡ca softvÃ©rovÃ©ho architekta nespoÄÃ­va len vo vytvorenÃ­ architektÃºry. PodÄ¾a SEI 1 musÃ­ softvÃ©rovÃ½ architekt Äalej: Â zdokumentovaÅ¥ a komunikovaÅ¥ vytvorenÃº architektÃºru; Â uistiÅ¥ sa, Å¾e ju kaÅ¾dÃ½ pouÅ¾Ã­va a to sprÃ¡vnym spÃ´sobom; Â uistiÅ¥ sa, Å¾e vytvÃ¡ranÃ½ softvÃ©r je v sÃºlade s architektÃºrou; Â uistiÅ¥ sa, Å¾e manaÅ¾ment architektÃºre rozumie na poÅ¾adovanej Ãºrovni detailnosti; Â rieÅ¡iÅ¥ technickÃ© problÃ©my; Â rieÅ¡iÅ¥ nezhody a robiÅ¥ kompromisy; Â uistiÅ¥ sa, Å¾e sa pouÅ¾Ã­vajÃº sprÃ¡vne modelovacie techniky, aby sa vedelo v dostatoÄnom predstihu, Äi sa dosiahnu poÅ¾iadavky na kvalitu ako je vÃ½konnosÅ¥; Â spolupodieÄ¾aÅ¥ sa na problÃ©moch ako je vÃ½ber konkrÃ©tnych nÃ¡strojov a prostredÃ­; Â uistiÅ¥ sa, Å¾e architektÃºra je sprÃ¡vna z hÄ¾adiska nasadenia, ÃºdrÅ¾by a ÄalÅ¡ieho vÃ½voja systÃ©mu; Â udrÅ¾iavaÅ¥ morÃ¡lku vo vÃ½vojom tÃ­me; Â chÃ¡paÅ¥ a plÃ¡novaÅ¥ vÃ½vojovÃ© smery aplikÃ¡cie, plÃ¡novaÅ¥ nasadenie novÃ½ch technolÃ³giÃ­; Â vykonÃ¡vaÅ¥ manaÅ¾ment rizÃ­k sÃºvisiacich s architektÃºrou. UvedenÃ½ zoznam nie je kompletnÃ½ a zrejme ani nikdy nemÃ´Å¾e byÅ¥, keÄÅ¾e kaÅ¾dÃ½ mÃ¡ svoje vlastnÃ© oÄakÃ¡vania a definÃ­cie prÃ¡ce softvÃ©rovÃ©ho architekta. Zo zoznamu sa vÅ¡ak dajÃº abstrahovaÅ¥ zÃ¡kladnÃ© zruÄnosti softvÃ©rovÃ©ho architekta v tÃ½chto Å¡tyroch oblastiach: Â VzÅ¥ahy â architekt hrÃ¡ vÃ½znamnÃº rolu vo viacerÃ½ch vzÅ¥ahoch v rÃ¡mci spoloÄnosti ako aj navonok smerom k zÃ¡kaznÃ­kovi. Äasto sa zÃºÄastÅuje stretnutÃ­ so zÃ¡kaz1"
393,540,0.327,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 2,"V zÃ¡sade sa dÃ¡ povedaÅ¥, Å¾e sme rozdelili pohÄ¾ad na znovupouÅ¾itie nÃ¡vrhovÃ½ch vzorov na dve zÃ¡kladnÃ© skupiny, od ktorÃ½ch sa odvÃ­jajÃº rÃ´zne problÃ©my. KonkrÃ©tne ide o: Â znovupouÅ¾itie nÃ¡vrhovÃ½ch vzorov formou CASE nÃ¡strojov a Â znovupouÅ¾itie nÃ¡vrhovÃ½ch vzorov, resp. ich ÄastÃ­ pomocou samotnÃ©ho implementaÄnÃ©ho jazyka. Postupne sme identifikovali problÃ©my s viditeÄ¾nosÅ¥ou vzorov v celkovom nÃ¡vrhu, Äo je spojenÃ© s nÃ¡vrhom a implementÃ¡ciou prehÄ¾adnej a Å¡iroko pouÅ¾iteÄ¾nej notÃ¡cie a s pouÅ¾itÃ­m mikroarchitektÃºr, ktorÃ© sÃº eÅ¡te i dnes pomerne nejasne definovanÃ© vo vÅ¡eobecnosti a tieÅ¾ chÃ½ba definÃ­cia, Äi uÅ¾ formÃ¡lna alebo semiformÃ¡lna, skupÃ­n spolupracujÃºcich vzorov vo forme definÃ­ciÃ­ mikroarchitektÃºr. ZaujÃ­mavÃ© sa zdÃ¡ vytvorenie katalÃ³gu mikroarchitektÃºr ako skupÃ­n spolupracujÃºcich vzorov, priÄom Å¡truktÃºra katalÃ³gu by mohla byÅ¥ podobnÃ¡ Å¡truktÃºre sÃºÄasnÃ½ch katalÃ³gov nÃ¡vrhovÃ½ch vzorov."
236,19,0.327,Nie prÃ­liÅ¡ struÄnÃ½ Ãºvod do systÃ©mu LATEX2e,"KeÄ Ä¾udia z WYSIWYGovÃ©ho sveta stretnÃº Ä¾udÃ­, ktorÃ­ pouÅ¾Ã­vajÃº LATEX, najÄastejÅ¡ie sa diskutuje âo vÃ½hodÃ¡ch LATEXu v porovnanÃ­ s normÃ¡lnym textovÃ½m procesoromÃ¿ alebo naopak. NajlepÅ¡ie urobÃ­te, ak takÃ½to rozhovor zaÄne, keÄ budete v ÃºzadÃ­, keÄÅ¾e sa takÃ¡to diskusia Äasto vymykÃ¡ z rÃºk. AvÅ¡ak niekedy niet Ãºniku. . . Teda tu je troÅ¡ka streliva. NajvÃ¤ÄÅ¡ie vÃ½hody LATEXu oproti normÃ¡lnym textovÃ½m procesorom sÃº nasledujÃºce: â¢ SÃº dostupnÃ© profesionÃ¡lne vytvorenÃ© Ãºpravy strÃ¡nky, takÅ¾e dokument skutoÄne vyzerÃ¡, ako keby bol âvytlaÄenÃ½Ã¿. â¢ PÃ­sanie matematickÃ½ch vzorcov je zabezpeÄenÃ© pohodlnÃ½m spÃ´sobom. â¢ UÅ¾Ã­vateÄ¾ovi sa staÄÃ­ nauÄiÅ¥ niekoÄ¾ko Ä¾ahko pochopiteÄ¾nÃ½ch prÃ­kazov, definujÃºcich logickÃº Å¡truktÃºru dokumentu. Takmer nikdy nemusÃ­ âfuÅ¡ovaÅ¥Ã¿ do nastavenej Ãºpravy dokumentu. â¢ Ä½ahko mÃ´Å¾u byÅ¥ vygenerovanÃ© aj zloÅ¾itÃ© Å¡truktÃºry, ako poznÃ¡mky pod Äiarou, odkazy, obsah, pouÅ¾itÃ¡ literatÃºra a register. â¢ Na rieÅ¡enie mnohÃ½ch typografickÃ½ch Ãºloh priamo nepodporovanÃ½ch zÃ¡kladnÃ½m LATEXom existujÃº voÄ¾ne pripojiteÄ¾nÃ© balÃ­ky makier. NaprÃ­klad mÃ´Å¾ete pomocou nich vloÅ¾iÅ¥ do textu PostScriptovÃº grafiku alebo vytvoriÅ¥ bibliografie dodrÅ¾ujÃºc presnÃ© Å¡tandardy. Mnoho z tÃ½chto voÄ¾ne pripojiteÄ¾nÃ½ch makier je opÃ­sanÃ½ch v The LATEX Companion [3]. â¢ LATEX povzbudzuje autorov pÃ­saÅ¥ texty s kvalitnou Å¡truktÃºrou, pretoÅ¾e toto je spÃ´sob, ako LATEX pracuje â Å¡pecifikovanÃ­m Å¡truktÃºry. â¢ TEX, formÃ¡tovacÃ­ motor LATEXu2Îµ, je bezplatnÃ½ a Ä¾ahko prenositeÄ¾nÃ½. Preto beÅ¾Ã­ takmer na kaÅ¾dej dostupnej hardvÃ©rovej platforme. LATEX mÃ¡ aj urÄitÃ© nevÃ½hody, ale myslÃ­m si, Å¾e je pre mÅa trochu obtiaÅ¾ne nÃ¡jsÅ¥ nejakÃº rozumnÃº, hoci som si istÃ½, Å¾e inÃ­ Ä¾udia by vÃ¡m mohli povedaÅ¥ o stovkÃ¡ch ;-) â¢ LATEX nefunguje dobre Ä¾uÄom, ktorÃ­ predali svoju duÅ¡u. . . â¢ Hoci pri preddefinovanÃ½ch formÃ¡toch strÃ¡n sa dajÃº upravovaÅ¥ niektorÃ© parametre, vytvorenie novÃ©ho formÃ¡tu je nÃ¡roÄnÃ© a zaberie veÄ¾a Äasu2 . â¢ Je veÄ¾mi Å¥aÅ¾kÃ© napÃ­saÅ¥ neÅ¡truktÃºrovanÃ½ a chaotickÃ½ dokument."
190,390,0.326,O softvÃ©ri od A po Z ; Ãvahy nastupujÃºcich profesionÃ¡lov,"KeÄ dÃ¡me Ä¾uÄom do rÃºk dokonalejÅ¡ie nÃ¡stroje, rozdiely medzi nimi sa zaÄnÃº zmenÅ¡ovaÅ¥. Aj keÄ posun kvality vÄaka softvÃ©rovÃ½m nÃ¡strojom nie je vÃ½raznÃ½, je urÄite prÃ­nosom. Zistilo sa, Å¾e v oblasti databÃ¡zovÃ½ch technolÃ³giÃ­ vzrÃ¡stla kvalita (hodnotenÃ¡ na zÃ¡klade oznÃ¡mkovania urÄenÃ½ch vlastnostÃ­) o 30 % v obdobÃ­ 1997-2002 oproti obdobiu 1992-1997, Äo pripisuje kvalitnejÅ¡Ã­m nÃ¡strojom na vÃ½voj [1]. ModernÃ© vÃ½vojÃ¡rske nÃ¡stroje naznaÄili pozitÃ­vny trend v oblasti zlepÅ¡ovania kvality. DneÅ¡nÃ© kompilÃ¡tory dokÃ¡Å¾u automaticky oznaÄiÅ¥ mnoÅ¾stvo potenciÃ¡lnych chÃ½b, ktorÃ© by inak unikli pozornosti. PrÃ­pady ako nepouÅ¾itÃ© premennÃ©, neinicializovanÃ© premennÃ©, nedostupnÃ½ kÃ³d, funkcie s vetvami bez definovanÃ©ho vÃ½stupu a mnohÃ© ÄalÅ¡ie sÃº dnes potlaÄenÃ© na minimum. Osobne by som uvÃ­tal nÃ¡stroje, ktorÃ© by automaticky sledovali, ktorÃ© sÃºÄiastky mÃ´Å¾u byÅ¥ potenciÃ¡lne ovplyvnenÃ© uskutoÄnenÃ½mi zmenami v kÃ³de. Na prvÃ½ch prieÄkach v zozname by boli tie sÃºÄiastky, ktorÃ© sÃº zmenami ovplyvnenÃ© v najvÃ¤ÄÅ¡ej miere. OznaÄenÃ© by boli miesta, kde mÃ´Å¾e teoreticky dÃ´jsÅ¥ k problÃ©mom a tÃ½mto by som ako programÃ¡tor mohol venovaÅ¥ viac pozornosti. PredpokladÃ¡m, Å¾e automatickÃ© inteligentnÃ© odhaÄ¾ovanie chÃ½b a potenciÃ¡lnych problÃ©mov v programe sa bude Äalej vyvÃ­jaÅ¥, a tak umoÅ¾nÃ­ zlepÅ¡iÅ¥ kvalitu vÃ½stupov slabÅ¡Ã­ch programÃ¡torov, Äi odstrÃ¡niÅ¥ prehliadnutÃ© nedostatky v kÃ³de skÃºsenÃ½ch vÃ½vojÃ¡rov."
190,235,0.326,O softvÃ©ri od A po Z ; Ãvahy nastupujÃºcich profesionÃ¡lov,"Predstavme si, Å¾e nÃ¡s prÃ¡ve prijali na prÃ¡cu na projekte. Nech na Åom pracuje eÅ¡te niekoÄ¾ko ÄalÅ¡Ã­ch Ä¾udÃ­. NemusÃ­ ich byÅ¥ veÄ¾a, staÄÃ­ dvaja, traja. Nie je dÃ´leÅ¾itÃ©, ÄÃ­m sa projekt zaoberÃ¡. DÃ´leÅ¾itÃ© je, Å¾e preÅ nebol vytvorenÃ½ Å¾iaden plÃ¡n alebo bol vytvorenÃ½ len veÄ¾mi hrubÃ½ plÃ¡n, ktorÃ½ ani zÄaleka nepokrÃ½va vÅ¡etky nutnÃ© nÃ¡leÅ¾itosti. ManaÅ¾Ã©r zvolal poradu, kde vÅ¡etkÃ½m oznÃ¡mil, o Äo pribliÅ¾ne v projekte ide a Å¾e od kaÅ¾dÃ©ho oÄakÃ¡va, aby sa zapojil."
76,333,0.326,PRAVDEPODOBNOSÅ¤ A MATEMATICKÃ Å TATISTIKA,"7.2.4 PoznÃ¡mka. PrÃ¡ve sme ukÃ¡zali, Å¾e vieme rozhodnÃºÅ¥, ktorÃ½ z dvoch uvaÅ¾ovanÃ½ch nevychÃ½lenÃ½ch odhadov je lepÅ¡Ã­. Rovnako by sme vybrali najlepÅ¡Ã­ spomedzi troch, Äi Å¡tyroch nevychÃ½lenÃ½ch odhadov. PokiaÄ¾ sa obmedzÃ­me na nevychÃ½lenÃ© odhady, tak nÃ¡jsÅ¥ najlepÅ¡Ã­ nevychÃ½lenÃ½ odhad znamenÃ¡ nÃ¡jsÅ¥ ten z nich, ktorÃ©ho variancia je (spomedzi vÅ¡etkÃ½ch nevychÃ½lenÃ½ch odhadov) najmenÅ¡ia moÅ¾nÃ¡. TÃ¡to problematika vÅ¡ak uÅ¾ presahuje rÃ¡mec tohoto textu. Nakoniec poznamenajme, Å¾e mierne vychÃ½lenÃ½ odhad ( ) nie je treba ignorovaÅ¥, pokiaÄ¾ jeho MSE( ) je menÅ¡ia ako variancia konkurenÄnÃ©ho nevychÃ½lenÃ©ho odhadu, pretoÅ¾e MSE( ) je vskutku dobrÃ½ ukazovateÄ¾ kvality odhadu. 7.2.5 PrÃ­klad. Nech odhadoch parametrov"
190,302,0.325,O softvÃ©ri od A po Z ; Ãvahy nastupujÃºcich profesionÃ¡lov,"takpovediac z prsta. NavyÅ¡e, ak zvolÃ­ vysokÃº ÃºroveÅ ohrozenia a zabrÃ¡ni tak prÃ­padnÃ©mu teroristickÃ©mu Ãºtoku, nikto sa o tom nedozvie a obÄania budÃº akurÃ¡t nadÃ¡vaÅ¥ na rÃ´zne obmedzenia, ktorÃ© si museli vytrpieÅ¥. Naopak, ak zvolÃ­ nÃ­zku ÃºroveÅ a dÃ´jde k neÄakanÃ©mu Ãºtoku, Ä¾udia okrem toho, Å¾e budÃº nahnevanÃ­, zaÄnÃº pochybovaÅ¥ o vÃ½zname takÃ©hoto Ãºradu. V softvÃ©rovÃ½ch firmÃ¡ch sa Äasto deje nieÄo podobnÃ©. V oÄiach zamestnancov mÃ´Å¾e byÅ¥ manaÅ¾Ã©r zbytoÄnou zloÅ¾kou vÃ½vojovÃ©ho tÃ­mu. PodÄ¾a nich totiÅ¾ ak firma v danom projekte uspeje, je to vÄaka programÃ¡torom, keÄ neuspeje, je to samozrejme chyba manaÅ¾Ã©ra. Ako sa spieva v jednej slovenskej pesniÄke: âÃºspech je vÅ¡etkÃ½ch, neÃºspech iba jednÃ©hoâ. MÃ¡lokto si vÅ¡ak uvedomuje, Å¾e samotnÃ¡ predpoveÄ budÃºcnosti tÃºto budÃºcnosÅ¥ ovplyvÅuje. UÅ¾ spomÃ­nanÃ© zabrÃ¡nenie predpokladanÃ©mu Ãºtoku je toho dobrÃ½m prÃ­kladom. V rovine softvÃ©rovÃ½ch inÅ¾inierov moÅ¾no tento fakt interpretovaÅ¥ takto: Ak rÃ¡tate so zmenami poÅ¾iadaviek alebo technolÃ³giÃ­ a tieto predpoklady zakomponujete do svojich Ãºvah uÅ¾ na zaÄiatku, vyrieÅ¡ite tÃ½m mnoÅ¾stvo problÃ©mov, ktorÃ© by sa neskÃ´r objavili. V ideÃ¡lnom stave vyrieÅ¡ite vÅ¡etky problÃ©my eÅ¡te pred ich vznikom a neskÃ´r sa nemusÃ­te uÅ¾ o niÄ staraÅ¥, keÄÅ¾e Å¾iadne problÃ©my sa (paradoxne) nevyskytli."
195,203,0.325,OdporÃºÄanie pre softvÃ©rovÃ½ch inÅ¾inierov,"11.5 Zhrnutie VykonÃ¡vanie systematickÃ½ch zmien je ÄastokrÃ¡t mÃ¡lo zaujÃ­mavÃ¡ ÄinnosÅ¥ a nÃ¡chylnÃ¡ na chyby. Ako rieÅ¡enie tejto problematiky sme uviedli zavedenie systÃ©mov pre odporÃºÄanie transformÃ¡ciÃ­ zdrojovÃ©ho kÃ³du. TransformÃ¡cia sa identifikuje z interakciÃ­ programÃ¡tora alebo vykonanÃ½ch zmien medzi verziami zdrojovÃ©ho kÃ³du ako prevod z pÃ´vodnej verzie na novÃº verziu. TÃºto transformÃ¡ciu je moÅ¾nÃ© zovÅ¡eobecniÅ¥, ako sme uviedli na prÃ­klade systÃ©mu Sydit, a nÃ¡sledne aplikovaÅ¥ aj v inÃ½ch podobnÃ½ch miestach zdrojovÃ©ho kÃ³du. OdporÃºÄanÃ­m v tomto prÃ­pade bol vzor transformÃ¡cie a miesta, kde ju moÅ¾no aplikovaÅ¥. Na odporÃºÄacie systÃ©my v tejto oblasti sa preto mÃ´Å¾eme pozeraÅ¥ z viacerÃ½ch pohÄ¾adov po vykonanÃ­ prvej zmeny, ktorÃ¡ by mala byÅ¥ transformÃ¡ciou: - odporÃºÄanie miest v zdrojovom kÃ³de, ktorÃ© by mal programÃ¡tor transformovaÅ¥, - odporÃºÄanie vzoru transformÃ¡cie z vykonanej zmeny, - odporÃºÄanie pouÅ¾itia transformÃ¡cie na zvolenom mieste. ExistujÃºce rieÅ¡enia tejto problematiky vÅ¡ak narÃ¡Å¾ajÃº na viacerÃ© problÃ©my. NajvÃ¡Å¾nejÅ¡Ã­m sÃº granularita a kontext zmeny. UvedenÃ½ prÃ­klad transformÃ¡cie systÃ©mom Sydit je moÅ¾nÃ© vykonaÅ¥ len v rÃ¡mci metÃ³dy v zdrojovom kÃ³de. SystematickÃ© zmeny sa vÅ¡ak ÄastokrÃ¡t vykonÃ¡vajÃº aj na vyÅ¡Å¡ej Ãºrovni, napr. hierarchia tried, alebo naprieÄ viacerÃ½mi metÃ³dami sÃºÄasne. ProblÃ©mom odlÃ­Å¡enia kontextu zmeny je prÃ­klad upravenia cyklu for, kedy by sa nesprÃ¡vne odporÃºÄali vÅ¡etky podobnÃ© cykly v zdrojovom kÃ³de. Z tohto vyplÃ½va aj problÃ©m presnosti odporÃºÄania, keÄ mÃ´Å¾eme programÃ¡tora zahltiÅ¥ odporÃºÄaniami."
190,399,0.324,O softvÃ©ri od A po Z ; Ãvahy nastupujÃºcich profesionÃ¡lov,"Pod pojmom testovanie si vÃ¤ÄÅ¡ina z nÃ¡s predstavÃ­ vykonÃ¡vanie softvÃ©ru za ÃºÄelom overenia jeho sprÃ¡vnosti. AlternatÃ­vnou formou testovania (alebo presnejÅ¡ie kontroly kvality) je ukÃ¡zanie prÃ¡ce kolegovi za ÃºÄelom objavenia chÃ½b a moÅ¾nostÃ­ zlepÅ¡enia. KÃ½m tradiÄnÃ© testovanie je obmedzenÃ© na overovanie vlastnostÃ­ spustiteÄ¾nÃ©ho kÃ³du, prehliadky mÃ´Å¾u byÅ¥ (a mali by byÅ¥) pouÅ¾itÃ© na vÅ¡etky Äasti procesu vÃ½voja: od analÃ½zy cez nÃ¡vrh aÅ¾ po tvorbu dokumentÃ¡cie. Za chyby sa platÃ­ a v softvÃ©rovom inÅ¾inierstve sa za chyby platÃ­ tÃ½m viac, ÄÃ­m neskorÅ¡ie sa odhalia. TroÅ¡ka matematiky ukÃ¡Å¾e, Å¾e najviac uÅ¡etrÃ­me na chybÃ¡ch, ktorÃ© odhalÃ­me Äo najskÃ´r â a to sÃº chyby v Å¡pecifikÃ¡cii poÅ¾iadaviek. NiÄ vÅ¡ak nie je zadarmo, a to platÃ­ aj pre prehliadky. Na jednej strane uÅ¡etrÃ­me na chybÃ¡ch, na druhej strane stratÃ­me Äas a prostriedky na ich hÄ¾adanie. Prehliadky mÃ´Å¾u âzhltnÃºÅ¥â aÅ¾ 5 â 15% vÅ¡etkÃ½ch nÃ¡kladov na projekt [6]. Napriek tomu sa ukazuje, Å¾e vÃ½hody Äaleko prevÃ¡Å¾ia nÃ¡klady. Prehliadky skracujÃº dobu potrebnÃº na vÃ½voj tÃ½m, Å¾e skracujÃº dobu potrebnÃº na integrÃ¡ciu a redukujÃº Äas potrebnÃ½ na testovanie, pretoÅ¾e do finÃ¡lneho testovania sa dostÃ¡va menej chybovÃ½ produkt. VyÅ¡Å¡ia kvalita finÃ¡lneho produktu tieÅ¾ skracuje Äas potrebnÃ½ na ÃºdrÅ¾bu. Äas, ktorÃ½ by bolo treba venovaÅ¥ hÄ¾adaniu a opravovaniu chÃ½b, je tak moÅ¾nÃ© venovaÅ¥ vÃ½voju novÃ½ch funkciÃ­. SamotnÃ© testovanie softvÃ©ru mÃ¡ len obmedzenÃ½ efekt. PriemernÃ½ podiel odhalenÃ½ch chÃ½b je len 25% pre testy jednotiek softvÃ©ru (angl. unit tests), 35% pre funkÄnÃ© testy a 45% pre integraÄnÃ© testy. Pre porovnanie, priemernÃ¡ efektivita prehliadok kÃ³du je 55 aÅ¾ 60% [5]. PodÄ¾a inej Å¡tÃºdie, typickÃ½ programÃ¡tor nÃ¡jde za hodinu testovanÃ­m 2-4 chyby, ale 6-10 chÃ½b pri prehliadke kÃ³du [3]. Je to spÃ´sobenÃ© aj tÃ½m, Å¾e ak sa pri testovanÃ­ odhalÃ­ chyba, treba venovaÅ¥ Äas hÄ¾adaniu prÃ­Äiny. Pri prehliadke kÃ³du sa vÅ¡ak hÄ¾adajÃº priamo prÃ­Äiny chyby, nie len symptÃ³my. Prehliadky kÃ³du vÅ¡ak neslÃºÅ¾ia ako nÃ¡hrada testovania, ale len ako doplnok. Tieto dve techniky pomÃ¡hajÃº odhaÄ¾ovaÅ¥ rÃ´zne druhy chÃ½b, sÃº aplikovateÄ¾nÃ© v rÃ´znych fÃ¡zach projektu a vyÅ¾adujÃº rÃ´zne druhy a Ãºrovne skÃºsenostÃ­. Testovanie ukazuje reÃ¡lne sprÃ¡vanie systÃ©mu, nie modelovÃ© sprÃ¡vanie,"
59,14,0.324,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"1.4 KognitÃ­vna neuroveda Neuroveda Å¡tuduje nervovÃ½ systÃ©m, jeho vlastnosti, architektÃºru, fyziolÃ³giu a biofyziku neurÃ³nov a spojov (synapsiÃ­) medzi nimi. Jej Å¡pecializovanÃ¡ ÄasÅ¥ kognitÃ­vna neuroveda [13] Å¡tuduje mechanizmy realizÃ¡cie kognitÃ­vnych aktivÃ­t mozgu. Je to veda o informaÄnÃ½ch procesoch prebiehajÃºcich v mozgu: (1) akÃ½m spÃ´sobom je tÃ¡to informÃ¡cia zÃ­skavanÃ¡ z naÅ¡ich zmyslov, (2) ako sÃº realizovanÃ© procesy vnÃ­mania a rozpoznÃ¡vania, (3) ako vznikÃ¡ myslenie a vedomie, (4) ako vznikajÃº procesy rozhodovania, ktorÃ© zahÅÅajÃº predvÃ­danie budÃºcich stavov nÃ¡Å¡ho okolia a dÃ´sledkov naÅ¡ej aktivity, (5) Äo je to uÄenie a ako je realizovanÃ¡ pamÃ¤Å¥ a koneÄne, (6) ako sÃº implementovanÃ© procesy tvoriace nÃ¡Å¡ jazyk? Tieto Äinnosti patria do fundamentÃ¡lneho jadra kognitÃ­vnej vedy. MÃ´Å¾eme si poloÅ¾iÅ¥ otÃ¡zku, akÃ½ je rozdiel medzi kognitÃ­vnou vedou a kognitÃ­vnou neurovedou? HÄ¾adaÅ¥ odpoveÄ na tÃºto otÃ¡zku nie je jednoduchÃ© v dÃ´sledku veÄ¾kÃ©ho presahu medzi tÃ½mito dvoma âkognitÃ­vnymiâ vednÃ½mi disciplÃ­nami. SnÃ¡Ä, pomocou urÄitÃ©ho zjednoduÅ¡enÃ©ho prÃ­stupu k tomuto problÃ©mu, mÃ´Å¾eme povedaÅ¥, Å¾e medzi âkognitÃ­vnou neurovedouâ a âkognitÃ­vnou vedouâ existuje demarkaÄnÃ¡ Äiara v predmete ich zÃ¡ujmu, predmet zÃ¡ujmu kognitÃ­vnej neurovedy je hardvÃ©r (t. j. biologickÃ¡ realizÃ¡cia procesov) a predmet zÃ¡ujmu kognitÃ­vnej vedy je softvÃ©r (t. j. informatickÃ¡ a/alebo algoritmickÃ¡ realizÃ¡cia procesov). Tu musÃ­me vÅ¡ak poznamenaÅ¥, Å¾e toto zakotvenie kognitÃ­vnej vedy v biologickÃ½ch vedÃ¡ch (na nervovom substrÃ¡te) je hlavnÃ© kritÃ©rium odlÃ­Å¡enia kognitÃ­vnej vedy od umelej inteligencie, ktorÃ¡ taktieÅ¾ Å¡tuduje algoritmickÃº realizÃ¡ciu kognitÃ­vnych (alebo vÅ¡eobecnejÅ¡ie â inteligentnÃ½ch) procesov, ale nie je zakotvenÃ¡ na neurÃ³novom substrÃ¡te. VeÄ¾mi zaujÃ­mavÃ¡ je histÃ³ria neurovedy (a teda aj kognitÃ­vnej neurovedy). Za prvÃ½ch experimentÃ¡torov s Ä¾udskÃ½m mozgom sÃº pokladanÃ­ EgypÅ¥ania, ktorÃ­ uÅ¾ pred 5000 rokmi vykonÃ¡vali chirurgickÃ© vÃ½kony na mozgu. O ÃºspeÅ¡nosti tÃ½chto zÃ¡krokov svedÄia archeologickÃ© nÃ¡lezy, kde boli nÃ¡jdenÃ© lebky so zahojenou trepanÃ¡ciou lebeÄnej kosti. Filozof Aristoteles veril, Å¾e centrom naÅ¡ej inteligencie je srdce (podÄ¾a neho mozog je orgÃ¡n na"
184,75,0.324,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 3,"ObrÃ¡zok 2-4. PouÅ¾itie distribuovanÃ½ch objektov v CORBA. ObrÃ¡zok 2-4 znÃ¡zorÅuje jednoduchÃ½ scenÃ¡r pouÅ¾itia CORBA pre zaslanie poÅ¾iadavky klientom na server za pomoci sprostredkovateÄ¾a poÅ¾iadaviek pre objekty (Object Request Broker, ORB). Sluhovia â objekty, ktorÃ© poÅ¾iadavky na serveri spracovÃ¡vajÃº, musia implementovaÅ¥ rozhranie, ktorÃ© je najskÃ´r zadefinovanÃ© pomocou opisnÃ©ho jazyka CORBA IDL (Interface Description Language). Kostra takto zadefinovanÃ©ho objektu je nÃ¡sledne automaticky vygenerovanÃ¡ do cieÄ¾ovÃ©ho jazyka. TÃ¡to kostra obsahuje mechanizmy, ktorÃ© zabezpeÄujÃº komunikÃ¡ciu medzi vzdialenÃ½m sluhom a referenciou objektu, ktorÃ½ ho neskÃ´r zavolÃ¡. ProgramÃ¡tor samozrejme musÃ­ implementovaÅ¥ kÃ³d samotnÃ©ho sluhu, ktorÃ½ sa vykonÃ¡ na serveri. Z pohÄ¾adu pouÅ¾Ã­vateÄ¾a sa takÃ½to vzdialenÃ½ objekt pouÅ¾Ã­va Ãºplne rovnako ako objekt lokÃ¡lny. SpojovacÃ­ softvÃ©r zabezpeÄuje odchytenie volania metÃ³dy, transformÃ¡ciu do formÃ¡tu vhodnÃ©ho na prenos, samotnÃ½ prenos, spracovanie na serveri a spÃ¤tnÃ© zaslanie vÃ½sledku klientovi. VÅ¡etko sa udeje bez toho, aby klientska strana vedela, kde a ako sa samotnÃ¡ poÅ¾iadavka vykonÃ¡. Toto je vÅ¡ak len veÄ¾mi zjednoduÅ¡enÃ½ pohÄ¾ad na problematiku technolÃ³gie distribuovanÃ½ch objektov. Z pohÄ¾adu softvÃ©rovÃ©ho architekta je dÃ´leÅ¾itÃ© si uvedomiÅ¥, akÃ© sÃº zÃ¡kladnÃ© vlastnosti a dÃ´sledky vyuÅ¾itia takÃ©hoto rieÅ¡enia v reÃ¡lnych aplikÃ¡ciÃ¡ch. Â PoÅ¾iadavky na sluhov sÃº volania na vzdialenÃ© objekty a mÃ´Å¾u byÅ¥ pomalÃ© kvÃ´li rÃ½chlostiam transformÃ¡ciÃ­ a prenosu po sieti. Je preto vhodnÃ© takÃ©to volania Äo najviac minimalizovaÅ¥."
122,76,0.323,Modelovanie softvÃ©ru,"Obr. 4.7: NÃ¡vrhovÃ½ diagram tried e-obchodu. â¢ Composite rieÅ¡i vhniezdenÃ© pohÄ¾ady, kde View je Composite alebo Leaf NÃ¡vrhovÃ© vzory je niekedy moÅ¾nÃ© rozpoznaÅ¥ uÅ¾ na zÃ¡klade samotnÃ©ho Å¡trukturÃ¡lneho usporiadania tried a rozhranÃ­, ktorÃ© v nich vystupujÃº. ObrÃ¡zky 4.8â4.10 zobrazujÃº prÃ­klady nÃ¡vrhovÃ½ch vzorov vo forme zaslepenej Å¡truktÃºry a Å¡truktÃºry s obsahom. VÅ¡imnime si, naprÃ­klad, veÄ¾mi charakteristickÃº kombinÃ¡ciu agregÃ¡cie a dedenia v opaÄnom smere vo vzore Composite. V naÅ¡om prÃ­klade bol uplatnenÃ½ vzor Observer, ktorÃ©ho Å¡truktÃºra nie je aÅ¾ takÃ¡ charakteristickÃ¡. Na obrÃ¡zku 4.2 je vyznaÄenÃ½ poznÃ¡mkou umiestnenou medzi triedami, ktorÃ© tento vzor realizujÃº. Ak MVC prirovnÃ¡me k stereotypom Unified Process, triedy oznaÄenÃ© ako entity a control spolu zodpovedajÃº role Model, priÄom boundary zodpovedÃ¡ role View. Rola Controller v tejto analytickej reprezentÃ¡cii Å¡truktÃºry eÅ¡te nie je vyÄlenenÃ¡. DÃ´leÅ¾itÃ© je poznamenaÅ¥, Å¾e napriek podobnosti v pomenovanÃ­ triedy oznaÄenÃ© ako control nezodpovedajÃº role Controller."
76,12,0.321,PRAVDEPODOBNOSÅ¤ A MATEMATICKÃ Å TATISTIKA,"rÃ­me aditivita. Je uÅ¾itoÄnÃ© sledovaÅ¥, ako budeme argumentovaÅ¥ pri obhajovanÃ­ toho, Å¾e kaÅ¾dÃ¡ pravdepodobnosÅ¥ je aditÃ­vna. 1.1.2 PrÃ­klad. Nech pokus spoÄÃ­va v nÃ¡hodnom Å¥ahanÃ­ guÄ¾ky zo Å¡katule, ktorÃ¡ obsahuje 10 guliek: 5 bielych, 3 modrÃ© a 2 ÄervenÃ©. Za vÃ½sledok opÃ¤Å¥ povaÅ¾ujeme farbu vytiahnutej guÄ¾ky. ÄÃ­m sa takÃ½to pokus lÃ­Å¡i od pokusu z 1.1.1? Zrejme ï, S sÃº rovnakÃ© ako v 1.1.1, ale P bude inÃ¡, veÄ vytiahnutie bielej mÃ¡ vÃ¤ÄÅ¡iu pravdepodobnosÅ¥, ako vytiahnutie modrej, alebo Äervenej. KeÄÅ¾e vytiahnutie kaÅ¾dej (z tÃ½ch desiatich guliek) je rovnako moÅ¾nÃ©, tak kladieme P({b}) = 0.5 (pretoÅ¾e 5 z desiatich realizujÃº udalosÅ¥ {b}), P({m})= 0.3 (pretoÅ¾e 3 z desiatich realizujÃº udalosÅ¥ {m}), P({Ä}) = 0.2 (pretoÅ¾e 2 z desiatich realizujÃº udalosÅ¥ {Ä}). TakÃ½to postup je zaiste v zhode s intuÃ­ciou, resp. so skÃºsenosÅ¥ou. MÃ´Å¾eme povedaÅ¥ aj to, Å¾e postupujeme v zhode so znÃ¡mou Laplaceovou definÃ­ciou (mimochodom, s oznaÄenÃ­m definÃ­cia sa dÃ¡ v tomto prÃ­pade polemizovaÅ¥), ktorÃº vÅ¡ak vzÅ¥ahujeme na pomocnÃ½ priestor ï , ktorÃ½ mÃ¡ 10 rovnako moÅ¾nÃ½ch âprvotnÃ½ch vÃ½sledkovâ: ï = {b1, b2, b3, b4, b5, m1, m2, m3, Ä1, Ä2}. Analogicky ako v 1.1.1 (odvolÃ¡vajÃºc sa na aditivitu P), urÄÃ­me pravdepodobnosti udalostÃ­ A = {b, m}, B = {b, Ä}, C = {m, Ä}. Teraz pravdepodobnosÅ¥ P urÄuje tabuÄ¾ka"
190,309,0.321,O softvÃ©ri od A po Z ; Ãvahy nastupujÃºcich profesionÃ¡lov,"PrvÃ© dve z tÃ½chto definÃ­cii sa v podstate zhodujÃº. Tretia definÃ­cia hovorÃ­ o tom, Å¾e pokiaÄ¾ mÃ¡ byÅ¥ nieÄo, produkt, sluÅ¾ba alebo softvÃ©r, kvalitnÃ½ musÃ­ byÅ¥ vÃ½nimoÄnÃ½ a v nieÄom lepÅ¡Ã­ ako ostatnÃ© dostupnÃ© veci. Je len logickÃ©, Å¾e takÃ¡to definÃ­cia nemohla padnÃºÅ¥ na ÃºrodnÃº pÃ´du v komunite programÃ¡torov, ktorÃ½ sa snaÅ¾ia vÅ¡etko robiÅ¥ podÄ¾a moÅ¾nosti Äo najrÃ½chlejÅ¡ie a najjednoduchÅ¡ie. A naviac, keby sa celÃ½ svet pridÅÅ¾al tejto definÃ­cie, Ä¾udia by zrazu s prekvapenÃ­m zistili, Å¾e vÃ¤ÄÅ¡ina toho Äo pouÅ¾Ã­vajÃº je jednoducho nieÄo nekvalitnÃ©. No a to by bola tvrdÃ¡ rana pravdepodobne pre kaÅ¾dÃ©ho Å¾ijÃºceho v dneÅ¡nej spoloÄnosti. Aj keÄ si to vÃ¤ÄÅ¡ina Ä¾udÃ­ nechce priznaÅ¥. MoÅ¾no prÃ¡ve preto sa kvalita softvÃ©ru v sÃºÄasnosti meria podÄ¾a prvÃ½ch dvoch definÃ­ciÃ­. Okrem ich nespornej pravdivosti, ktorÃº vÅ¡etci akosi podvedome cÃ­tia, dÃ¡vajÃº moÅ¾nosÅ¥ vzniku omnoho vÃ¤ÄÅ¡iemu mnoÅ¾stvu kvalitnÃ½ch vecÃ­ ako tretia, oxfordskÃ¡ definÃ­cia. V tom tkvie ich sila, a to je ich veÄ¾kou prednosÅ¥ou a vÃ½hodou. VÅ¡ak kaÅ¾dÃ½ predsa chce robiÅ¥ kvalitnÃ© veci bez toho, aby musel preukazovaÅ¥ vÃ½nimoÄnosÅ¥. Bez ohÄ¾adu na to, Äi sa jednÃ¡ o vÃ½robu hrncov, tlaÄ novÃ­n alebo tvorbu informaÄnÃ©ho systÃ©m pre uchovÃ¡vanie informÃ¡cii o krvnÃ½ch skupinÃ¡ch dobrovoÄ¾nÃ½ch darcov krvi. ÄalÅ¡ou vÃ½hodou alebo aj nevÃ½hodou je fakt, Å¾e poskytujÃº neuveriteÄ¾ne Å¡irokÃ½ priestor pre manipulÃ¡ciu s pojmami kvalita. Ide o jednoduchÃ½ princÃ­p spoÄÃ­vajÃºci v tom, Å¾e pokiaÄ¾ sÃº splnenÃ© zadanÃ© poÅ¾iadavky, produkt je kvalitnÃ½. Za touto jednoduchou implikÃ¡ciou sa toho skrÃ½va viac ako sa zdÃ¡. InÃ½mi slovami aj Ãºplne zle fungujÃºci program, ktorÃ½ nedokÃ¡Å¾e sprÃ¡vne spoÄÃ­taÅ¥ dve ÄÃ­sla sa mÃ´Å¾e s ÄistÃ½m svedomÃ­m oznaÄiÅ¥ za kvalitnÃ½ pokiaÄ¾ zadÃ¡vateÄ¾ omylom, schvÃ¡lne alebo z nepozornosti sÃºhlasil prÃ¡ve s touto jeho vlastnosÅ¥ou. Koniec koncov nevadÃ­, Å¾e to nerobÃ­ to, Äo to mÃ¡ robiÅ¥, najmÃ¤ Å¾e je to podÄ¾a poÅ¾iadaviek a je to kvalitnÃ©. HlavnÃ½ problÃ©m, ktorÃ½ z tÃ½chto definÃ­cii vyplÃ½va je teda nasledovnÃ½: nie Na kvalitu sa je kvalita ako kvalita. PokiaÄ¾ niekto oÄakÃ¡va od filmu vzÃ¡jomnÃ© kynoÅ¾enie dÃ¡ nazeraÅ¥ monÅ¡truÃ³znych robotov a obyvateÄ¾ov naÅ¡ej planÃ©ty, bude zjavne povaÅ¾ovaÅ¥ za rÃ´zne. kvalitnÃ© Ãºplne inÃ© filmy ako niekto s citlivou duÅ¡ou pachtiaci po romantike."
59,598,0.32,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"nemÃ´Å¾e byÅ¥ vo vÅ¡eobecnosti urÄenÃ© jednoznaÄne. ÄalÅ¡Ã­ problÃ©m s inverznÃ½m modelom je, Å¾e jeho urÄenie pomocou diagramu A na Obr. 12.7 nie je cieÄ¾ovo orientovanÃ©. To znamenÃ¡, Å¾e nemusÃ­me nÃ¡jsÅ¥ takÃº akciu, ktorÃ¡ produkuje poÅ¾adovanÃ½ vÃ½stup systÃ©mu. UÄenie sa komplexu vytvorenÃ©ho z inverznÃ©ho a z doprednÃ©ho modelu (pozri Obr. 12.7, diagram B) sa mÃ´Å¾e vykonaÅ¥ podobne ako uÄenie sa komplexu obsahujÃºceho agenta a doprednÃ½ model v predchÃ¡dzajÃºcej podkapitole (pozri Obr. 12.4., diagram B). Podobne, ako je umiestnenÃ½ model doprednÃ©ho szstÃ©mu v kognitÃ­vnom orgÃ¡ne agenta, aj inverznÃ½ model je umiestnenÃ½ ako model inverznÃ©ho systÃ©mu v kognitÃ­vnom orgÃ¡ne agenta."
393,518,0.32,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 2,"ObrÃ¡zok 9-15. Diagram tried predstavenÃ©ho rieÅ¡enia pre transparentnÃº skladbu. OtÃ¡zka na druhÃº stranu znie, Äi je vÃ´bec moÅ¾nÃ© znovupouÅ¾iÅ¥ Äasti vzoru bez fyzickÃ©ho rozdelenia tried spÃ¡jajÃºcich vÅ¡eobecnÃº a domÃ©novo zÃ¡vislÃº ÄasÅ¥ vzoru? Ako uvidÃ­me v Äasti 9.6, je to moÅ¾nÃ© s pomocou Å¡peciÃ¡lnych rozÅ¡Ã­renÃ­. TÃ¡to ÄasÅ¥ mala za cieÄ¾ poukÃ¡zaÅ¥ na netriviÃ¡lnosÅ¥ realizÃ¡cie dekompozÃ­cie vzoru pomocou Å¡tandardnÃ½ch prostriedkov jazyka C++. NavyÅ¡e sa podarilo poukÃ¡zaÅ¥ na nutnosÅ¥ prijatia poruÅ¡enÃ­ v obmedzeniach modelu rolÃ­ v kontexte nÃ¡vrhovÃ©ho vzoru Composite s cieÄ¾om oddeliÅ¥ vÅ¡eobecnÃº ÄasÅ¥ od domÃ©novo zÃ¡vislej Äasti vzoru (napr. v podobe obsadenia role Component triedami ConcreteComponent a CommonComponent, ÄÃ­m sa poruÅ¡ili obmedzenia na poÄet tried obsadenÃ½ch v danej roli)."
59,453,0.318,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"9 RevÃ­zia poznatkov 9.1 ÃvodnÃ© poznÃ¡mky1 ProblÃ©m revÃ­zie poznatkov mÃ¡ vo filozofii a v logike dlhÃº tradÃ­ciu. Stal sa integrÃ¡lnou sÃºÄasÅ¥ou mnohÃ½ch traktÃ¡tov a monografiÃ­ z filozofie poznania (epistemolÃ³gie) a logiky od staroveku aÅ¾ po sÃºÄasnosÅ¥, ktorÃ© obsahovali rozsiahle kapitoly, kde vÃ¤ÄÅ¡inou na fenomenologicko-Å¡pekulatÃ­vnej Ãºrovni sa formulovali zÃ¡sady nÃ¡Å¡ho myslenia, argumentÃ¡cie a zmeny poznatkov vyplÃ½vajÃºcich zo zmien vÃ½chodiskovÃ½ch predpokladov, ich rozÅ¡Ã­renia alebo ÄiastoÄnej falzifikÃ¡cie. TÃ¡to zaujÃ­mavÃ¡ problematika sa stala sÃºÄasÅ¥ou aplikovanej matematickej logiky aÅ¾ koncom minulÃ©ho storoÄia, keÄ jej formÃ¡lny aparÃ¡t bol pouÅ¾itÃ½ na formulÃ¡ciu teÃ³rie revÃ­zie poznatkov. TaktieÅ¾, problÃ©m revÃ­zie poznatkov sa stal v sÃºÄasnosti integrÃ¡lnou ÄasÅ¥ou informatiky a umelej inteligencie a tÃ½m musel prejsÅ¥ z roviny vÅ¡eobecnoÅ¡pekulatÃ­vnej k rovine formÃ¡lno-exaktnej, ktorÃ¡ mÃ´Å¾e slÃºÅ¾iÅ¥ ako zÃ¡klad algoritmizÃ¡cie problematiky revÃ­zie poznatkov na poÄÃ­taÄoch. Tak naprÃ­klad, ak chceme Å¡pecifikovaÅ¥ zÃ¡kladnÃ© epistemickÃ© princÃ­py vÃ½vinu vedy, dynamiku jej vÃ½voja v Äase, tento cieÄ¾ mÃ´Å¾e byÅ¥ realizovanÃ½ na abstraktnej Ãºrovni tak, Å¾e Å¡tudujeme danÃº konzistentnÃº databÃ¡zu poznatkov. TÃ¡to databÃ¡za je v Äase postupne modifikovanÃ¡ elementÃ¡rnymi operÃ¡ciami, ako je dodanie novÃ©ho poznatku a odstrÃ¡nenie pÃ´vodnÃ©ho poznatku. V obidvoch prÃ­padoch tieto operÃ¡cie zmeny mÃ´Å¾u ovplyvÅovaÅ¥ ostatnÃ© poznatky, preto sa vykonÃ¡va ich revÃ­zia, aby sa odstrÃ¡nili prÃ­padnÃ© nekonzistentosti. V poÄiatoÄnom obdobÃ­ vzniku teÃ³rie revÃ­zie poznatkov (80. roky minulÃ©ho storoÄia) zÃ¡kladnÃ© idey boli formulovanÃ© Å¡vÃ©dskym kognitÃ­vnym vedcom Petrom GÃ¤rdenforsom [3,4] a dvojicou americkÃ½ch logikov Carlosom AlchourrrÃ³nom a Davidom Makinsomom [1], ktorÃ­ spoloÄne v r. 1985 publikovali v Journal of Symbolic Logic vÃ½znamnÃº prÃ¡cu [1] (ktorÃ¡ sa v odbornej literatÃºre oznaÄuje akronymom AGM poÄiatoÄnÃ½ch pÃ­smen ich priezvisk v abecednom poriadku jej autorov), v ktorej formulovali zÃ¡kladnÃ© princÃ­py, koncepcie a konÅ¡trukcie teÃ³rie revÃ­zie poznatkov. PrÃ­klad 9.1. Predpokladajme, Å¾e teÃ³ria obsahuje tieto Å¡tyri poznatky: p1 = Â´vÅ¡etky eurÃ³pske labute sÃº bieleÂ´ p2 = Â´vtÃ¡k zachytenÃ½ do siete je labuÅ¥Â´ p3 = Â´vtÃ¡k zachytenÃ½ v sieti pochÃ¡dza zo SlovenskaÂ´ p4 = Â´Slovensko je ÄasÅ¥ EurÃ³pyÂ´ Ak tieto Å¡tyri poznatky tvoria vstup do programu simulujÃºceho logickÃ© usudzovanie, potom ako vÃ½stup z tohto programu dostaneme novÃ½ poznatok p5 = Â´vtÃ¡k zachytenÃ½ v sieti je bielyÂ´ Teraz predpokladajme, Å¾e naÅ¡a databÃ¡za bola doplnenÃ¡ o ÄalÅ¡Ã­ poznatok p6 = Â´vtÃ¡k zachytenÃ½ v sieti je ÄiernyÂ´ Tento novÃ½ âpoznatokâ je v kontradikcii so zÃ¡verom p5 , t. j. platÃ­ p6 ï½ ïp5 . Potom musÃ­me vykonaÅ¥ revÃ­ziu databÃ¡zy, aby sme odstrÃ¡nili tÃºto nekonzistentnosÅ¥, t. j. niektorÃ½ poznatok z pÃ´vodnej databÃ¡zy {p1, p2, p3, p4} musÃ­ byÅ¥ odstrÃ¡nenÃ½ alebo modifikovanÃ½. Tak naprÃ­klad, ak poznatok p1 nahradÃ­me novÃ½m poznatkom"
43,31,0.318,Objektovo orientovanÃ© programovanie v C++,"1.7 DediÄnosÅ¥ Ak sa pozrieme okolo nÃ¡s, zistÃ­me, Å¾e objekty reÃ¡lneho sveta sÃº hierarchicky usporiadanÃ©. To znamenÃ¡, Å¾e vÅ¡etky patria do nejakej skupiny, alebo ak chceme triedy, ktorÃ¡ sa Äalej mÃ´Å¾e deliÅ¥ na menÅ¡ie skupiny (podtriedy) charakteristickÃ© nejakou vlastnosÅ¥ou a s takÃ½mto delenÃ­m mÃ´Å¾eme postupovaÅ¥ Äalej do rÃ´znej hÄºbky. Ako prÃ­klad si mÃ´Å¾eme uviesÅ¥ triedu Å¾ivÃ½ch organizmov. Ich spoloÄnou vlastnosÅ¥ou mÃ´Å¾e byÅ¥ naprÃ­klad dÄºÅ¾ka Å¾ivota. V tejto triede je obsiahnutÃ¡ podtrieda Å¾ivoÄÃ­chov, ktorÃ© okrem dÄºÅ¾ky Å¾ivota mÃ´Å¾u byÅ¥ charakterizovanÃ© spÃ´sobom pohybu. Podtriedou Å¾ivoÄÃ­chov je hmyz, ktorÃ©ho ÄalÅ¡ou vlastnosÅ¥ou je poÄet nÃ´h. Medzi hmyzom mÃ´Å¾eme Äalej nÃ¡jsÅ¥ podtriedu motÃ½Ä¾ov, ktorÃ© okrem vÅ¡etkÃ½ch uvedenÃ½ch vlastnostÃ­ majÃº navyÅ¡e eÅ¡te farbu krÃ­del. VidÃ­me, Å¾e pri takomto delenÃ­ vÅ¾dy existujÃº nejakÃ© spoloÄnÃ© vlastnosti pre vÅ¡etky objekty danej triedy a kaÅ¾dÃ¡ ÄalÅ¡ia podtrieda je okrem tÃ½chto vlastnostÃ­ charakteristickÃ¡ nieÄim novÃ½m, Äo ju robÃ­ odliÅ¡nou. MÃ´Å¾eme teda povedaÅ¥, Å¾e objekt nejakej podtriedy mÃ¡ na jednej strane vlastnosti, ktorÃ© v podstate zdedil tÃ½m, Å¾e je aj prvkom nejakej vyÅ¡Å¡ie postavenej triedy, a na druhej strane mÃ¡ aj svoje Å¡peciï¬ckÃ© vlastnosti, ktorÃ© vyÅ¡Å¡ie postavenÃ¡ trieda nemÃ¡. Teda kaÅ¾dÃ½ motÃ½Ä¾ mÃ¡ urÄitÃ½ poÄet nÃ´h z toho dÃ´vodu, Å¾e je to hmyz, ale farbu krÃ­del mÃ¡ preto, Å¾e je motÃ½Ä¾, pretoÅ¾e nie kaÅ¾dÃ½ hmyz mÃ¡ aj krÃ­dla. Objektovo orientovanÃ© programovanie vyuÅ¾Ã­va takÃ©to hierarchickÃ© usporiadanie na prehÄ¾adnejÅ¡iu a efektÃ­vnejÅ¡iu organizÃ¡ciu programu. Tento princÃ­p, pri ktorom kaÅ¾dÃ¡ trieda mÃ´Å¾e maÅ¥ podtriedy, ktorÃ© sÃº nieÄÃ­m Å¡peciï¬ckÃ©, a pri ktorom prvky podtriedy preberajÃº vlastnosti triedy, z ktorej pÃ´vodne pochÃ¡dzajÃº, sa nazÃ½va dediÄnosÅ¥ (angl. inheritance). OpÃ¤Å¥ platÃ­, Å¾e dediÄnosÅ¥ je veÄ¾mi uÅ¾itoÄnÃ¡ najmÃ¤ pri rozsiahlych programoch, v ktorÃ½ch sa vyskytujÃº triedy so spoloÄnÃ½mi vlastnosÅ¥ami alebo s rovnakÃ½mi metÃ³dami. DediÄnosÅ¥ umoÅ¾Åuje tieto spoloÄnÃ© prvky deï¬novaÅ¥ na jednom mieste, v jednej rodiÄovskej triede, a v triedach, ktorÃ© sÃº od nej odvodenÃ©, sa potom uvÃ¡dzajÃº len novÃ© Ãºdaje a metÃ³dy, ktorÃ© rodiÄovskÃ¡ trieda neobsahuje. Takto sa skracuje"
190,358,0.318,O softvÃ©ri od A po Z ; Ãvahy nastupujÃºcich profesionÃ¡lov,"KaÅ¾dÃ¡ snaha, aktivita Äi samotnÃ¡ prÃ¡ca so sebou prinÃ¡Å¡a urÄitÃº ÃºroveÅ nejasnostÃ­ ohÄ¾adne toho, ako sa bude postupne vyvÃ­jaÅ¥, resp. akÃ© vÃ½sledky prinesie. Podobne je to aj pri vÃ½voji softvÃ©rovÃ©ho systÃ©mu. S kaÅ¾dÃ½m ÄalÅ¡Ã­m krokom vÃ½voja, s kaÅ¾dÃ½m novÃ½m nÃ¡vrhom a podnetom sÃºvisia rizikÃ¡, ktorÃ© tieto kroky sprevÃ¡dzajÃº. Samozrejme, vÅ¡eobecnou snahou, moÅ¾no rizikÃ¡ eliminovaÅ¥, resp. Äo najviac obmedziÅ¥. AvÅ¡ak ÃºplnÃ© vyradenie vÅ¡etkÃ½ch moÅ¾nÃ½ch rizÃ­k je takmer nemoÅ¾nÃ©. Preto je nutnÃ© pozrieÅ¥ sa na rizikovÃ© oblasti z druhej strany, to znamenÃ¡, snaÅ¾iÅ¥ sa ich odhadnÃºÅ¥ a predvÃ­daÅ¥ a nÃ¡sledne ich Äo najefektÃ­vnejÅ¡ie riadiÅ¥. PodÄ¾a mÃ´jho nÃ¡zoru je oveÄ¾a lepÅ¡ie maÅ¥ v projekte viac rizÃ­k, nad ktorÃ½mi mÃ¡me kontrolu, ako menej takÃ½ch rizÃ­k, o ktorÃ½ch nevieme. V kontexte tÃ­movÃ©ho projektu (projekt na univerzite, ktorÃ½ mÃ¡ spravidla Å¡esÅ¥ Älenov) nadobÃºda oblasÅ¥ rizÃ­k ÄalÅ¡ie rozmery spojenÃ© s manaÅ¾mentom tÃ­mu a komunikÃ¡ciou v tÃ­me. VÃ¤ÄÅ¡ina softvÃ©rovÃ½ch projektov sa vyvÃ­ja v podmienkach, ktorÃ© nie sÃº vÅ¾dy Ãºplne predvÃ­dateÄ¾nÃ© a v ktorÃ½ch existuje veÄ¾a faktorov, ktorÃ© mÃ´Å¾u ovplyvniÅ¥ vÃ½slednÃ½ produkt. Projekt povaÅ¾uje za ÃºspeÅ¡nÃ½ vtedy, ak spÄºÅa poÅ¾iadavky (funkcionalitu, spoÄ¾ahlivosÅ¥, udrÅ¾ovateÄ¾nosÅ¥, rozÅ¡Ã­riteÄ¾nosÅ¥, efektivita, schopnosÅ¥ zaÄleniÅ¥ sa do vÃ¤ÄÅ¡ieho projektu a schopnosÅ¥ prevÃ¡dzkovaÅ¥ systÃ©m v danÃ½ch podmienkach), dokonÄÃ­ sa v danom termÃ­ne a v rÃ¡mci stanovenÃ©ho rozpoÄtu [6]. VÃ½skum v [4], ukazuje, Å¾e len jedna Å¡estina vÅ¡etkÃ½ch projektov bola ukonÄenÃ¡ naÄas a v rÃ¡mci danÃ©ho rozpoÄtu, jedna tretina projektov bola zruÅ¡enÃ¡ a viac ako polovica priniesla len obmedzenÃ© vÃ½sledky. V Å¡tÃºdii [3] sa ukÃ¡zalo, Å¾e hlavnÃº Ãºlohu vo vysokej neÃºspeÅ¡nosti projektov zohrÃ¡vajÃº projektovÃ­ manaÅ¾Ã©ri, ktorÃ­ v prvÃ½ch fÃ¡zach projektu nedostatoÄne zohÄ¾adÅujÃº moÅ¾nÃ© rizikÃ¡ vyplÃ½vajÃºce z projektu. Po- NeÃºspeÅ¡nosÅ¥ tvrdzuje to tieÅ¾ Å¡tatistika, ktorÃ¡ ukazuje, Å¾e asi tretina projektov sa ukonÄÃ­ projektov Äasto s neÃºspechom aÅ¾ vo fÃ¡ze implementÃ¡cie. Preto je dnes jasnÃ©, Å¾e manaÅ¾- spÃ´sobujÃº projektovÃ­ manaÅ¾Ã©ri ment rizÃ­k musÃ­ byÅ¥ samozrejmou sÃºÄasÅ¥ou prÃ¡ce v tÃ­movom projekte."
59,578,0.318,KognitÃ­vna veda v kontexte informatickÃ½ch vied,"12 Riadenie zloÅ¾itÃ½ch systÃ©mov a ich modely 12.1 ÃvodnÃ© poznÃ¡mky ProblÃ©m riadenia zloÅ¾itÃ½ch systÃ©mov (napr. banky, systÃ©mu zÃ¡sobovania veÄ¾komesta, vysokej pece na vÃ½robu Å¾eleza, ...), ktorÃ½ch modely dobre nepoznÃ¡me (ak poznÃ¡me, tak len vo veÄ¾mi nedokonalej forme), sÃº tradiÄnÃ½ problÃ©m umelej inteligencie a kognitÃ­vnej vedy. MetÃ³dy modernej umelej inteligencie sÃº schopnÃ© poskytnÃºÅ¥ novÃ½ pohÄ¾ad na tento Å¡tandardnÃ½ problÃ©m informatiky, poskytujÃº nielen jeho novÃº interpretÃ¡ciu, ale umoÅ¾ÅujÃº aj jeho implementÃ¡ciu pomocou neurÃ³novÃ½ch sietÃ­. Podobne, ako v predchÃ¡dzajÃºcich Äastiach naÅ¡ej prednÃ¡Å¡ky, z dÃ´vodov neutrality naÅ¡ich Ãºvah budeme pouÅ¾Ã­vaÅ¥ termÃ­n âagentâ na oznaÄenie inteligentnÃ©ho jedinca s kognitÃ­vnym orgÃ¡nom (mozgom), ktorÃ©ho cieÄ¾om je riadiÅ¥ zloÅ¾itÃ½ systÃ©m. KognitÃ­vny orgÃ¡n agenta (informatickÃ½ termÃ­n pre Ä¾udskÃ½ mozog) je schopnÃ½ vykonÃ¡vaÅ¥ zloÅ¾itÃ© kognitÃ­vne aktivity, akÃ½mi sÃº uÄenie, plÃ¡novanie, vyhodnocovanie, rieÅ¡enie problÃ©mov, vnÃ­manie okolia, a pod. Tieto schopnosti kognitÃ­vneho orgÃ¡nu sa vyuÅ¾Ã­vajÃº pri tvorbe vnÃºtornÃ½ch modelov riadenÃ©ho systÃ©mu, ktorÃ© tvoria ÃºstrednÃº zloÅ¾ku vyuÅ¾Ã­vanÃº pri riadenÃ­ zloÅ¾itÃ½ch systÃ©mov. V tejto prednÃ¡Å¡ke budeme Å¡tudovaÅ¥ model distanÄnÃ©ho uÄenia (angl. distal learning), ktorÃ½ bol navrhnutÃ½ poÄiatkom 90. rokov americkÃ½mi informatikmi a kognitÃ­vnymi vedcami, Michaleom Jordanom a Davidom Rumelhartom [2], ktorÃ­ sa zaslÃºÅ¾ili o rozvoj modernÃ½ch konekcionistickÃ½ch metÃ³d a ich aplikÃ¡cie v umelej inteligencii a kognitÃ­vnej vede. DistanÄnÃ© uÄenie slÃºÅ¾i ako urÄitÃ¡ alternatÃ­va k uÄeniu s odmenou a trestom (pozri prednÃ¡Å¡ku 5), poskytuje rieÅ¡enia, ktorÃ© sÃº pre psycholÃ³gov uÄenia akceptovateÄ¾nejÅ¡ie ako vÃ½sledky poskytovanÃ© uÄenÃ­m s odmenou a trestom a taktieÅ¾ mÃ´Å¾u slÃºÅ¾iÅ¥ ako priamy nÃ¡vod na implementÃ¡ciu systÃ©mov riadenia zloÅ¾itÃ½ch systÃ©mov. stav systÃ©mu stav systÃ©mu"
184,221,0.318,Å tÃºdie vybranÃ½ch tÃ©m programovÃ½ch a informaÄnÃ½ch 3,"ObrÃ¡zok 3-10. TransformÃ¡cie modelov v MDA. MDA je zastreÅ¡enÃ© radom OMG Å¡tandardov, vrÃ¡tane UML, MOF (Meta-Object Facility), XMI (XML Metadata Interchange) a CWM (Common Warehouse Metamodel) a taktieÅ¾ obsahuje smernice a Å¡tandardy aj pre transformÃ¡cie modelov a generickÃ© sluÅ¾by. Å tandardy MDA tak spoloÄne definujÃº spÃ´sob, ktorÃ½m je aj za pomoci nÃ¡strojov kompatibilnÃ½ch s MDA moÅ¾nÃ© vyvÃ­jaÅ¥ systÃ©my. Modely v MDA je nutnÃ© Å¡pecifikovaÅ¥ v modelovacom jazyku. MÃ´Å¾e Ã­sÅ¥ o vÅ¡eobecnÃ© modelovacie jazyky pouÅ¾iteÄ¾nÃ© vo viacerÃ½ch domÃ©nach (napr. UML), ale aj o domÃ©novo Å¡pecifickÃ© modelovacie jazyky. MOF tu zohrÃ¡va Ãºlohu metamodelovacieho jazyka, ktorÃ½ umoÅ¾Åuje Å¡pecifikovaÅ¥ inÃ© modelovacie jazyky a zÃ¡roveÅ definuje spÃ´sob ukladania modelov vytvorenÃ½ch v tÃ½chto jazykoch do XML dokumentov. AkÃ½koÄ¾vek existujÃºci modelovacÃ­ jazyk je teda po vytvorenÃ­ jeho MOF reprezentÃ¡cie uÅ¾ moÅ¾nÃ© povaÅ¾ovaÅ¥ za kompatibilnÃ½ s MDA. PrÃ­kladmi takto definovanÃ½ch modelovacÃ­ch jazykov sÃº, aj keÄ pomerne vÅ¡eobecnÃ©, UML a CWM, ktorÃ© sÃº zÃ¡roveÅ sÃºÄasÅ¥ou balÃ­ka MDA Å¡tandardov. ZatiaÄ¾ Äo UML sa sÃºstreÄuje skÃ´r na objektovÃ© modelovanie, CWM sa naopak zameriava na dÃ¡tovÃ© modelovanie. Spojenie XMI a MOF navyÅ¡e umoÅ¾Åuje automatickÃº serializÃ¡ciu modelov do Å¡tandardizovanÃ½ch XML dokumentov, ÄÃ­m sa zvyÅ¡ujÃº moÅ¾nosti ÄalÅ¡ieho spracovania modelov v rÃ´znych nÃ¡strojoch. PrÃ­kladom takÃ©hoto ÃºspeÅ¡nÃ©ho vyuÅ¾itia XMI je Å¡tandardizovanÃ¡ XML schÃ©ma pre UML modely slÃºÅ¾iaca ako vÃ½mennÃ½ formÃ¡t medzi modelovacÃ­mi nÃ¡strojmi. MDA sa snaÅ¾Ã­ pokryÅ¥ vÅ¡etky fÃ¡zy procesu vÃ½voja softvÃ©ru, od domÃ©novÃ½ch modelov, cez analytickÃ© a nÃ¡vrhovÃ© modely aÅ¾ po modely samotnÃ©ho kÃ³du, priÄom dÃ´raz sa kladie na Å¡tandardizÃ¡ciu vÃ½mennÃ½ch formÃ¡tov samotnÃ½ch modelov."
